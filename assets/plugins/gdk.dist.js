(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var b = o.split("/");
                b = b[b.length - 1];
                if (!t[b]) {
                    var a = "function" == typeof __require ? __require : void 0;
                    if (a) return a(b, u);
                    throw new Error("Cannot find module '" + o + "'");
                }
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f, function(e) {
                var n = e == "gdk" ? gdkEntry : t[o][1][e];
                return s(n || e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var gdkEntry = r[0];
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "bd213W6FuFL0YA0OywcxdgH", "BaseWaitAction");
        var BaseWaitAction = cc.Class({
            extends: require("../FsmStateAction"),
            properties: {
                isWait: {
                    default: true,
                    tooltip: CC_DEV && "等待完成"
                }
            }
        });
        module.exports = BaseWaitAction;
        cc._RF.pop();
    }, {
        "../FsmStateAction": 35
    } ],
    2: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "4ee2e2RVoVPG7chIp5dF1xU", "AddPopupAction");
        var gdk = require("gdk");
        var AddPopupAction = cc.Class({
            name: "AddPopupAction",
            extends: require("../../FsmStateAction"),
            info: "",
            properties: {
                prefab: cc.Prefab,
                mask: true
            },
            onEnter() {
                gdk.gui.addPopup(this.prefab, mask);
                this.finish();
            }
        });
        require("../../Fsm").addAction(AddPopupAction, "GUI", CC_EDITOR && {
            tooltip: "弹出一个面板"
        });
        module.exports = AddPopupAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    3: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "9d5b7eg9IhNN7LLySabm05u", "HideAllWaitingAction");
        var gdk = require("gdk");
        var HideAllWaitingAction = cc.Class({
            name: "HideAllWaitingAction",
            extends: require("../../FsmStateAction"),
            properties: {},
            onEnter() {
                gdk.gui.hideAllWaiting();
                this.finish();
            }
        });
        require("../../Fsm").addAction(HideAllWaitingAction, "GUI");
        module.exports = HideAllWaitingAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    4: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "bccb0HZzt5IJKxCJFa44BdJ", "HideLoadingAction");
        var gdk = require("gdk");
        var HideLoadingAction = cc.Class({
            name: "HideLoadingAction",
            extends: require("../../FsmStateAction"),
            properties: {},
            onEnter() {
                gdk.gui.hideLoading();
                this.finish();
            }
        });
        require("../../Fsm").addAction(HideLoadingAction, "GUI");
        module.exports = HideLoadingAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    5: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "0ce83CZpU9P9rfwZa1vMDGH", "HideNodeAction");
        var gdk = require("gdk");
        var HideNodeAction = cc.Class({
            name: "HideNodeAction",
            extends: require("../BaseWaitAction"),
            properties: {
                target: cc.Node,
                effect: true
            },
            onEnter() {
                if (this.isWait) gdk.NodeTool.hide(this.target, this.effect, () => {
                    this.finish();
                }); else {
                    gdk.NodeTool.hide(this.target, this.effect);
                    this.finish();
                }
            }
        });
        require("../../Fsm").addAction(HideNodeAction, "GUI");
        module.exports = HideNodeAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../BaseWaitAction": 1,
        gdk: "gdk"
    } ],
    6: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "49e900VvApNKZPpcdGvFnoA", "HidePanelAction");
        let gdk = require("gdk");
        let PanelId = gdk.PanelId;
        let PanelManager = gdk.PanelManager;
        let HidePanelAction = cc.Class({
            name: "HidePanelAction",
            extends: require("../../FsmStateAction"),
            info: "",
            properties: {
                _panelName: "",
                panel: {
                    get() {
                        return PanelId[this._panelName] || 0;
                    },
                    set(value) {
                        this._panelName = PanelId[value];
                    },
                    visible: true,
                    type: PanelId,
                    tooltip: CC_DEV && "如果没可选值，请先配置gdk.PanelId"
                }
            },
            onEnter() {
                PanelManager.hide(this._panelName);
                this.finish();
            }
        });
        require("../../Fsm").addAction(HidePanelAction, "GUI", CC_EDITOR && {
            tooltip: "关闭一个面板"
        });
        module.exports = HidePanelAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    7: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "371b780vlpMlrvx8FyJx2LN", "HideViewAction");
        var gdk = require("gdk");
        var HideViewAction = cc.Class({
            name: "HideViewAction",
            extends: require("../../FsmStateAction"),
            properties: {
                prefab: cc.Prefab
            },
            onEnter() {
                gdk.gui.hideView(this.prefab);
                this.finish();
            }
        });
        require("../../Fsm").addAction(HideViewAction, "GUI");
        module.exports = HideViewAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    8: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "fd0bfTJ7vNIuqZU5j9xFR0d", "HideWaitingAction");
        var gdk = require("gdk");
        var HideWaitingAction = cc.Class({
            name: "HideWaitingAction",
            extends: require("../../FsmStateAction"),
            properties: {
                tag: {
                    default: "ShowWaitingAction",
                    tooltip: CC_DEV && "将要隐藏的Waiting圈的标记"
                }
            },
            onEnter() {
                gdk.gui.hideWaiting(this.tag);
                this.finish();
            }
        });
        require("../../Fsm").addAction(HideWaitingAction, "GUI");
        module.exports = HideWaitingAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    9: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "db5c7LlVf1Gb6b0m3J6XUo0", "OpenPanelAction");
        let gdk = require("gdk");
        let PanelId = gdk.PanelId;
        let PanelManager = gdk.PanelManager;
        let BasePanel = gdk.BasePanel;
        let OpenPanelAction = cc.Class({
            name: "OpenPanelAction",
            extends: require("../BaseWaitAction"),
            info: "",
            properties: {
                _panelName: "",
                panel: {
                    get() {
                        return PanelId[this._panelName] || 0;
                    },
                    set(value) {
                        this._panelName = PanelId[value];
                    },
                    visible: true,
                    type: PanelId,
                    tooltip: CC_DEV && "如果没可选值，请先配置gdk.PanelId"
                },
                isBlock: {
                    default: false,
                    tooltip: CC_DEV && "是否阻塞到界面关闭"
                }
            },
            onEnter() {
                var b = this.isBlock || this.isWait;
                PanelManager.open(this._panelName, node => {
                    var basePanel = node && node.getComponent(BasePanel);
                    if (this.isBlock && basePanel) {
                        basePanel.onClose.once(() => {
                            this.finish();
                        }, this);
                    } else if (b) {
                        this.finish();
                    }
                }, this, null, b ? this.finish : null);
                if (!b) {
                    this.finish();
                }
            }
        });
        require("../../Fsm").addAction(OpenPanelAction, "GUI", CC_EDITOR && {
            tooltip: "打开一个面板"
        });
        module.exports = OpenPanelAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../BaseWaitAction": 1,
        gdk: "gdk"
    } ],
    10: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "5d813HPMfFLJ76HG7yxrxxW", "RemoveAllPopupAction");
        var gdk = require("gdk");
        var RemoveAllPopupAction = cc.Class({
            name: "RemoveAllPopupAction",
            extends: require("../../FsmStateAction"),
            properties: {
                popup: true,
                alert: true,
                waiting: true
            },
            onEnter() {
                if (this.popup) {
                    gdk.gui.removeAllPopup();
                }
                if (this.alert) {
                    gdk.gui.hideAllAlert();
                }
                if (this.waiting) {
                    gdk.gui.hideAllWaiting();
                }
                this.finish();
            }
        });
        require("../../Fsm").addAction(RemoveAllPopupAction, "GUI");
        module.exports = RemoveAllPopupAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    11: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "35a29i0CB1C7JC2IYHcrpWj", "SetActiveAction");
        var SetActiveAction = cc.Class({
            name: "SetActiveAction",
            extends: require("../../FsmStateAction"),
            properties: {
                target: cc.Node,
                isActive: true
            },
            onEnter() {
                this.node.active = this.isActive;
                this.finish();
            }
        });
        require("../../Fsm").addAction(SetActiveAction, "GUI");
        module.exports = SetActiveAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35
    } ],
    12: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ffe6cQOWLtGeZDPvpJriDkc", "ShowAlertAction");
        var gdk = require("gdk");
        var ShowAlertAction = cc.Class({
            name: "ShowAlertAction",
            extends: require("../../FsmStateAction"),
            properties: {
                title: "",
                text: "",
                buttons: {
                    default: [],
                    type: cc.String
                },
                events: {
                    default: [],
                    type: cc.String
                }
            },
            onEnter() {
                this.alert = gdk.gui.showAlert(this.text, this.title, null, function(index) {
                    this.alert = null;
                    if (index != -1) {
                        var event = this.events[index];
                        if (event) this.sendEvent(event);
                    }
                    this.finish();
                }, this, this.buttons);
            }
        });
        require("../../Fsm").addAction(ShowAlertAction, "GUI", CC_EDITOR && {
            tooltip: "弹出一个提示框，要求用户操作后才可以继续执行",
            finishType: "op"
        });
        module.exports = ShowAlertAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    13: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "72f2dvxSVZOZYGKbWRtCNup", "ShowLoadingAction");
        var gdk = require("gdk");
        var ShowLoadingAction = cc.Class({
            name: "ShowLoadingAction",
            extends: require("../../FsmStateAction"),
            properties: {
                text: "",
                prefabUuid: ""
            },
            onEnter() {
                let resId = gdk.Tool.getResIdByNode(this.node);
                gdk.rm.loadResBy(resId, this.prefabUuid, cc.Prefag, prefab => {
                    if (!this.active) return;
                    gdk.gui.getCurrentLoading(prefab);
                    gdk.gui.showLoading(this.text);
                    this.finish();
                });
            }
        });
        require("../../Fsm").addAction(ShowLoadingAction, "GUI");
        module.exports = ShowLoadingAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    14: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ca5167Zv8xAcpgtJYatmhx8", "ShowMessageAction");
        var gdk = require("gdk");
        var ShowMessageAction = cc.Class({
            name: "ShowMessageAction",
            extends: require("../../FsmStateAction"),
            properties: {
                text: ""
            },
            onEnter() {
                gdk.gui.showMessage(this.text);
                this.finish();
            }
        });
        require("../../Fsm").addAction(ShowMessageAction, "GUI");
        module.exports = ShowMessageAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    15: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "edef9rvRn9CYb9RgJg8Ag0A", "ShowNodeAction");
        var gdk = require("gdk");
        var ShowNodeAction = cc.Class({
            name: "ShowNodeAction",
            extends: require("../BaseWaitAction"),
            properties: {
                target: cc.Node,
                effect: true
            },
            onEnter() {
                if (this.isWait) gdk.NodeTool.show(this.target, this.effect, () => {
                    this.finish();
                }); else {
                    gdk.NodeTool.show(this.target, this.effect);
                    this.finish();
                }
            }
        });
        require("../../Fsm").addAction(ShowNodeAction, "GUI");
        module.exports = ShowNodeAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../BaseWaitAction": 1,
        gdk: "gdk"
    } ],
    16: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "1dd217nJE9BBpO5C3yaRiFk", "ShowViewAction");
        var gdk = require("gdk");
        var ShowViewAction = cc.Class({
            name: "ShowViewAction",
            extends: require("../../FsmStateAction"),
            properties: {
                prefab: cc.Prefab
            },
            onEnter() {
                gdk.gui.showView(this.prefab);
                this.finish();
            }
        });
        require("../../Fsm").addAction(ShowViewAction, "GUI");
        module.exports = ShowViewAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    17: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "7b5d75fsdlEpKx9WgocQmM0", "ShowWaitingAction");
        var gdk = require("gdk");
        var ShowWaitingAction = cc.Class({
            name: "ShowWaitingAction",
            extends: require("../../FsmStateAction"),
            properties: {
                tag: {
                    default: "ShowWaitingAction",
                    tooltip: CC_DEV && "将要显示的Waiting圈的标记"
                },
                delay: {
                    default: 0,
                    tooltip: CC_DEV && "延时显示Waiting圈"
                },
                text: ""
            },
            onEnter() {
                gdk.gui.showWaiting(this.text, this.tag, 0, null, null, this.delay);
                this.finish();
            }
        });
        require("../../Fsm").addAction(ShowWaitingAction, "GUI", CC_EDITOR && {
            tooltip: "提示待待"
        });
        module.exports = ShowWaitingAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    18: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "14ea6DOxnBCRYlC2r3mj6Kn", "ModuleAction");
        let ModuleAction = cc.Class({
            extends: require("../FsmStateAction"),
            properties: {},
            _enter(node, fsm, state) {
                this._setActive(true);
                let _super = cc.js.getSuper(this.__proto__.constructor);
                if (_super && _super.prototype && _super.prototype._enter) {
                    _super.prototype._enter.call(this, node, fsm, state);
                }
            },
            _exit() {
                let _super = cc.js.getSuper(this.__proto__.constructor);
                if (_super && _super.prototype && _super.prototype._exit) {
                    _super.prototype._exit.call(this);
                }
                if (this._fsm == null) return;
                this._setActive(false);
            }
        });
        module.exports = ModuleAction;
        cc._RF.pop();
    }, {
        "../FsmStateAction": 35
    } ],
    19: [ function(require, module, exports) {
        require("./BaseWaitAction");
        require("./ModuleAction");
        require("./GUI/AddPopupAction");
        require("./GUI/HideAllWaitingAction");
        require("./GUI/HideLoadingAction");
        require("./GUI/HideNodeAction");
        require("./GUI/HideViewAction");
        require("./GUI/HideWaitingAction");
        require("./GUI/HidePanelAction");
        require("./GUI/OpenPanelAction");
        require("./GUI/RemoveAllPopupAction");
        require("./GUI/SetActiveAction");
        require("./GUI/ShowAlertAction");
        require("./GUI/ShowLoadingAction");
        require("./GUI/ShowMessageAction");
        require("./GUI/ShowNodeAction");
        require("./GUI/ShowViewAction");
        require("./GUI/ShowWaitingAction");
        require("./system/DestoryNodeAction");
        require("./system/DestorySelfAction");
        require("./system/LoadSceneAction");
        require("./system/PauseAction");
        require("./system/PlaySoundAction");
        require("./system/PreloadModuleAction");
        require("./system/PreloadPanelAction");
        require("./system/PreloadSceneAction");
        require("./system/SendEventAction");
        require("./system/SendGdkEventAction");
        require("./system/WaitAction");
        require("./system/WaitFrameAction");
    }, {
        "./BaseWaitAction": 1,
        "./GUI/AddPopupAction": 2,
        "./GUI/HideAllWaitingAction": 3,
        "./GUI/HideLoadingAction": 4,
        "./GUI/HideNodeAction": 5,
        "./GUI/HidePanelAction": 6,
        "./GUI/HideViewAction": 7,
        "./GUI/HideWaitingAction": 8,
        "./GUI/OpenPanelAction": 9,
        "./GUI/RemoveAllPopupAction": 10,
        "./GUI/SetActiveAction": 11,
        "./GUI/ShowAlertAction": 12,
        "./GUI/ShowLoadingAction": 13,
        "./GUI/ShowMessageAction": 14,
        "./GUI/ShowNodeAction": 15,
        "./GUI/ShowViewAction": 16,
        "./GUI/ShowWaitingAction": 17,
        "./ModuleAction": 18,
        "./system/DestoryNodeAction": 20,
        "./system/DestorySelfAction": 21,
        "./system/LoadSceneAction": 22,
        "./system/PauseAction": 23,
        "./system/PlaySoundAction": 24,
        "./system/PreloadModuleAction": 25,
        "./system/PreloadPanelAction": 26,
        "./system/PreloadSceneAction": 27,
        "./system/SendEventAction": 28,
        "./system/SendGdkEventAction": 29,
        "./system/WaitAction": 30,
        "./system/WaitFrameAction": 31
    } ],
    20: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "a9463J4NdNOOLBAMjAUqVkp", "DestoryNodeAction");
        var DestoryNodeAction = cc.Class({
            name: "DestoryNodeAction",
            extends: require("../../FsmStateAction"),
            properties: {
                target: cc.Node
            },
            onEnter() {
                this.target.destory();
                this.finish();
            }
        });
        require("../../Fsm").addAction(DestoryNodeAction, "System", CC_EDITOR && {
            tooltip: "销毁一个节点"
        });
        module.exports = DestoryNodeAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35
    } ],
    21: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "e5451BmzXFGCoeDMJbNG+FE", "DestorySelfAction");
        var DestorySelfAction = cc.Class({
            name: "DestorySelfAction",
            extends: require("../../FsmStateAction"),
            properties: {},
            onEnter() {
                this.node.destory();
                this.finish();
            }
        });
        require("../../Fsm").addAction(DestorySelfAction, "System", CC_EDITOR && {
            tooltip: "销毁自身"
        });
        module.exports = DestorySelfAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35
    } ],
    22: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ddebaWN5WNCTKZuYUJe3/Z7", "LoadSceneAction");
        let gdk = require("gdk");
        let SceneId = gdk.SceneId;
        let Log = gdk.Log;
        let LoadSceneAction = cc.Class({
            name: "LoadSceneAction",
            extends: require("../BaseWaitAction"),
            properties: {
                _sceneName: "",
                scene: {
                    get() {
                        return SceneId[this._sceneName] || 0;
                    },
                    set(value) {
                        this._sceneName = SceneId[value];
                    },
                    type: SceneId,
                    tooltip: CC_DEV && "如果没可选值，请先配置gdk.SceneId"
                }
            },
            onEnter() {
                var scene = SceneId.getValue(this._sceneName);
                gdk.scene.load(scene, err => {
                    if (!err) {
                        if (this.isWait) {
                            this.finish();
                        }
                    }
                });
                if (!this.isWait) {
                    this.finish();
                }
            }
        });
        require("../../Fsm").addAction(LoadSceneAction, "System", CC_EDITOR && {
            tooltip: "加载一个场景",
            finishType: "wait"
        });
        module.exports = LoadSceneAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../BaseWaitAction": 1,
        gdk: "gdk"
    } ],
    23: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "cbf26NzJMNP34vawN0Iujqo", "PauseAction");
        var PauseAction = cc.Class({
            name: "PauseAction",
            extends: require("../../FsmStateAction"),
            onEnter() {
                this.fsm.pause();
                this.finish();
            }
        });
        require("../../Fsm").addAction(PauseAction, "System", CC_EDITOR && {
            tooltip: "暂停执行动作",
            info: "暂停执行",
            finishType: "pause"
        });
        module.exports = PauseAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35
    } ],
    24: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "7bfbexEzBREZ5N12NHI3Nuc", "PlaySoundAction");
        let gdk = require("gdk");
        let Tools = gdk.Tools;
        let SoundId = gdk.SoundId;
        let SoundManager = gdk.SoundManager;
        let PlaySoundAction = cc.Class({
            name: "PlaySoundAction",
            extends: require("../../FsmStateAction"),
            properties: {
                _soundName: "",
                sound: {
                    get() {
                        return SoundId[this._soundName] || 0;
                    },
                    set(value) {
                        this._soundName = SoundId[value];
                    },
                    type: SoundId,
                    visible: true,
                    serializable: true,
                    tooltip: CC_DEV && "如果没可选值，请先配置gdk.SoundId"
                },
                clip: {
                    default: null,
                    type: cc.AudioClip,
                    tooltip: CC_DEV && "设置此值会覆盖id的值,推荐使用id设置，因为设置这里会影响场景加载速度，场景会把cc.AudioClip预加载进来"
                }
            },
            onEnter() {
                if (this.clip) {
                    SoundManager.playAudio(this.clip);
                } else {
                    let resId = Tools.getResIdByNode(this.node);
                    SoundManager.play(resId, SoundId.getValue(this._soundName));
                }
                this.finish();
            }
        });
        require("../../Fsm").addAction(PlaySoundAction, "System", CC_EDITOR && {
            tooltip: "播放一个音效"
        });
        module.exports = PlaySoundAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    25: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "e3f36Pf8rpJcoLKEQJzyFfF", "PreloadModuleAction");
        let gdk = require("gdk");
        let ResourceId = gdk.ResourceId;
        let PreloadModuleAction = cc.Class({
            name: "PreloadModuleAction",
            extends: require("../../FsmStateAction"),
            properties: {
                _moduleName: "",
                panel: {
                    get() {
                        return ResourceId[this._moduleName] || 0;
                    },
                    set(value) {
                        this._moduleName = ResourceId[value];
                    },
                    type: ResourceId,
                    tooltip: CC_DEV && "如果没可选值，请先配置gdk.ResourceId"
                }
            },
            onEnter() {
                if (this._moduleName) {
                    gdk.rm.addModuleInBackground([ this._moduleName ]);
                }
                this.finish();
            }
        });
        require("../../Fsm").addAction(PreloadModuleAction, "System", CC_EDITOR && {
            tooltip: "预加载模块资源"
        });
        module.exports = PreloadModuleAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    26: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ee481hb1eVC5Ir6rnDEV9O+", "PreloadPanelAction");
        let gdk = require("gdk");
        let PanelId = gdk.PanelId;
        let PreloadPanelAction = cc.Class({
            name: "PreloadPanelAction",
            extends: require("../../FsmStateAction"),
            properties: {
                _panelName: "",
                panel: {
                    get() {
                        return PanelId[this._panelName] || 0;
                    },
                    set(value) {
                        this._panelName = PanelId[value];
                    },
                    type: PanelId,
                    tooltip: CC_DEV && "如果没可选值，请先配置gdk.PanelId"
                },
                autoRelease: {
                    default: true,
                    tooltip: CC_DEV && "完成后自动释放资源"
                }
            },
            onEnter() {
                if (this._panelName) {
                    gdk.panel.preload(this._panelName, this.autoRelease);
                }
                this.finish();
            }
        });
        require("../../Fsm").addAction(PreloadPanelAction, "System", CC_EDITOR && {
            tooltip: "预加载一个界面相关的资源"
        });
        module.exports = PreloadPanelAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    27: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "e1251tflL5LYInutBjQ1NP1", "PreloadSceneAction");
        let gdk = require("gdk");
        let SceneId = gdk.SceneId;
        let PreloadSceneAction = cc.Class({
            name: "PreloadSceneAction",
            extends: require("../../FsmStateAction"),
            properties: {
                _sceneName: "",
                scene: {
                    get() {
                        return SceneId[this._sceneName] || 0;
                    },
                    set(value) {
                        this._sceneName = SceneId[value];
                    },
                    type: SceneId,
                    tooltip: CC_DEV && "如果没可选值，请先配置gdk.SceneId"
                },
                autoRelease: {
                    default: true,
                    tooltip: CC_DEV && "完成后自动释放资源"
                }
            },
            onEnter() {
                var scene = SceneId.getValue(this._sceneName);
                if (scene) {
                    gdk.scene.preload(scene, this.autoRelease);
                }
                this.finish();
            }
        });
        require("../../Fsm").addAction(PreloadSceneAction, "System", CC_EDITOR && {
            tooltip: "预加载一个场景相关的资源"
        });
        module.exports = PreloadSceneAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    28: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "11f58SLzbxHcrh9cnNkbs/Z", "SendEventAction");
        const Fsm = require("../../Fsm");
        const FsmEventId = require("../../enum/FsmEventId");
        var SendEventAction = cc.Class({
            name: "SendEventAction",
            extends: require("../../FsmStateAction"),
            properties: {
                _eventName: "",
                event: {
                    get() {
                        return FsmEventId[this._eventName] || 0;
                    },
                    set(value) {
                        this._eventName = FsmEventId[value];
                    },
                    type: FsmEventId,
                    tooltip: CC_DEV && "如果没可选值，请先配置gdk.fms.FsmEventId"
                },
                eventName: {
                    default: "",
                    tooltip: CC_DEV && "设置此值会覆盖event的值"
                },
                isGlobalEvent: {
                    default: false,
                    tooltip: CC_DEV && "是否为全局事件"
                }
            },
            onEnter() {
                var eventType = this.eventName || FsmEventId.getValue(this._eventName);
                if (this.isGlobalEvent) {
                    Fsm.broadcastEvent(eventType);
                } else {
                    this.sendEvent(eventType);
                }
                this.finish();
            }
        });
        require("../../Fsm").addAction(SendEventAction, "System", CC_EDITOR && {
            tooltip: "向当前状态机发全局或自定义事件"
        });
        module.exports = SendEventAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        "../../enum/FsmEventId": 40
    } ],
    29: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "84beeUFcQJD2p5tj6olTUSL", "SendGdkEventAction");
        let gdk = require("gdk");
        let EventId = gdk.EventId;
        let SendGdkEventAction = cc.Class({
            name: "SendGdkEventAction",
            extends: require("../../FsmStateAction"),
            properties: {
                _eventName: "",
                event: {
                    get() {
                        return EventId[this._eventName] || 0;
                    },
                    set(value) {
                        this._eventName = EventId[value];
                    },
                    type: EventId,
                    tooltip: CC_DEV && "如果没可选值，请先配置gdk.EventId"
                },
                eventName: {
                    default: "",
                    tooltip: CC_DEV && "设置此值会覆盖event的值"
                },
                data: {
                    default: "",
                    tooltip: CC_DEV && "事件参数，只支持简单类型"
                }
            },
            onEnter() {
                var eventType = this.eventName || EventId.getValue(this._eventName);
                gdk.e.emit(eventType, this.data);
                this.finish();
            }
        });
        require("../../Fsm").addAction(SendGdkEventAction, "System", CC_EDITOR && {
            tooltip: "向gdk.EventManager发事件"
        });
        module.exports = SendGdkEventAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    30: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "e4eebFugsxFxY0yvzlrqxT7", "WaitAction");
        var gdk = require("gdk");
        var WaitAction = cc.Class({
            name: "WaitAction",
            extends: require("../../FsmStateAction"),
            properties: {
                time: {
                    default: 0,
                    type: cc.Integer,
                    tooltip: CC_DEV && "等待时间(单位：毫秒)"
                }
            },
            onEnter() {
                if (this.time >= 0) {
                    gdk.DelayCall.addCall(this.finish, this, this.time / 1e3);
                } else {
                    this.finish();
                }
            },
            onExit() {
                gdk.DelayCall.cancel(this.finish, this);
            }
        });
        require("../../Fsm").addAction(WaitAction, "System", CC_EDITOR && {
            tooltip: "等待多少毫秒才可以继续动作",
            finishType: "wait"
        });
        module.exports = WaitAction;
        cc._RF.pop();
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35,
        gdk: "gdk"
    } ],
    31: [ function(require, module, exports) {
        var WaitFrameAction = cc.Class({
            name: "WaitFrameAction",
            extends: require("../../FsmStateAction"),
            properties: {
                frame: {
                    default: 1,
                    type: cc.Integer,
                    tooltip: CC_DEV && "等待的帧数"
                }
            },
            onEnter() {
                let frame = this.frame;
                if (frame >= 0) {
                    gdk.Timer.frameOnce(frame, this, this.finish);
                } else {
                    this.finish();
                }
            },
            onExit() {
                gdk.Timer.clearAll(this);
            }
        });
        require("../../Fsm").addAction(WaitFrameAction, "System", CC_EDITOR && {
            tooltip: "等待多少帧后才可以继续动作",
            finishType: "wait"
        });
        module.exports = WaitFrameAction;
    }, {
        "../../Fsm": 32,
        "../../FsmStateAction": 35
    } ],
    32: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "3cb8f+tM3pAPozELgX/I1J5", "Fsm");
        let gdk = require("gdk");
        let FsmEventId = require("./enum/FsmEventId");
        let Fsm = cc.Class({
            name: "Fsm",
            properties: {
                fsmName: "",
                fsmDescription: "",
                states: {
                    default: [],
                    type: [ require("./FsmState") ],
                    serializable: true
                },
                events: {
                    default: [],
                    type: cc.String,
                    serializable: true
                },
                globalTransitions: {
                    default: [],
                    type: [ require("./FsmTransition") ],
                    serializable: true
                },
                startState: cc.String,
                active: {
                    get() {
                        return this._active;
                    }
                },
                activeState: {
                    get() {
                        return this._activeState;
                    }
                },
                activeStateName: {
                    get() {
                        if (this._activeState) {
                            return this._activeState.stateName;
                        }
                        return null;
                    }
                },
                isPause: {
                    get() {
                        if (this._activeState) {
                            return this._activeState.isPause;
                        }
                        return false;
                    }
                }
            },
            statics: {
                main: null,
                fsms: [],
                isShowLog: false,
                actionList: {},
                addAction(action, type, info) {
                    if (CC_EDITOR) {
                        var actions = Fsm.actionList;
                        type = type || "Custom";
                        info = info || {};
                        if (!info.actionName) {
                            info.actionName = action.name;
                            let i = info.actionName.lastIndexOf("Action");
                            if (i != -1) {
                                info.actionName = info.actionName.substring(0, i);
                            }
                        }
                        actions[type] = actions[type] || {};
                        actions[type][info.actionName] = {
                            action: action,
                            type: type,
                            info: info
                        };
                        Editor.Ipc.sendToPanel("gdk-fsm", "fsm-add-action");
                    }
                },
                _actionDecorator(name, type, info) {
                    return function(action) {
                        if (!cc.Class._isCCClass(action)) {
                            action = cc._decorator.ccclass(name)(action);
                        }
                        CC_EDITOR && Fsm.addAction(action, type, info);
                    };
                },
                log(str) {
                    if (Fsm.isShowLog) {
                        gdk.Log.log(str);
                    }
                },
                broadcastEvent(eventName, excludeSelf = false) {
                    if (Fsm.isShowLog) {
                        Fsm.log(`Fsm  BroadcastEvent:${eventName}`);
                    }
                    let fsms = this.fsms.concat();
                    for (let i = 0, n = fsms.length; i < n; i++) {
                        let fsm = fsms[i];
                        if (fsm && fsm._active) {
                            fsm._onGlobalEvent(eventName);
                        }
                    }
                },
                sendEventToNode(node, eventName, isChildren = false) {
                    var FsmComponent = require("./components/FsmComponent");
                    var coms = null;
                    if (Fsm.isShowLog) {
                        Fsm.log(`Fsm  SendEventToNode:${node.name}->${eventName}`);
                    }
                    if (isChildren) {
                        coms = node.getComponentsInChildren(FsmComponent);
                    } else {
                        coms = node.getComponents(FsmComponent);
                    }
                    for (var i = 0; i < coms.length; i++) {
                        var fsm = coms[i].fsm;
                        fsm._onGlobalEvent(eventName);
                    }
                },
                getByName(name) {
                    for (let i = 0; i < this.fsms.length; i++) {
                        var fsm = this.fsms[i];
                        if (fsm.fsmName == name) {
                            return fsm;
                        }
                    }
                }
            },
            ctor() {
                this._activeState = null;
                this._active = false;
                this.fsmComponent = null;
                this.node = null;
                this._destroyed = false;
            },
            start() {
                if (this._destroyed) return;
                if (Fsm.isShowLog) {
                    Fsm.log(`Fsm "${this.fsmName}" Start`);
                }
                this.setState(this.startState);
            },
            setActive(value) {
                if (this._destroyed) return;
                if (this._active == value) return;
                this._active = value;
                if (Fsm.isShowLog) {
                    Fsm.log(`Fsm "${this.fsmName}" SetActive:${value}`);
                }
                var index = Fsm.fsms.indexOf(this);
                if (this._active) {
                    if (Fsm.main == null) {
                        Fsm.main = this;
                    }
                    if (index == -1) {
                        Fsm.fsms.push(this);
                    }
                } else {
                    if (index != -1) {
                        Fsm.fsms.splice(index, 1);
                    }
                    if (this._activeState) {
                        this._activeState._exit();
                    }
                    this._activeState = null;
                }
            },
            setState(stateName) {
                if (this._active == false) return;
                if (Fsm.isShowLog) {
                    Fsm.log(`Fsm "${this.fsmName}" SetState:"${stateName}"`);
                }
                let state;
                if (!this.stateDic) {
                    this.stateDic = {};
                    for (let i = 0; i < this.states.length; i++) {
                        state = this.states[i];
                        this.stateDic[state.stateName] = state;
                    }
                }
                state = this.stateDic[stateName];
                if (state) {
                    this._enterState(state);
                }
            },
            isState(stateName) {
                return this.activeStateName == stateName;
            },
            finish() {
                this.sendEvent(require("./FsmEvent").FINISH);
            },
            continue() {
                if (this._activeState) {
                    this._activeState.continue();
                }
            },
            pause() {
                if (this._activeState) {
                    this._activeState.pause();
                }
            },
            sendEvent(eventName) {
                if (this._active == false) return;
                if (Fsm.isShowLog) {
                    Fsm.log(`Fsm "${this.fsmName}.${this._activeState.stateName}" SendEvent:${eventName}`);
                }
                if (this._activeState) {
                    let transition;
                    if (!this._activeState.transitionDic) {
                        let dic = this._activeState.transitionDic = {};
                        let key;
                        let transitions = this._activeState.transitions;
                        for (let i = 0; i < transitions.length; i++) {
                            transition = transitions[i];
                            key = FsmEventId.getValue(transition.eventName);
                            dic[key] = transition;
                        }
                    }
                    transition = this._activeState.transitionDic[eventName];
                    if (transition) {
                        this.setState(transition.toState);
                    }
                }
            },
            broadcastEvent(eventName) {
                this._onGlobalEvent(eventName);
            },
            destroy() {
                this._active = false;
                if (this._destroyed) return;
                if (Fsm.isShowLog) {
                    Fsm.log(`Fsm "${this.fsmName}" Destroy`);
                }
                if (Fsm.main == this) {
                    Fsm.main = Fsm.fsms[0];
                }
                for (var i = 0; i < this.states.length; i++) {
                    var state = this.states[i];
                    state._destroy();
                }
            },
            _enterState(state) {
                if (this._active == false) return;
                if (this._activeState) {
                    this._activeState._exit();
                }
                this._activeState = state;
                state._enter(this.node, this);
            },
            _onGlobalEvent(eventName) {
                if (this._active == false) return;
                let transition;
                if (!this.globalTransitionDic) {
                    let dic = this.globalTransitionDic = {};
                    let key;
                    for (let i = 0; i < this.globalTransitions.length; i++) {
                        transition = this.globalTransitions[i];
                        key = FsmEventId.getValue(transition.eventName);
                        dic[key] = transition;
                    }
                }
                transition = this.globalTransitionDic[eventName];
                if (transition) {
                    this.setState(transition.toState);
                }
            }
        });
        module.exports = Fsm;
        cc._RF.pop();
    }, {
        "./FsmEvent": 33,
        "./FsmState": 34,
        "./FsmTransition": 36,
        "./components/FsmComponent": 37,
        "./enum/FsmEventId": 40,
        gdk: "gdk"
    } ],
    33: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "1833eOlNE5PgaOpy4z8jlJ9", "FsmEvent");
        var FsmEventId = require("./enum/FsmEventId");
        var FsmEvent = {
            FINISH: "FINISH"
        };
        FsmEventId.mixins(FsmEvent);
        module.exports = FsmEvent;
        cc._RF.pop();
    }, {
        "./enum/FsmEventId": 40
    } ],
    34: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "1c8a71oGv1CHK51HvLWtfDb", "FsmState");
        var FsmEvent = require("./FsmEvent");
        var Fsm;
        var FsmState = cc.Class({
            name: "FsmState",
            properties: {
                stateName: "FsmState",
                stateDescription: "",
                x: 0,
                y: 0,
                sequence: true,
                actions: {
                    default: [],
                    type: [ require("./FsmStateAction") ],
                    serializable: true
                },
                transitions: {
                    default: [],
                    type: [ require("./FsmTransition") ],
                    serializable: true
                },
                active: {
                    get() {
                        return this._active;
                    }
                },
                activeActions: {
                    get() {
                        return this._activeActions;
                    }
                },
                isPause: {
                    get() {
                        return this._isPause;
                    }
                }
            },
            ctor() {
                this._node = null;
                this._fsm = null;
                this._active = false;
                this._sequence = true;
                this._finish = false;
                this._activeActions = [];
                this._activeActionIndex = -1;
                this._isPause = false;
                this._waitNext = false;
                Fsm = require("./Fsm");
            },
            continue() {
                this._isPause = false;
                if (this._waitNext) {
                    this._waitNext = false;
                    if (this._sequence) {
                        this._enterNextAction();
                    }
                    this._checkFinish();
                }
            },
            pause() {
                this._isPause = true;
            },
            _enter(node, fsm) {
                this._exit();
                this._activeActionIndex = -1;
                this._activeActions.length = 0;
                this._fsm = fsm;
                this._node = node;
                this._active = true;
                this._finish = false;
                this._sequence = this.sequence;
                this._isPause = false;
                this._waitNext = false;
                if (Fsm.isShowLog) {
                    Fsm.log(`FsmState "${this._fsm.fsmName}:${this.stateName}" Enter`);
                }
                if (this._sequence) {
                    this._enterNextAction();
                } else {
                    while (true) {
                        if (this._enterNextAction() == false) {
                            break;
                        }
                    }
                }
                this._checkFinish();
            },
            _exit() {
                if (this._fsm == null) {
                    return;
                }
                if (Fsm.isShowLog) {
                    Fsm.log(`FsmState "${this._fsm.fsmName}:${this.stateName}" Exit`);
                }
                this._fsm = null;
                this._node = null;
                this._active = false;
                this._isPause = false;
                this._waitNext = false;
                for (var i = 0, n = this._activeActions.length; i < n; i++) {
                    this._activeActions[i]._exit();
                }
                this._activeActions.length = 0;
            },
            _destroy() {
                this._exit();
                for (var i = 0; i < this.actions.length; i++) {
                    var action = this.actions[i];
                    action._destroy();
                }
            },
            _actionFinish(action) {
                if (this._active == false) {
                    return;
                }
                var index = this._activeActions.indexOf(action);
                if (index != -1) {
                    this._activeActions.splice(index, 1);
                }
                action._exit();
                if (this._isPause == false) {
                    if (this._sequence) {
                        this._enterNextAction();
                    }
                    this._checkFinish();
                } else {
                    this._waitNext = true;
                }
            },
            _checkFinish() {
                if (this._isPause == false && this._finish == false && this._active && this._activeActions.length == 0 && this._fsm) {
                    if (Fsm.isShowLog) {
                        Fsm.log(`FsmState "${this._fsm.fsmName}:${this.stateName}" Finish`);
                    }
                    this._finish = true;
                    this._fsm.sendEvent(FsmEvent.FINISH);
                }
            },
            _enterNextAction() {
                this._activeActionIndex++;
                while (this._active && this._activeActionIndex < this.actions.length) {
                    var action = this.actions[this._activeActionIndex];
                    if (action.enabled) {
                        this._activeActions.push(action);
                        action._awake();
                        action._enter(this._node, this._fsm, this);
                        return true;
                    } else {
                        this._activeActionIndex++;
                    }
                }
                return false;
            }
        });
        module.exports = FsmState;
        cc._RF.pop();
    }, {
        "./Fsm": 32,
        "./FsmEvent": 33,
        "./FsmStateAction": 35,
        "./FsmTransition": 36
    } ],
    35: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "d535ao0u2lHna7KYI9K1upY", "FsmStateAction");
        let actionId = 0;
        let Fsm;
        let FsmStateAction = cc.Class({
            name: "FsmStateAction",
            properties: {
                enabled: {
                    default: true,
                    visible: false
                },
                actionName: {
                    default: "",
                    visible: false
                },
                finished: {
                    get() {
                        return this._finished;
                    },
                    visible: false
                },
                node: {
                    get() {
                        return this._node;
                    },
                    visible: false
                },
                fsm: {
                    get() {
                        return this._fsm;
                    },
                    visible: false
                },
                state: {
                    get() {
                        return this._state;
                    },
                    visible: false
                },
                active: {
                    get() {
                        return this.enabled && !this._finished && this._state && this._state.active && this._fsm && this._fsm.active && !this._destroyed;
                    },
                    visible: false
                },
                _id: {
                    default: "",
                    serializable: false
                },
                _classname: {
                    get() {
                        return this.constructor.name;
                    }
                },
                uuid: {
                    get() {
                        var id = this._id;
                        if (!id) {
                            id = this._id = "FsmAct." + actionId++;
                        }
                        if (CC_EDITOR || CC_TEST) {
                            if (cc && cc.engine && cc.engine.attachedObjsForEditor) {
                                cc.engine.attachedObjsForEditor[id] = this;
                            }
                        }
                        return id;
                    },
                    visible: false
                }
            },
            statics: {
                __gdk_bindable__: true
            },
            ctor() {
                if (!Fsm) {
                    Fsm = require("./Fsm");
                }
                if (CC_EDITOR) {
                    this.actionName = this.constructor.name;
                }
                this._id = this.uuid;
                this._finished = false;
                this._node = null;
                this._fsm = null;
                this._state = null;
                this._destroyed = false;
                this._isAwake = false;
            },
            sendEvent(eventName) {
                if (this.active) {
                    if (Fsm.isShowLog) {
                        Fsm.log(`FsmStateAction "${this.fsm.fsmName}:${this.state.stateName}:${this.actionName}" sendEvent:${eventName}`);
                    }
                    this.fsm.sendEvent(eventName);
                }
            },
            broadcastEvent(eventName) {
                if (this.active) {
                    if (Fsm.isShowLog) {
                        Fsm.log(`FsmStateAction "${this.fsm.fsmName}:${this.state.stateName}:${this.actionName}" broadcastEvent:${eventName}`);
                    }
                    this.fsm.broadcastEvent(eventName);
                }
            },
            finish() {
                if (!this.active) {
                    this._finished = true;
                    return;
                }
                if (Fsm.isShowLog) {
                    Fsm.log(`FsmStateAction "${this.fsm.fsmName}:${this.state.stateName}:${this.actionName}" Finish`);
                }
                this._state._actionFinish(this);
            },
            _awake() {
                if (!this._isAwake && this.awake) {
                    this._isAwake = true;
                    if (Fsm.isShowLog) {
                        Fsm.log(`FsmStateAction "${this.fsm.fsmName}:${this.state.stateName}:${this.actionName}" Awake`);
                    }
                    this.awake();
                }
            },
            _enter(node, fsm, state) {
                this._node = node;
                this._fsm = fsm;
                this._state = state;
                this._finished = false;
                if (Fsm.isShowLog) {
                    Fsm.log(`FsmStateAction "${this.fsm.fsmName}:${this.state.stateName}:${this.actionName}" Enter`);
                }
                this.onEnter && this.onEnter();
                if (this._node && this._fsm && this._state) {
                    this.onEnable && this.onEnable();
                    if (this.update) {
                        cc.director.getScheduler().scheduleUpdate(this, cc.Scheduler.PRIORITY_SYSTEM, false);
                    }
                }
            },
            _exit() {
                if (this._fsm == null) {
                    return;
                }
                if (Fsm.isShowLog) {
                    Fsm.log(`FsmStateAction "${this.fsm.fsmName}:${this.state.stateName}:${this.actionName}" Exit`);
                }
                if (this.update) {
                    cc.director.getScheduler().unscheduleUpdate(this);
                }
                this.onDisable && this.onDisable();
                this.onExit && this.onExit();
                this._node = null;
                this._fsm = null;
                this._state = null;
            },
            _destroy() {
                if (this._destroyed) {
                    return;
                }
                this._exit();
                this.onDestroy && this.onDestroy();
                if (CC_EDITOR || CC_TEST) {
                    if (cc && cc.engine && cc.engine.attachedObjsForEditor) {
                        delete cc.engine.attachedObjsForEditor[this._id];
                    }
                }
            }
        });
        module.exports = FsmStateAction;
        cc._RF.pop();
    }, {
        "./Fsm": 32
    } ],
    36: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "5153e6iDH1Pd68W9OybH/YN", "FsmTransition");
        var FsmTransition = cc.Class({
            name: "FsmTransition",
            properties: {
                eventName: cc.String,
                toState: cc.String
            }
        });
        module.exports = FsmTransition;
        cc._RF.pop();
    }, {} ],
    37: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "82c30TfLL5H/bhHcqHqJiuy", "FsmComponent");
        var Fsm = require("../Fsm");
        var FsmComponent = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(FSM)/FsmComponent",
                executeInEditMode: true,
                inspector: "packages://gdk-fsm/scripts/fsmInspector.js"
            },
            properties: {
                fsm: {
                    default: null,
                    type: Fsm,
                    visible: false,
                    serializable: true
                },
                syncActive: {
                    default: true,
                    visible: true,
                    serializable: true,
                    tooltip: CC_DEV && "把node节点激活状态同步给fsm"
                },
                _persist: {
                    default: false,
                    visible: true,
                    serializable: true,
                    tooltip: CC_DEV && "常驻根节点，该节点不会在场景切换中被销毁"
                },
                persist: {
                    get() {
                        return this._persist;
                    },
                    set(value) {
                        this._persist = value;
                        if (value) {
                            cc.game.addPersistRootNode(this.node);
                        } else {
                            cc.game.removePersistRootNode(this.node);
                        }
                    },
                    visible: false
                }
            },
            ctor() {
                if (CC_EDITOR) {
                    this.fsm = new Fsm(true);
                    var FsmState = require("../FsmState");
                    var state = new FsmState();
                    state.stateName = "State1";
                    state.x = -300;
                    state.y = -200;
                    this.fsm.startState = state.stateName;
                    this.fsm.states.push(state);
                    Editor.Ipc.sendToPanel("gdk-fsm", "fsm-create-or-delete");
                    Editor.Ipc.sendToMain("gdk-fsm:fsm-create-or-delete");
                }
                this._isInit = false;
            },
            onLoad() {
                if (this._persist) {
                    cc.game.removePersistRootNode(this.node);
                }
                if (this.fsm) {
                    this.fsm.fsmComponent = this;
                    this.fsm.node = this.node;
                }
            },
            onEnable() {
                if (CC_EDITOR) {
                    if (this.fsm.fsmName == "") {
                        var url = _Scene.title();
                        var isPrefab = url && url != "";
                        var name = "FSM";
                        var node = this.node;
                        while (node) {
                            name = node.name + "." + name;
                            node = node.parent;
                            if (isPrefab && node instanceof cc.Scene) break;
                        }
                        var comps = this.node.getComponents(FsmComponent);
                        var id = comps.length;
                        while (comps.some(comp => {
                            return comp.fsm.fsmName == name + "." + id;
                        })) {
                            id++;
                        }
                        this.fsm.fsmName = name + "." + id;
                    }
                    return;
                }
                if ((this.syncActive || this._isInit == false) && this.fsm) {
                    this._isInit = true;
                    this.fsm.setActive(true);
                    this.fsm.start();
                }
            },
            onDisable() {
                if (CC_EDITOR) return;
                if (this.syncActive && this.fsm) {
                    this.fsm.setActive(false);
                }
            },
            onDestroy: function() {
                if (CC_EDITOR) {
                    Editor.Ipc.sendToPanel("gdk-fsm", "fsm-create-or-delete");
                    Editor.Ipc.sendToMain("gdk-fsm:fsm-create-or-delete");
                }
                if (this.fsm) {
                    this.fsm.destroy();
                }
            }
        });
        module.exports = FsmComponent;
        cc._RF.pop();
    }, {
        "../Fsm": 32,
        "../FsmState": 34
    } ],
    38: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "2cc6c8sQilOELyX6msi+Bgq", "FsmControllerComponent");
        var Fsm = require("../Fsm");
        var FsmControlType = cc.Enum({
            sendEvent: 0,
            broadcastEvent: 1,
            pause: 2,
            continue: 3,
            start: 4,
            setState: 5,
            setActive: 6
        });
        function _getParam(arg) {
            if (arg[0] instanceof cc.Event) {
                var arr = arg[1].split(":");
                return {
                    arg1: arr[0],
                    arg2: arr[1]
                };
            }
            return {
                arg1: arg[0],
                arg2: arg[1]
            };
        }
        var FsmControllerComponent = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(FSM)/FsmControllerComponent",
                inspector: "packages://gdk-fsm/scripts/fsmControllerInspector.js"
            },
            properties: {
                enableToTrigger: {
                    default: false,
                    tooltip: CC_DEV && "被激活时立即触发"
                },
                control: {
                    default: FsmControlType.sendEvent,
                    type: FsmControlType,
                    tooltip: CC_DEV && "操作类型"
                },
                fsmName: "",
                args: "",
                active: true
            },
            ctor() {},
            trigger() {
                if (this.control == FsmControlType.sendEvent) {
                    this.sendEvent(this.fsmName, this.args);
                } else if (this.control == FsmControlType.broadcastEvent) {
                    this.broadcastEvent(this.args);
                } else if (this.control == FsmControlType.pause) {
                    this.pause(this.fsmName);
                } else if (this.control == FsmControlType.continue) {
                    this.continue(this.fsmName);
                } else if (this.control == FsmControlType.start) {
                    this.start(this.fsmName);
                } else if (this.control == FsmControlType.setState) {
                    this.setState(this.fsmName, this.args);
                } else if (this.control == FsmControlType.setActive) {
                    this.setActive(this.fsmName, this.args);
                }
            },
            sendEvent(fsmName, eventName) {
                let {arg1: arg1, arg2: arg2} = _getParam(arguments);
                if (arg1) {
                    Fsm.getByName(arg1).sendEvent(arg2);
                }
            },
            broadcastEvent(eventName) {
                let {arg1: arg1, arg2: arg2} = _getParam(arguments);
                Fsm.broadcastEvent(arg1);
            },
            pause(fsmName) {
                let {arg1: arg1, arg2: arg2} = _getParam(arguments);
                if (arg1) {
                    Fsm.getByName(arg1).pause();
                }
            },
            continue(fsmName) {
                let {arg1: arg1, arg2: arg2} = _getParam(arguments);
                if (arg1) {
                    Fsm.getByName(arg1).continue();
                }
            },
            start(fsmName) {
                let {arg1: arg1, arg2: arg2} = _getParam(arguments);
                if (arg1) {
                    Fsm.getByName(arg1).start();
                }
            },
            setState(fsmName, stateName) {
                let {arg1: arg1, arg2: arg2} = _getParam(arguments);
                if (arg1) {
                    Fsm.setState(arg1).start(arg2);
                }
            },
            setActive(fsmName, active) {
                let {arg1: arg1, arg2: arg2} = _getParam(arguments);
                if (arg1) {
                    var value = active;
                    if (arg2 == "true" || arg2 == true) value = true; else if (arg2 == "false" || arg2 == false) value = false;
                    Fsm.setState(arg1).setActive(value);
                }
            },
            onEnable() {
                if (this.enableToTrigger) this.trigger();
            }
        });
        module.exports = FsmControllerComponent;
        cc._RF.pop();
    }, {
        "../Fsm": 32
    } ],
    39: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "2bf3a1MKLZOVpth7ojHnhW0", "FsmEventButton");
        let gdk = require("gdk");
        let Fsm = require("../Fsm");
        let FsmEventId = require("../enum/FsmEventId");
        let FsmNamesId = CC_EDITOR ? require("../enum/FsmNamesId") : void 0;
        let FsmEventButton = cc.Class({
            extends: gdk.SoundButton,
            editor: {
                menu: "gdk(FSM)/FsmEventButton",
                disallowMultiple: false
            },
            properties: {
                _fsm: "",
                fsm: {
                    type: FsmNamesId,
                    get() {
                        if (FsmNamesId) {
                            return FsmNamesId[this._fsm] || 0;
                        }
                        return this._fsm;
                    },
                    set(value) {
                        if (FsmNamesId) {
                            this._fsm = FsmNamesId.getValue(value);
                        } else {
                            this._fsm = value;
                        }
                    },
                    visible() {
                        return !this.isGlobalEvent;
                    },
                    tooltip: CC_DEV && "FSM实例组件的名称，如果为None则使用Fsm.main"
                },
                _eventName: "",
                event: {
                    get() {
                        return FsmEventId[this._eventName] || 0;
                    },
                    set(value) {
                        this._eventName = FsmEventId[value];
                    },
                    visible() {
                        return !this.eventName;
                    },
                    type: FsmEventId,
                    tooltip: CC_DEV && "如果没可选值，请先配置gdk.fms.FsmEventId"
                },
                eventName: {
                    default: "",
                    tooltip: CC_DEV && "设置此值会覆盖event的值"
                },
                isBroadCastEvent: {
                    default: false,
                    visible() {
                        return !this.isGlobalEvent;
                    },
                    tooltip: CC_DEV && "是否为当前Fsm实例的广播事件"
                },
                isGlobalEvent: {
                    default: false,
                    tooltip: CC_DEV && "是否为全局事件"
                }
            },
            onClick() {
                let _super = cc.js.getSuper(this.__proto__.constructor);
                if (_super && _super.prototype && _super.prototype.onClick) {
                    _super.prototype.onClick.call(this);
                }
                let eventType = this.eventName || FsmEventId.getValue(this._eventName);
                if (this.isGlobalEvent) {
                    Fsm.broadcastEvent(eventType);
                } else {
                    let fsm = this._fsm ? Fsm.getByName(this._fsm) : Fsm.main;
                    if (fsm) {
                        if (this.isBroadCastEvent) {
                            fsm.broadcastEvent(eventType);
                        } else {
                            fsm.sendEvent(eventType);
                        }
                    }
                }
            }
        });
        module.exports = FsmEventButton;
        cc._RF.pop();
    }, {
        "../Fsm": 32,
        "../enum/FsmEventId": 40,
        "../enum/FsmNamesId": 41,
        gdk: "gdk"
    } ],
    40: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "740bb82/edO5JOc60oTnArP", "FsmEventId");
        let gdk = require("gdk");
        let FsmEventId = gdk.Enum({
            None: -1
        });
        module.exports = FsmEventId;
        cc._RF.pop();
    }, {
        gdk: "gdk"
    } ],
    41: [ function(require, module, exports) {
        let gdk = require("gdk");
        let FsmNamesId = gdk.Enum({
            None: -1
        });
        module.exports = FsmNamesId;
    }, {
        gdk: "gdk"
    } ],
    42: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ded25cxL0lBkr5E5Xxhqh9W", "gdk.fsm");
        let gdk = require("gdk");
        let fsm = {
            FsmComponent: require("./components/FsmComponent"),
            Fsm: require("./Fsm"),
            FsmTransition: require("./FsmTransition"),
            FsmStateAction: require("./FsmStateAction"),
            FsmState: require("./FsmState"),
            FsmEvent: require("./FsmEvent"),
            FsmControllerComponent: require("./components/FsmControllerComponent"),
            FsmEventId: require("./enum/FsmEventId"),
            FsmNamesId: CC_EDITOR ? require("./enum/FsmNamesId") : void 0,
            FsmEventButton: require("./components/FsmEventButton"),
            ModuleAction: require("./Actions/ModuleAction"),
            BaseWaitAction: require("./Actions/BaseWaitAction"),
            PreloadSceneAction: require("./Actions/system/PreloadSceneAction"),
            LoadSceneAction: require("./Actions/system/LoadSceneAction")
        };
        require("./Actions");
        gdk.fsm = fsm;
        gdk.fsm.action = fsm.Fsm._actionDecorator;
        module.exports = fsm;
        cc._RF.pop();
    }, {
        "./Actions": 19,
        "./Actions/BaseWaitAction": 1,
        "./Actions/ModuleAction": 18,
        "./Actions/system/LoadSceneAction": 22,
        "./Actions/system/PreloadSceneAction": 27,
        "./Fsm": 32,
        "./FsmEvent": 33,
        "./FsmState": 34,
        "./FsmStateAction": 35,
        "./FsmTransition": 36,
        "./components/FsmComponent": 37,
        "./components/FsmControllerComponent": 38,
        "./components/FsmEventButton": 39,
        "./enum/FsmEventId": 40,
        "./enum/FsmNamesId": 41,
        gdk: "gdk"
    } ],
    43: [ function(require, module, exports) {
        "use strict";
        exports.byteLength = byteLength;
        exports.toByteArray = toByteArray;
        exports.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
            var len = b64.length;
            if (len % 4 > 0) {
                throw new Error("Invalid string. Length must be a multiple of 4");
            }
            var validLen = b64.indexOf("=");
            if (validLen === -1) validLen = len;
            var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
            return [ validLen, placeHoldersLen ];
        }
        function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i;
            for (i = 0; i < len; i += 4) {
                tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
                arr[curByte++] = tmp >> 16 & 255;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 2) {
                tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 1) {
                tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            return arr;
        }
        function tripletToBase64(num) {
            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
                output.push(tripletToBase64(tmp));
            }
            return output.join("");
        }
        function fromByteArray(uint8) {
            var tmp;
            var len = uint8.length;
            var extraBytes = len % 3;
            var parts = [];
            var maxChunkLength = 16383;
            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
            }
            if (extraBytes === 1) {
                tmp = uint8[len - 1];
                parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
            } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + uint8[len - 1];
                parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
            }
            return parts.join("");
        }
    }, {} ],
    44: [ function(require, module, exports) {
        (function(Buffer) {
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
            "use strict";
            var base64 = require("base64-js");
            var ieee754 = require("ieee754");
            var customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            exports.Buffer = Buffer;
            exports.SlowBuffer = SlowBuffer;
            exports.INSPECT_MAX_BYTES = 50;
            var K_MAX_LENGTH = 2147483647;
            exports.kMaxLength = K_MAX_LENGTH;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var arr = new Uint8Array(1);
                    var proto = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(proto, Uint8Array.prototype);
                    Object.setPrototypeOf(arr, proto);
                    return arr.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(length) {
                if (length > K_MAX_LENGTH) {
                    throw new RangeError('The value "' + length + '" is invalid for option "size"');
                }
                var buf = new Uint8Array(length);
                Object.setPrototypeOf(buf, Buffer.prototype);
                return buf;
            }
            function Buffer(arg, encodingOrOffset, length) {
                if (typeof arg === "number") {
                    if (typeof encodingOrOffset === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(arg);
                }
                return from(arg, encodingOrOffset, length);
            }
            if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
                Object.defineProperty(Buffer, Symbol.species, {
                    value: null,
                    configurable: true,
                    enumerable: false,
                    writable: false
                });
            }
            Buffer.poolSize = 8192;
            function from(value, encodingOrOffset, length) {
                if (typeof value === "string") {
                    return fromString(value, encodingOrOffset);
                }
                if (ArrayBuffer.isView(value)) {
                    return fromArrayLike(value);
                }
                if (value == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof value);
                }
                if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(value, encodingOrOffset, length);
                }
                if (typeof value === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var valueOf = value.valueOf && value.valueOf();
                if (valueOf != null && valueOf !== value) {
                    return Buffer.from(valueOf, encodingOrOffset, length);
                }
                var b = fromObject(value);
                if (b) return b;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                    return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof value);
            }
            Buffer.from = function(value, encodingOrOffset, length) {
                return from(value, encodingOrOffset, length);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(size) {
                if (typeof size !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (size < 0) {
                    throw new RangeError('The value "' + size + '" is invalid for option "size"');
                }
            }
            function alloc(size, fill, encoding) {
                assertSize(size);
                if (size <= 0) {
                    return createBuffer(size);
                }
                if (fill !== undefined) {
                    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
                }
                return createBuffer(size);
            }
            Buffer.alloc = function(size, fill, encoding) {
                return alloc(size, fill, encoding);
            };
            function allocUnsafe(size) {
                assertSize(size);
                return createBuffer(size < 0 ? 0 : checked(size) | 0);
            }
            Buffer.allocUnsafe = function(size) {
                return allocUnsafe(size);
            };
            Buffer.allocUnsafeSlow = function(size) {
                return allocUnsafe(size);
            };
            function fromString(string, encoding) {
                if (typeof encoding !== "string" || encoding === "") {
                    encoding = "utf8";
                }
                if (!Buffer.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                }
                var length = byteLength(string, encoding) | 0;
                var buf = createBuffer(length);
                var actual = buf.write(string, encoding);
                if (actual !== length) {
                    buf = buf.slice(0, actual);
                }
                return buf;
            }
            function fromArrayLike(array) {
                var length = array.length < 0 ? 0 : checked(array.length) | 0;
                var buf = createBuffer(length);
                for (var i = 0; i < length; i += 1) {
                    buf[i] = array[i] & 255;
                }
                return buf;
            }
            function fromArrayBuffer(array, byteOffset, length) {
                if (byteOffset < 0 || array.byteLength < byteOffset) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (array.byteLength < byteOffset + (length || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var buf;
                if (byteOffset === undefined && length === undefined) {
                    buf = new Uint8Array(array);
                } else if (length === undefined) {
                    buf = new Uint8Array(array, byteOffset);
                } else {
                    buf = new Uint8Array(array, byteOffset, length);
                }
                Object.setPrototypeOf(buf, Buffer.prototype);
                return buf;
            }
            function fromObject(obj) {
                if (Buffer.isBuffer(obj)) {
                    var len = checked(obj.length) | 0;
                    var buf = createBuffer(len);
                    if (buf.length === 0) {
                        return buf;
                    }
                    obj.copy(buf, 0, 0, len);
                    return buf;
                }
                if (obj.length !== undefined) {
                    if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(obj);
                }
                if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                    return fromArrayLike(obj.data);
                }
            }
            function checked(length) {
                if (length >= K_MAX_LENGTH) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
                }
                return length | 0;
            }
            function SlowBuffer(length) {
                if (+length != length) {
                    length = 0;
                }
                return Buffer.alloc(+length);
            }
            Buffer.isBuffer = function isBuffer(b) {
                return b != null && b._isBuffer === true && b !== Buffer.prototype;
            };
            Buffer.compare = function compare(a, b) {
                if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
                if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (a === b) return 0;
                var x = a.length;
                var y = b.length;
                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                        x = a[i];
                        y = b[i];
                        break;
                    }
                }
                if (x < y) return -1;
                if (y < x) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return true;

                  default:
                    return false;
                }
            };
            Buffer.concat = function concat(list, length) {
                if (!Array.isArray(list)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (list.length === 0) {
                    return Buffer.alloc(0);
                }
                var i;
                if (length === undefined) {
                    length = 0;
                    for (i = 0; i < list.length; ++i) {
                        length += list[i].length;
                    }
                }
                var buffer = Buffer.allocUnsafe(length);
                var pos = 0;
                for (i = 0; i < list.length; ++i) {
                    var buf = list[i];
                    if (isInstance(buf, Uint8Array)) {
                        buf = Buffer.from(buf);
                    }
                    if (!Buffer.isBuffer(buf)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    buf.copy(buffer, pos);
                    pos += buf.length;
                }
                return buffer;
            };
            function byteLength(string, encoding) {
                if (Buffer.isBuffer(string)) {
                    return string.length;
                }
                if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                    return string.byteLength;
                }
                if (typeof string !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof string);
                }
                var len = string.length;
                var mustMatch = arguments.length > 2 && arguments[2] === true;
                if (!mustMatch && len === 0) return 0;
                var loweredCase = false;
                for (;;) {
                    switch (encoding) {
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return len;

                      case "utf8":
                      case "utf-8":
                        return utf8ToBytes(string).length;

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return len * 2;

                      case "hex":
                        return len >>> 1;

                      case "base64":
                        return base64ToBytes(string).length;

                      default:
                        if (loweredCase) {
                            return mustMatch ? -1 : utf8ToBytes(string).length;
                        }
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(encoding, start, end) {
                var loweredCase = false;
                if (start === undefined || start < 0) {
                    start = 0;
                }
                if (start > this.length) {
                    return "";
                }
                if (end === undefined || end > this.length) {
                    end = this.length;
                }
                if (end <= 0) {
                    return "";
                }
                end >>>= 0;
                start >>>= 0;
                if (end <= start) {
                    return "";
                }
                if (!encoding) encoding = "utf8";
                while (true) {
                    switch (encoding) {
                      case "hex":
                        return hexSlice(this, start, end);

                      case "utf8":
                      case "utf-8":
                        return utf8Slice(this, start, end);

                      case "ascii":
                        return asciiSlice(this, start, end);

                      case "latin1":
                      case "binary":
                        return latin1Slice(this, start, end);

                      case "base64":
                        return base64Slice(this, start, end);

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return utf16leSlice(this, start, end);

                      default:
                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                        encoding = (encoding + "").toLowerCase();
                        loweredCase = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(b, n, m) {
                var i = b[n];
                b[n] = b[m];
                b[m] = i;
            }
            Buffer.prototype.swap16 = function swap16() {
                var len = this.length;
                if (len % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for (var i = 0; i < len; i += 2) {
                    swap(this, i, i + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var len = this.length;
                if (len % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for (var i = 0; i < len; i += 4) {
                    swap(this, i, i + 3);
                    swap(this, i + 1, i + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var len = this.length;
                if (len % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for (var i = 0; i < len; i += 8) {
                    swap(this, i, i + 7);
                    swap(this, i + 1, i + 6);
                    swap(this, i + 2, i + 5);
                    swap(this, i + 3, i + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var length = this.length;
                if (length === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, length);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
                if (this === b) return true;
                return Buffer.compare(this, b) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var str = "";
                var max = exports.INSPECT_MAX_BYTES;
                str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > max) str += " ... ";
                return "<Buffer " + str + ">";
            };
            if (customInspectSymbol) {
                Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                if (isInstance(target, Uint8Array)) {
                    target = Buffer.from(target, target.offset, target.byteLength);
                }
                if (!Buffer.isBuffer(target)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof target);
                }
                if (start === undefined) {
                    start = 0;
                }
                if (end === undefined) {
                    end = target ? target.length : 0;
                }
                if (thisStart === undefined) {
                    thisStart = 0;
                }
                if (thisEnd === undefined) {
                    thisEnd = this.length;
                }
                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                    throw new RangeError("out of range index");
                }
                if (thisStart >= thisEnd && start >= end) {
                    return 0;
                }
                if (thisStart >= thisEnd) {
                    return -1;
                }
                if (start >= end) {
                    return 1;
                }
                start >>>= 0;
                end >>>= 0;
                thisStart >>>= 0;
                thisEnd >>>= 0;
                if (this === target) return 0;
                var x = thisEnd - thisStart;
                var y = end - start;
                var len = Math.min(x, y);
                var thisCopy = this.slice(thisStart, thisEnd);
                var targetCopy = target.slice(start, end);
                for (var i = 0; i < len; ++i) {
                    if (thisCopy[i] !== targetCopy[i]) {
                        x = thisCopy[i];
                        y = targetCopy[i];
                        break;
                    }
                }
                if (x < y) return -1;
                if (y < x) return 1;
                return 0;
            };
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                if (buffer.length === 0) return -1;
                if (typeof byteOffset === "string") {
                    encoding = byteOffset;
                    byteOffset = 0;
                } else if (byteOffset > 2147483647) {
                    byteOffset = 2147483647;
                } else if (byteOffset < -2147483648) {
                    byteOffset = -2147483648;
                }
                byteOffset = +byteOffset;
                if (numberIsNaN(byteOffset)) {
                    byteOffset = dir ? 0 : buffer.length - 1;
                }
                if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
                if (byteOffset >= buffer.length) {
                    if (dir) return -1; else byteOffset = buffer.length - 1;
                } else if (byteOffset < 0) {
                    if (dir) byteOffset = 0; else return -1;
                }
                if (typeof val === "string") {
                    val = Buffer.from(val, encoding);
                }
                if (Buffer.isBuffer(val)) {
                    if (val.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                } else if (typeof val === "number") {
                    val = val & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (dir) {
                            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                        }
                    }
                    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                var indexSize = 1;
                var arrLength = arr.length;
                var valLength = val.length;
                if (encoding !== undefined) {
                    encoding = String(encoding).toLowerCase();
                    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                        if (arr.length < 2 || val.length < 2) {
                            return -1;
                        }
                        indexSize = 2;
                        arrLength /= 2;
                        valLength /= 2;
                        byteOffset /= 2;
                    }
                }
                function read(buf, i) {
                    if (indexSize === 1) {
                        return buf[i];
                    } else {
                        return buf.readUInt16BE(i * indexSize);
                    }
                }
                var i;
                if (dir) {
                    var foundIndex = -1;
                    for (i = byteOffset; i < arrLength; i++) {
                        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                            if (foundIndex === -1) foundIndex = i;
                            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                        } else {
                            if (foundIndex !== -1) i -= i - foundIndex;
                            foundIndex = -1;
                        }
                    }
                } else {
                    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                    for (i = byteOffset; i >= 0; i--) {
                        var found = true;
                        for (var j = 0; j < valLength; j++) {
                            if (read(arr, i + j) !== read(val, j)) {
                                found = false;
                                break;
                            }
                        }
                        if (found) return i;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                return this.indexOf(val, byteOffset, encoding) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
            };
            function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                var remaining = buf.length - offset;
                if (!length) {
                    length = remaining;
                } else {
                    length = Number(length);
                    if (length > remaining) {
                        length = remaining;
                    }
                }
                var strLen = string.length;
                if (length > strLen / 2) {
                    length = strLen / 2;
                }
                for (var i = 0; i < length; ++i) {
                    var parsed = parseInt(string.substr(i * 2, 2), 16);
                    if (numberIsNaN(parsed)) return i;
                    buf[offset + i] = parsed;
                }
                return i;
            }
            function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
            }
            function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length);
            }
            function latin1Write(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length);
            }
            function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length);
            }
            function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
            }
            Buffer.prototype.write = function write(string, offset, length, encoding) {
                if (offset === undefined) {
                    encoding = "utf8";
                    length = this.length;
                    offset = 0;
                } else if (length === undefined && typeof offset === "string") {
                    encoding = offset;
                    length = this.length;
                    offset = 0;
                } else if (isFinite(offset)) {
                    offset = offset >>> 0;
                    if (isFinite(length)) {
                        length = length >>> 0;
                        if (encoding === undefined) encoding = "utf8";
                    } else {
                        encoding = length;
                        length = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var remaining = this.length - offset;
                if (length === undefined || length > remaining) length = remaining;
                if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!encoding) encoding = "utf8";
                var loweredCase = false;
                for (;;) {
                    switch (encoding) {
                      case "hex":
                        return hexWrite(this, string, offset, length);

                      case "utf8":
                      case "utf-8":
                        return utf8Write(this, string, offset, length);

                      case "ascii":
                        return asciiWrite(this, string, offset, length);

                      case "latin1":
                      case "binary":
                        return latin1Write(this, string, offset, length);

                      case "base64":
                        return base64Write(this, string, offset, length);

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return ucs2Write(this, string, offset, length);

                      default:
                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf);
                } else {
                    return base64.fromByteArray(buf.slice(start, end));
                }
            }
            function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                var res = [];
                var i = start;
                while (i < end) {
                    var firstByte = buf[i];
                    var codePoint = null;
                    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                    if (i + bytesPerSequence <= end) {
                        var secondByte, thirdByte, fourthByte, tempCodePoint;
                        switch (bytesPerSequence) {
                          case 1:
                            if (firstByte < 128) {
                                codePoint = firstByte;
                            }
                            break;

                          case 2:
                            secondByte = buf[i + 1];
                            if ((secondByte & 192) === 128) {
                                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                                if (tempCodePoint > 127) {
                                    codePoint = tempCodePoint;
                                }
                            }
                            break;

                          case 3:
                            secondByte = buf[i + 1];
                            thirdByte = buf[i + 2];
                            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                                    codePoint = tempCodePoint;
                                }
                            }
                            break;

                          case 4:
                            secondByte = buf[i + 1];
                            thirdByte = buf[i + 2];
                            fourthByte = buf[i + 3];
                            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                                    codePoint = tempCodePoint;
                                }
                            }
                        }
                    }
                    if (codePoint === null) {
                        codePoint = 65533;
                        bytesPerSequence = 1;
                    } else if (codePoint > 65535) {
                        codePoint -= 65536;
                        res.push(codePoint >>> 10 & 1023 | 55296);
                        codePoint = 56320 | codePoint & 1023;
                    }
                    res.push(codePoint);
                    i += bytesPerSequence;
                }
                return decodeCodePointsArray(res);
            }
            var MAX_ARGUMENTS_LENGTH = 4096;
            function decodeCodePointsArray(codePoints) {
                var len = codePoints.length;
                if (len <= MAX_ARGUMENTS_LENGTH) {
                    return String.fromCharCode.apply(String, codePoints);
                }
                var res = "";
                var i = 0;
                while (i < len) {
                    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                }
                return res;
            }
            function asciiSlice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i] & 127);
                }
                return ret;
            }
            function latin1Slice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i]);
                }
                return ret;
            }
            function hexSlice(buf, start, end) {
                var len = buf.length;
                if (!start || start < 0) start = 0;
                if (!end || end < 0 || end > len) end = len;
                var out = "";
                for (var i = start; i < end; ++i) {
                    out += hexSliceLookupTable[buf[i]];
                }
                return out;
            }
            function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end);
                var res = "";
                for (var i = 0; i < bytes.length; i += 2) {
                    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                }
                return res;
            }
            Buffer.prototype.slice = function slice(start, end) {
                var len = this.length;
                start = ~~start;
                end = end === undefined ? len : ~~end;
                if (start < 0) {
                    start += len;
                    if (start < 0) start = 0;
                } else if (start > len) {
                    start = len;
                }
                if (end < 0) {
                    end += len;
                    if (end < 0) end = 0;
                } else if (end > len) {
                    end = len;
                }
                if (end < start) end = start;
                var newBuf = this.subarray(start, end);
                Object.setPrototypeOf(newBuf, Buffer.prototype);
                return newBuf;
            };
            function checkOffset(offset, ext, length) {
                if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
                if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) checkOffset(offset, byteLength, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength && (mul *= 256)) {
                    val += this[offset + i] * mul;
                }
                return val;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) {
                    checkOffset(offset, byteLength, this.length);
                }
                var val = this[offset + --byteLength];
                var mul = 1;
                while (byteLength > 0 && (mul *= 256)) {
                    val += this[offset + --byteLength] * mul;
                }
                return val;
            };
            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 1, this.length);
                return this[offset];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                return this[offset] | this[offset + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                return this[offset] << 8 | this[offset + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) checkOffset(offset, byteLength, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength && (mul *= 256)) {
                    val += this[offset + i] * mul;
                }
                mul *= 128;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength);
                return val;
            };
            Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) checkOffset(offset, byteLength, this.length);
                var i = byteLength;
                var mul = 1;
                var val = this[offset + --i];
                while (i > 0 && (mul *= 256)) {
                    val += this[offset + --i] * mul;
                }
                mul *= 128;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength);
                return val;
            };
            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 1, this.length);
                if (!(this[offset] & 128)) return this[offset];
                return (255 - this[offset] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                var val = this[offset] | this[offset + 1] << 8;
                return val & 32768 ? val | 4294901760 : val;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                var val = this[offset + 1] | this[offset] << 8;
                return val & 32768 ? val | 4294901760 : val;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, false, 52, 8);
            };
            function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                    checkInt(this, value, offset, byteLength, maxBytes, 0);
                }
                var mul = 1;
                var i = 0;
                this[offset] = value & 255;
                while (++i < byteLength && (mul *= 256)) {
                    this[offset + i] = value / mul & 255;
                }
                return offset + byteLength;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                    checkInt(this, value, offset, byteLength, maxBytes, 0);
                }
                var i = byteLength - 1;
                var mul = 1;
                this[offset + i] = value & 255;
                while (--i >= 0 && (mul *= 256)) {
                    this[offset + i] = value / mul & 255;
                }
                return offset + byteLength;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
                this[offset] = value & 255;
                return offset + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
                return offset + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                this[offset] = value >>> 8;
                this[offset + 1] = value & 255;
                return offset + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                this[offset + 3] = value >>> 24;
                this[offset + 2] = value >>> 16;
                this[offset + 1] = value >>> 8;
                this[offset] = value & 255;
                return offset + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 255;
                return offset + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit);
                }
                var i = 0;
                var mul = 1;
                var sub = 0;
                this[offset] = value & 255;
                while (++i < byteLength && (mul *= 256)) {
                    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                        sub = 1;
                    }
                    this[offset + i] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit);
                }
                var i = byteLength - 1;
                var mul = 1;
                var sub = 0;
                this[offset + i] = value & 255;
                while (--i >= 0 && (mul *= 256)) {
                    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                        sub = 1;
                    }
                    this[offset + i] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength;
            };
            Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
                if (value < 0) value = 255 + value + 1;
                this[offset] = value & 255;
                return offset + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
                return offset + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                this[offset] = value >>> 8;
                this[offset + 1] = value & 255;
                return offset + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
                this[offset + 2] = value >>> 16;
                this[offset + 3] = value >>> 24;
                return offset + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                if (value < 0) value = 4294967295 + value + 1;
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 255;
                return offset + 4;
            };
            function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length) throw new RangeError("Index out of range");
                if (offset < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4);
                return offset + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert);
            };
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8);
                return offset + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert);
            };
            Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
                if (!start) start = 0;
                if (!end && end !== 0) end = this.length;
                if (targetStart >= target.length) targetStart = target.length;
                if (!targetStart) targetStart = 0;
                if (end > 0 && end < start) end = start;
                if (end === start) return 0;
                if (target.length === 0 || this.length === 0) return 0;
                if (targetStart < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
                if (end < 0) throw new RangeError("sourceEnd out of bounds");
                if (end > this.length) end = this.length;
                if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start;
                }
                var len = end - start;
                if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(targetStart, start, end);
                } else if (this === target && start < targetStart && targetStart < end) {
                    for (var i = len - 1; i >= 0; --i) {
                        target[i + targetStart] = this[i + start];
                    }
                } else {
                    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
                }
                return len;
            };
            Buffer.prototype.fill = function fill(val, start, end, encoding) {
                if (typeof val === "string") {
                    if (typeof start === "string") {
                        encoding = start;
                        start = 0;
                        end = this.length;
                    } else if (typeof end === "string") {
                        encoding = end;
                        end = this.length;
                    }
                    if (encoding !== undefined && typeof encoding !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                        throw new TypeError("Unknown encoding: " + encoding);
                    }
                    if (val.length === 1) {
                        var code = val.charCodeAt(0);
                        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                            val = code;
                        }
                    }
                } else if (typeof val === "number") {
                    val = val & 255;
                } else if (typeof val === "boolean") {
                    val = Number(val);
                }
                if (start < 0 || this.length < start || this.length < end) {
                    throw new RangeError("Out of range index");
                }
                if (end <= start) {
                    return this;
                }
                start = start >>> 0;
                end = end === undefined ? this.length : end >>> 0;
                if (!val) val = 0;
                var i;
                if (typeof val === "number") {
                    for (i = start; i < end; ++i) {
                        this[i] = val;
                    }
                } else {
                    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
                    var len = bytes.length;
                    if (len === 0) {
                        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                    }
                    for (i = 0; i < end - start; ++i) {
                        this[i + start] = bytes[i % len];
                    }
                }
                return this;
            };
            var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
            function base64clean(str) {
                str = str.split("=")[0];
                str = str.trim().replace(INVALID_BASE64_RE, "");
                if (str.length < 2) return "";
                while (str.length % 4 !== 0) {
                    str = str + "=";
                }
                return str;
            }
            function utf8ToBytes(string, units) {
                units = units || Infinity;
                var codePoint;
                var length = string.length;
                var leadSurrogate = null;
                var bytes = [];
                for (var i = 0; i < length; ++i) {
                    codePoint = string.charCodeAt(i);
                    if (codePoint > 55295 && codePoint < 57344) {
                        if (!leadSurrogate) {
                            if (codePoint > 56319) {
                                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                                continue;
                            } else if (i + 1 === length) {
                                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                                continue;
                            }
                            leadSurrogate = codePoint;
                            continue;
                        }
                        if (codePoint < 56320) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            leadSurrogate = codePoint;
                            continue;
                        }
                        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                    } else if (leadSurrogate) {
                        if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    }
                    leadSurrogate = null;
                    if (codePoint < 128) {
                        if ((units -= 1) < 0) break;
                        bytes.push(codePoint);
                    } else if (codePoint < 2048) {
                        if ((units -= 2) < 0) break;
                        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                    } else if (codePoint < 65536) {
                        if ((units -= 3) < 0) break;
                        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                    } else if (codePoint < 1114112) {
                        if ((units -= 4) < 0) break;
                        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return bytes;
            }
            function asciiToBytes(str) {
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                    byteArray.push(str.charCodeAt(i) & 255);
                }
                return byteArray;
            }
            function utf16leToBytes(str, units) {
                var c, hi, lo;
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                    if ((units -= 2) < 0) break;
                    c = str.charCodeAt(i);
                    hi = c >> 8;
                    lo = c % 256;
                    byteArray.push(lo);
                    byteArray.push(hi);
                }
                return byteArray;
            }
            function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str));
            }
            function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; ++i) {
                    if (i + offset >= dst.length || i >= src.length) break;
                    dst[i + offset] = src[i];
                }
                return i;
            }
            function isInstance(obj, type) {
                return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
            }
            function numberIsNaN(obj) {
                return obj !== obj;
            }
            var hexSliceLookupTable = function() {
                var alphabet = "0123456789abcdef";
                var table = new Array(256);
                for (var i = 0; i < 16; ++i) {
                    var i16 = i * 16;
                    for (var j = 0; j < 16; ++j) {
                        table[i16 + j] = alphabet[i] + alphabet[j];
                    }
                }
                return table;
            }();
        }).call(this, require("buffer").Buffer);
    }, {
        "base64-js": 43,
        buffer: 44,
        ieee754: 45
    } ],
    45: [ function(require, module, exports) {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & (1 << -nBits) - 1;
            s >>= -nBits;
            nBits += eLen;
            for (;nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
            m = e & (1 << -nBits) - 1;
            e >>= -nBits;
            nBits += mLen;
            for (;nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
            if (e === 0) {
                e = 1 - eBias;
            } else if (e === eMax) {
                return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
            } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--;
                    c *= 2;
                }
                if (e + eBias >= 1) {
                    value += rt / c;
                } else {
                    value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                    e++;
                    c /= 2;
                }
                if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax;
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen);
                    e = e + eBias;
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e = 0;
                }
            }
            for (;mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}
            e = e << mLen | m;
            eLen += mLen;
            for (;eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}
            buffer[offset + i - d] |= s * 128;
        };
    }, {} ],
    46: [ function(require, module, exports) {
        var charenc = {
            utf8: {
                stringToBytes: function(str) {
                    return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
                },
                bytesToString: function(bytes) {
                    return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
                }
            },
            bin: {
                stringToBytes: function(str) {
                    for (var bytes = [], i = 0; i < str.length; i++) bytes.push(str.charCodeAt(i) & 255);
                    return bytes;
                },
                bytesToString: function(bytes) {
                    for (var str = [], i = 0; i < bytes.length; i++) str.push(String.fromCharCode(bytes[i]));
                    return str.join("");
                }
            }
        };
        module.exports = charenc;
    }, {} ],
    47: [ function(require, module, exports) {
        (function() {
            var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt = {
                rotl: function(n, b) {
                    return n << b | n >>> 32 - b;
                },
                rotr: function(n, b) {
                    return n << 32 - b | n >>> b;
                },
                endian: function(n) {
                    if (n.constructor == Number) {
                        return crypt.rotl(n, 8) & 16711935 | crypt.rotl(n, 24) & 4278255360;
                    }
                    for (var i = 0; i < n.length; i++) n[i] = crypt.endian(n[i]);
                    return n;
                },
                randomBytes: function(n) {
                    for (var bytes = []; n > 0; n--) bytes.push(Math.floor(Math.random() * 256));
                    return bytes;
                },
                bytesToWords: function(bytes) {
                    for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8) words[b >>> 5] |= bytes[i] << 24 - b % 32;
                    return words;
                },
                wordsToBytes: function(words) {
                    for (var bytes = [], b = 0; b < words.length * 32; b += 8) bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
                    return bytes;
                },
                bytesToHex: function(bytes) {
                    for (var hex = [], i = 0; i < bytes.length; i++) {
                        hex.push((bytes[i] >>> 4).toString(16));
                        hex.push((bytes[i] & 15).toString(16));
                    }
                    return hex.join("");
                },
                hexToBytes: function(hex) {
                    for (var bytes = [], c = 0; c < hex.length; c += 2) bytes.push(parseInt(hex.substr(c, 2), 16));
                    return bytes;
                },
                bytesToBase64: function(bytes) {
                    for (var base64 = [], i = 0; i < bytes.length; i += 3) {
                        var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
                        for (var j = 0; j < 4; j++) if (i * 8 + j * 6 <= bytes.length * 8) base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63)); else base64.push("=");
                    }
                    return base64.join("");
                },
                base64ToBytes: function(base64) {
                    base64 = base64.replace(/[^A-Z0-9+\/]/gi, "");
                    for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
                        if (imod4 == 0) continue;
                        bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
                    }
                    return bytes;
                }
            };
            module.exports = crypt;
        })();
    }, {} ],
    48: [ function(require, module, exports) {
        "use strict";
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                        target[key] = source[key];
                    }
                }
            }
            return target;
        };
        var defaultEscapes = {
            "{": "\\{",
            "}": "\\}",
            "\\": "\\textbackslash{}",
            "#": "\\#",
            $: "\\$",
            "%": "\\%",
            "&": "\\&",
            "^": "\\textasciicircum{}",
            _: "\\_",
            "~": "\\textasciitilde{}"
        };
        var formatEscapes = {
            "–": "\\--",
            "—": "\\---",
            " ": "~",
            "\t": "\\qquad{}",
            "\r\n": "\\newline{}",
            "\n": "\\newline{}"
        };
        var defaultEscapeMapFn = function defaultEscapeMapFn(defaultEscapes, formatEscapes) {
            return _extends({}, defaultEscapes, formatEscapes);
        };
        module.exports = function(str) {
            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === undefined ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === undefined ? defaultEscapeMapFn : _ref$escapeMapFn;
            var runningStr = String(str);
            var result = "";
            var escapes = escapeMapFn(_extends({}, defaultEscapes), preserveFormatting ? _extends({}, formatEscapes) : {});
            var escapeKeys = Object.keys(escapes);
            var _loop = function _loop() {
                var specialCharFound = false;
                escapeKeys.forEach(function(key, index) {
                    if (specialCharFound) {
                        return;
                    }
                    if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
                        result += escapes[escapeKeys[index]];
                        runningStr = runningStr.slice(key.length, runningStr.length);
                        specialCharFound = true;
                    }
                });
                if (!specialCharFound) {
                    result += runningStr.slice(0, 1);
                    runningStr = runningStr.slice(1, runningStr.length);
                }
            };
            while (runningStr) {
                _loop();
            }
            return result;
        };
    }, {} ],
    49: [ function(require, module, exports) {
        const AMFEncode = require("./lib/AMFEncode");
        const AMFDecode = require("./lib/AMFDecode");
        const AMFType = require("./lib/AMFType");
        function getAMFEncode(version) {
            const amfEncode = new AMFEncode();
            amfEncode.version = version;
            return amfEncode;
        }
        function getAMFDecode() {
            const amfDecode = new AMFDecode("");
            return amfDecode;
        }
        class AMF {
            static encodeObject(obj, version = AMFType.AMF3_OBJECT_ENCODING) {
                const amfEncode = getAMFEncode(version);
                amfEncode.writeValue(obj);
                const buffer = amfEncode.getBuffer();
                return buffer;
            }
            static decodeObject(buffer, version = AMFType.AMF3_OBJECT_ENCODING) {
                const amfDecode = getAMFDecode();
                amfDecode.buffer.writeBuffer(buffer);
                const obj = amfDecode.readValue(version);
                return obj;
            }
        }
        module.exports = AMF;
    }, {
        "./lib/AMFDecode": 50,
        "./lib/AMFEncode": 51,
        "./lib/AMFType": 56
    } ],
    50: [ function(require, module, exports) {
        const SmartBuffer = require("smart-buffer").SmartBuffer;
        const AMFType = require("./AMFType");
        const AMFTraits = require("./AMFTraits");
        const AMFHeader = require("./AMFHeader");
        const AMFMessage = require("./AMFMessage");
        class AMFDecode {
            constructor(buffer) {
                this.buffer = SmartBuffer.fromBuffer(buffer);
                this.resetRefs();
            }
            resetRefs() {
                this.refObj = [];
                this.refStr = [];
                this.refTra = [];
            }
            readU8() {
                return this.buffer.readUInt8();
            }
            readU16() {
                return this.buffer.readUInt16BE();
            }
            readU32() {
                return this.buffer.readInt32BE();
            }
            readDouble() {
                const s = this.buffer.readDoubleBE();
                if (s === 63615) {
                    return Number.NaN;
                }
                return s;
            }
            readU29() {
                const b1 = this.buffer.readUInt8();
                if ((b1 & 128) === 0) {
                    return b1;
                }
                const b2 = this.buffer.readUInt8();
                if ((b2 & 128) === 0) {
                    return (b1 & 127) << 7 | b2;
                }
                const b3 = this.buffer.readUInt8();
                if ((b3 & 128) === 0) {
                    return (b1 & 127) << 14 | (b2 & 127) << 7 | b3;
                }
                const b4 = this.buffer.readUInt8();
                return (b1 & 127) << 22 | (b2 & 127) << 15 | (b3 & 127) << 8 | b4;
            }
            readInteger(version) {
                if (version === AMFType.AMF0_OBJECT_ENCODING) {
                    return this.readDouble();
                }
                return this.readU29();
            }
            readUTF8(version) {
                let str;
                let len;
                if (version === AMFType.AMF3_OBJECT_ENCODING || version === undefined) {
                    const n = this.readU29();
                    if (n & 1) {
                        len = n >> 1;
                        if (len === 0) {
                            return "";
                        }
                        str = this.buffer.readString(len);
                        this.refStr.push(str);
                    } else {
                        const idx = n >> 1;
                        if (this.refStr[idx] === undefined) {
                            throw new Error(`No string reference at index ${idx}, offset ${this.i}`);
                        }
                        str = this.refStr[idx];
                    }
                } else {
                    len = this.readU16();
                    str = this.buffer.readString(len);
                }
                return str;
            }
            readXML(version = AMFType.AMF3_OBJECT_ENCODING) {
                const ref = this.readU29();
                if ((ref & 1) === 0) {
                    return this.refObj[ref >> 1];
                }
                return this.readUTF8(version);
            }
            readByteArray() {
                const ref = this.readU29();
                if ((ref & 1) === 0) {
                    return this.refObj[ref >> 1];
                }
                const len = ref >> 1;
                return this.buffer.readBuffer(len);
            }
            readValue(version = AMFType.AMF3_OBJECT_ENCODING) {
                let marker = this.readU8();
                if (version === AMFType.AMF0_OBJECT_ENCODING && marker === AMFType.AMF0.AMV_PLUS) {
                    version = AMFType.AMF3_OBJECT_ENCODING;
                    marker = this.readU8();
                }
                if (version === AMFType.AMF3_OBJECT_ENCODING) {
                    switch (marker) {
                      case AMFType.AMF3.UNDEFINED:
                        return undefined;

                      case AMFType.AMF3.NULL:
                        return null;

                      case AMFType.AMF3.BOOLEAN_FALSE:
                        return false;

                      case AMFType.AMF3.BOOLEAN_TRUE:
                        return true;

                      case AMFType.AMF3.INTEGER:
                        return this.readInteger();

                      case AMFType.AMF3.DOUBLE:
                        return this.readDouble();

                      case AMFType.AMF3.STRING:
                        return this.readUTF8(version);

                      case AMFType.AMF3.XML_DOCUMENT:
                        return this.readXML(version);

                      case AMFType.AMF3.ARRAY:
                        return this.readArray();

                      case AMFType.AMF3.OBJECT:
                        return this.readObject(version);

                      case AMFType.AMF3.DATE:
                        return this.readDate();

                      case AMFType.AMF3.BYTE_ARRAY:
                        return this.readByteArray();

                      default:
                        throw new Error(`Type error, unsupported AMF3 marker: 0x${marker.toString("hex")}, offset ${this.buffer.readOffset}`);
                    }
                } else {
                    switch (marker) {
                      case AMFType.AMF0.NUMBER:
                        return this.readDouble();

                      case AMFType.AMF0.STRING:
                        return this.readUTF8(version);

                      case AMFType.AMF0.UNDEFINED:
                        return undefined;

                      case AMFType.AMF0.NULL:
                        return null;

                      case AMFType.AMF0.BOOLEAN:
                        return this.readBoolean();

                      case AMFType.AMF0.STRICT_ARRAY:
                        return this.readStrictArray();

                      case AMFType.AMF0.DATE:
                        return this.readDate();

                      case AMFType.AMF0.OBJECT:
                        return this.readObject(version);

                      default:
                        throw new Error(`Type error, unsupported AMF3 marker: 0x${marker.toString("hex")}, offset ${this.buffer.readOffset}`);
                    }
                }
            }
            readBoolean() {
                return Boolean(this.readU8());
            }
            readStrictArray() {
                const a = [];
                const n = this.readU32();
                for (let i = 0; i < n; i += 1) {
                    a.push(this.readValue(AMFType.AMF0_OBJECT_ENCODING));
                }
                return a;
            }
            readArray() {
                let a = [];
                const n = this.readU29();
                if (n & 1) {
                    this.refObj.push(a);
                    const len = n >> 1;
                    let key;
                    key = this.readUTF8(AMFType.AMF3_OBJECT_ENCODING);
                    while (key) {
                        a[key] = this.readValue(AMFType.AMF3_OBJECT_ENCODING);
                        key = this.readUTF8(AMFType.AMF3_OBJECT_ENCODING);
                    }
                    for (let i = 0; i < len; i += 1) {
                        a.push(this.readValue(AMFType.AMF3_OBJECT_ENCODING));
                    }
                } else {
                    const idx = n >> 1;
                    if (this.refObj[idx] === undefined) {
                        throw new Error(`No array reference at index ${idx}, offset ${this.i}`);
                    }
                    a = this.refObj[idx];
                }
                return a;
            }
            readObject(version) {
                let prop;
                let Obj = {};
                if (version === AMFType.AMF0_OBJECT_ENCODING) {
                    prop = this.readUTF8(version);
                    while (prop) {
                        Obj[prop] = this.readValue(version);
                        prop = this.readUTF8(version);
                    }
                    const end = this.readU8();
                    if (end !== AMFType.AMF0.OBJECT_END) {
                        throw new Error(`Expected object end marker, got 0x${end.toString(16)}`);
                    }
                    return Obj;
                }
                let traits;
                const n = this.readU29();
                if (n & 1) {
                    if (n & 2) {
                        traits = new AMFTraits();
                        this.refTra.push(traits);
                        if (n & 4) {
                            traits.clss = this.readUTF8(AMFType.AMF3_OBJECT_ENCODING);
                            throw new Error("Externalizable classes not yet supported, sorry");
                        } else {
                            traits.dyn = Boolean(n & 8);
                            traits.clss = this.readUTF8(AMFType.AMF3_OBJECT_ENCODING);
                            const proplen = n >> 4;
                            for (let i = 0; i < proplen; i += 1) {
                                prop = this.readUTF8(AMFType.AMF3_OBJECT_ENCODING);
                                traits.props.push(prop);
                            }
                        }
                    } else {
                        const idx = n >> 2;
                        if (this.refTra[idx] === undefined) {
                            throw new Error(`No traits reference at index ${idx}, offset ${this.i}`);
                        }
                        traits = this.refTra[idx];
                    }
                    this.refObj.push(Obj);
                    for (let i = 0, len = traits.props.length; i < len; i += 1) {
                        prop = traits.props[i];
                        Obj[prop] = this.readValue(AMFType.AMF3_OBJECT_ENCODING);
                    }
                    if (traits.clss) {
                        Obj._$type = traits.clss;
                    }
                    if (traits.dyn) {
                        prop = this.readUTF8(AMFType.AMF3_OBJECT_ENCODING);
                        while (prop) {
                            Obj[prop] = this.readValue(AMFType.AMF3_OBJECT_ENCODING);
                            prop = this.readUTF8(AMFType.AMF3_OBJECT_ENCODING);
                        }
                    }
                } else {
                    const idx = n >> 1;
                    if (this.refObj[idx] === undefined) {
                        throw new Error(`No object reference at index ${idx}, offset ${this.i}`);
                    }
                    Obj = this.refObj[idx];
                }
                return Obj;
            }
            readDate() {
                let u;
                let d;
                const n = this.readU29();
                if (n & 1) {
                    u = this.readDouble();
                    d = new Date(u);
                    this.refObj.push(d);
                } else {
                    const idx = n >> 1;
                    if (this.refObj[idx] === undefined || !(this.refObj[idx] instanceof Date)) {
                        throw new Error(`No date object reference at index ${idx}, offset ${this.i}`);
                    }
                    d = this.refObj[idx];
                }
                return d;
            }
            readHeader() {
                this.resetRefs();
                const name = this.readUTF8(AMFType.AMF0_OBJECT_ENCODING);
                const header = new AMFHeader(name, "");
                header.mustunderstand = Boolean(this.readU8());
                this.readU32();
                header.value = this.readValue(AMFType.AMF0_OBJECT_ENCODING);
                return header;
            }
            readMessage() {
                this.resetRefs();
                const msg = new AMFMessage("", "", "");
                msg.requestURI = this.readUTF8(AMFType.AMF0_OBJECT_ENCODING);
                msg.responseURI = this.readUTF8(AMFType.AMF0_OBJECT_ENCODING);
                this.readU32();
                msg.value = this.readValue(AMFType.AMF0_OBJECT_ENCODING);
                return msg;
            }
        }
        module.exports = AMFDecode;
    }, {
        "./AMFHeader": 52,
        "./AMFMessage": 53,
        "./AMFTraits": 55,
        "./AMFType": 56,
        "smart-buffer": 133
    } ],
    51: [ function(require, module, exports) {
        (function(Buffer) {
            const SmartBuffer = require("smart-buffer").SmartBuffer;
            const AMFType = require("./AMFType");
            const utf8 = require("./utils/utf8");
            class AMFEncode {
                constructor(version = AMFType.AMF3_OBJECT_ENCODING) {
                    if (version !== AMFType.AMF0_OBJECT_ENCODING && version !== AMFType.AMF3_OBJECT_ENCODING) {
                        throw new Error("AMF版本指定错误");
                    }
                    this.version = version;
                    this.vKey = `AMF${this.version}`;
                    this.buffer = new SmartBuffer();
                    this.offset = 0;
                    this.resetRefs();
                }
                resetRefs() {
                    this.refObj = [];
                    this.refStr = [];
                    this.refTra = [];
                }
                getBuffer() {
                    return this.buffer.toBuffer();
                }
                toString() {
                    return this.buffer.toString();
                }
                writeHeader(header) {
                    this.resetRefs();
                    const v = this.version;
                    this.version = AMFType.AMF0_OBJECT_ENCODING;
                    this.writeUTF8(header.name);
                    this.writeU8(header.mustunderstand ? 1 : 0);
                    this.writeU32(4294967295);
                    const s = this.writeValue(header.value);
                    this.version = v;
                    return s;
                }
                writeMessage(message, v) {
                    this.resetRefs();
                    const vv = this.version;
                    this.version = AMFType.AMF0_OBJECT_ENCODING;
                    this.writeUTF8(message.requestURI);
                    this.writeUTF8(message.responseURI);
                    this.writeU32(4294967295);
                    if (v === AMFType.AMF3_OBJECT_ENCODING) {
                        this.writeU8(AMFType.AMF0.AMV_PLUS);
                    }
                    this.version = v;
                    this.writeValue(message.value);
                    this.version = vv;
                    return this.buffer;
                }
                writeValue(value) {
                    if (value === undefined) {
                        return this.writeUndefined();
                    }
                    if (value === null) {
                        return this.writeNull();
                    }
                    if (typeof value === "string") {
                        return this.writeUTF8(value, true);
                    }
                    if (typeof value === "number") {
                        return this.writeNumber(value, true);
                    }
                    if (typeof value === "boolean") {
                        return this.writeBool(value);
                    }
                    if (Array.isArray(value)) {
                        return this.writeArray(value);
                    }
                    if (value.constructor === Date) {
                        return this.writeDate(value);
                    }
                    if (value.constructor === Buffer) {
                        return this.writeByteArray(value);
                    }
                    return this.writeObject(value);
                }
                writeByteArray(buffer) {
                    const marker = AMFType.AMF3.BYTE_ARRAY;
                    this.writeU8(marker);
                    const len = buffer.length;
                    const flag = len << 1 | 1;
                    this.writeU29(flag);
                    return this.buffer.writeBuffer(buffer);
                }
                writeUndefined() {
                    return this.writeU8(AMFType[this.vKey].UNDEFINED);
                }
                writeNull() {
                    return this.writeU8(AMFType[this.vKey].NULL);
                }
                writeBool(value) {
                    if (this.version === AMFType.AMF3_OBJECT_ENCODING) {
                        const marker = value ? AMFType.AMF3.BOOLEAN_TRUE : AMFType.AMF3.BOOLEAN_FALSE;
                        return this.writeU8(marker);
                    }
                    this.writeU8(AMFType.AMF0.BOOLEAN);
                    return this.writeU8(value ? 1 : 0);
                }
                writeNumber(value, writeMarker) {
                    const n = parseInt(value, 10);
                    if (n === value && n >= 0 && n < 536870912) {
                        return this.writeU29(value, writeMarker);
                    }
                    return this.writeDouble(value, writeMarker);
                }
                writeUTF8(value, writeMarker) {
                    if (typeof value !== "string") {
                        value = "";
                    }
                    const utf8Arr = utf8.encode(value);
                    const len = utf8Arr.length;
                    if (this.version === AMFType.AMF3_OBJECT_ENCODING) {
                        if (writeMarker) {
                            this.writeU8(AMFType.AMF3.STRING);
                        }
                        const n = this.refStr.indexOf(value);
                        if (n !== -1 && value !== "") {
                            this.writeU29(n << 1);
                            return;
                        }
                        const flag = len << 1 | 1;
                        this.writeU29(flag);
                    } else {
                        if (writeMarker) {
                            this.writeU8(AMFType.AMF0.STRING);
                        }
                        this.writeU16(len);
                    }
                    if (value !== "") {
                        this.refStr.push(value);
                    }
                    for (let i = 0; i < len; i += 1) {
                        this.buffer.writeUInt8(utf8Arr[i]);
                    }
                }
                writeArray(value) {
                    const len = value.length;
                    if (this.version === AMFType.AMF3_OBJECT_ENCODING) {
                        this.writeU8(AMFType.AMF3.ARRAY);
                        const n = this.refObj.indexOf(value);
                        if (n !== -1) {
                            return this.writeU29(n << 1);
                        }
                        this.refObj.push(value);
                        const flag = len << 1 | 1;
                        this.writeU29(flag);
                        this.writeUTF8("");
                    } else {
                        this.writeU8(AMFType.AMF0.STRICT_ARRAY);
                        this.writeU32(len);
                    }
                    for (let i = 0; i < len; i += 1) {
                        this.writeValue(value[i]);
                    }
                    return this.buffer;
                }
                writeObject(value) {
                    if (this.version !== AMFType.AMF3_OBJECT_ENCODING) {
                        throw new Error("This library doesn't support AMF0 objects, use AMF3");
                    }
                    this.writeU8(AMFType.AMF3.OBJECT);
                    const n = this.refObj.indexOf(value);
                    if (n !== -1) {
                        return this.writeU29(n << 1);
                    }
                    this.refObj.push(value);
                    this.writeU29(11);
                    if (value._$type) {
                        this.writeUTF8(value.type);
                    } else {
                        this.writeUTF8("");
                    }
                    const keys = Object.keys(value);
                    for (let i = 0, len = keys.length; i < len; i += 1) {
                        const key = keys[i];
                        if (typeof value[key] !== "function") {
                            this.writeUTF8(key);
                            this.writeValue(value[key]);
                        }
                    }
                    return this.writeUTF8("");
                }
                writeDate(d) {
                    if (this.version !== AMFType.AMF3_OBJECT_ENCODING) {
                        throw new Error("This library doesn't support AMF0 objects, use AMF3");
                    }
                    this.writeU8(AMFType.AMF3.DATE);
                    this.writeU29(1);
                    return this.writeDouble(d.getTime());
                }
                writeDouble(value, writeMarker) {
                    if (writeMarker) {
                        const marker = this.version === AMFType.AMF3_OBJECT_ENCODING ? AMFType.AMF3.DOUBLE : AMFType.AMF0.NUMBER;
                        this.writeU8(marker);
                    }
                    if (isNaN(value)) {
                        this.buffer.writeDoubleBE(63615);
                    } else {
                        this.buffer.writeDoubleBE(value);
                    }
                    return this.buffer;
                }
                writeU8(n) {
                    return this.buffer.writeUInt8(n);
                }
                writeU16(n) {
                    return this.buffer.writeUInt16BE(n);
                }
                writeU32(n) {
                    return this.buffer.writeUInt32BE(n);
                }
                writeU29(value, writeMarker) {
                    if (writeMarker) {
                        this.buffer.writeUInt8(AMFType.AMF3.INTEGER);
                    }
                    if ((value & 4294967168) === 0) {
                        this.buffer.writeUInt8(value & 127);
                    } else if ((value & 4294950912) === 0) {
                        this.buffer.writeUInt8(128 | value >> 7 & 127);
                        this.buffer.writeUInt8(value & 127);
                    } else if ((value & 4292870144) === 0) {
                        this.buffer.writeUInt8(128 | value >> 14 & 127);
                        this.buffer.writeUInt8(128 | value >> 7 & 127);
                        this.buffer.writeUInt8(value & 127);
                    } else if ((value & 3221225472) === 0) {
                        this.buffer.writeUInt8(128 | value >> 22 & 127);
                        this.buffer.writeUInt8(128 | value >> 15 & 127);
                        this.buffer.writeUInt8(128 | value >> 8 & 127);
                        this.buffer.writeUInt8(value & 255);
                    } else {
                        throw new Error("AMF3 U29 range");
                    }
                }
            }
            module.exports = AMFEncode;
        }).call(this, require("buffer").Buffer);
    }, {
        "./AMFType": 56,
        "./utils/utf8": 57,
        buffer: 44,
        "smart-buffer": 133
    } ],
    52: [ function(require, module, exports) {
        const AMFObject = require("./AMFObject");
        class AMFHeader extends AMFObject {
            constructor(name, value) {
                super();
                this.mustunderstand = false;
                this.name = name;
                this.value = value;
                this.className = "AMFHeader";
            }
        }
        module.exports = AMFHeader;
    }, {
        "./AMFObject": 54
    } ],
    53: [ function(require, module, exports) {
        const AMFObject = require("./AMFObject");
        class AMFMessage extends AMFObject {
            constructor(value, requestURI, responseURI) {
                super();
                this.value = value;
                this.requestURI = requestURI || "";
                this.responseURI = responseURI || "";
            }
        }
        module.exports = AMFMessage;
    }, {
        "./AMFObject": 54
    } ],
    54: [ function(require, module, exports) {
        class AMFObject {
            toString() {
                return `[Object ${this.className}]`;
            }
        }
        module.exports = AMFObject;
    }, {} ],
    55: [ function(require, module, exports) {
        const AMFObject = require("./AMFObject");
        class AMFTraits extends AMFObject {
            constructor() {
                super();
                this.clss = "Object";
                this.dyn = false;
                this.props = [];
                this.className = "AMFTraits";
            }
        }
        module.exports = AMFTraits;
    }, {
        "./AMFObject": 54
    } ],
    56: [ function(require, module, exports) {
        module.exports = {
            AMF0_OBJECT_ENCODING: 0,
            AMF3_OBJECT_ENCODING: 3,
            AMF0: {
                NUMBER: 0,
                BOOLEAN: 1,
                STRING: 2,
                OBJECT: 3,
                MOVIECLIP: 4,
                NULL: 5,
                UNDEFINED: 6,
                REFERENCE: 7,
                ECMA_ARRAY: 8,
                OBJECT_END: 9,
                STRICT_ARRAY: 10,
                DATE: 11,
                LONG_STRING: 12,
                UNSUPPORTED: 13,
                RECORDSET: 14,
                XML_DOCUMENT: 15,
                TYPED_OBJECT: 16,
                AMV_PLUS: 17
            },
            AMF3: {
                UNDEFINED: 0,
                NULL: 1,
                BOOLEAN_FALSE: 2,
                BOOLEAN_TRUE: 3,
                INTEGER: 4,
                DOUBLE: 5,
                STRING: 6,
                XML_DOCUMENT: 7,
                DATE: 8,
                ARRAY: 9,
                OBJECT: 10,
                XML: 11,
                BYTE_ARRAY: 12,
                VECTOR_INT: 13,
                VECTOR_UINT: 14,
                VECTOR_DOUBLE: 15,
                VECTOR_OBJECT: 16,
                DICTIONARY: 17
            }
        };
    }, {} ],
    57: [ function(require, module, exports) {
        function encode(s) {
            const utf8 = [];
            let i = 0;
            let codePoint;
            while (i < s.length) {
                const a = s.charCodeAt(i);
                i += 1;
                if (a < 55296 || a >= 56320) {
                    codePoint = a;
                } else {
                    const b = s.charCodeAt(i);
                    i += 1;
                    codePoint = (a << 10) + b + (65536 - (55296 << 10) - 56320);
                }
                if (codePoint < 128) {
                    utf8.push(codePoint);
                } else {
                    if (codePoint < 2048) {
                        utf8.push(codePoint >> 6 & 31 | 192);
                    } else {
                        if (codePoint < 65536) {
                            utf8.push(codePoint >> 12 & 15 | 224);
                        } else {
                            utf8.push(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128);
                        }
                        utf8.push(codePoint >> 6 & 63 | 128);
                    }
                    utf8.push(codePoint & 63 | 128);
                }
            }
            return utf8;
        }
        module.exports = {
            encode: encode
        };
    }, {} ],
    58: [ function(require, module, exports) {
        /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
        module.exports = function(obj) {
            return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
        };
        function isBuffer(obj) {
            return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
        }
        function isSlowBuffer(obj) {
            return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
        }
    }, {} ],
    59: [ function(require, module, exports) {
        var core = require("mathjs/core");
        var math = core.create();
        math.import(require("mathjs/lib/expression/function/parse"));
        math.import(require("mathjs/lib/expression/function/compile"));
        math.import(require("mathjs/lib/expression/function/eval"));
        math.import(require("mathjs/lib/function/string/format"));
        math.import({
            add: function(a, b) {
                return a + b;
            },
            subtract: function(a, b) {
                return a - b;
            },
            multiply: function(a, b) {
                return a * b;
            },
            divide: function(a, b) {
                return a / b;
            },
            mod: function(a, b) {
                return a % b;
            },
            unaryPlus: function(a) {
                return a;
            },
            unaryMinus: function(a) {
                return -a;
            },
            bitOr: function(a, b) {
                return a | b;
            },
            bitXor: function(a, b) {
                return a ^ b;
            },
            bitAnd: function(a, b) {
                return a & b;
            },
            bitNot: function(a) {
                return ~a;
            },
            leftShift: function(a, b) {
                return a << b;
            },
            rightArithShift: function(a, b) {
                return a >> b;
            },
            rightLogShift: function(a, b) {
                return a >>> b;
            },
            or: function(a, b) {
                return !!(a || b);
            },
            xor: function(a, b) {
                return !!a !== !!b;
            },
            and: function(a, b) {
                return !!(a && b);
            },
            not: function(a) {
                return !a;
            },
            equal: function(a, b) {
                return a == b;
            },
            unequal: function(a, b) {
                return a != b;
            },
            smaller: function(a, b) {
                return a < b;
            },
            larger: function(a, b) {
                return a > b;
            },
            smallerEq: function(a, b) {
                return a <= b;
            },
            largerEq: function(a, b) {
                return a >= b;
            },
            matrix: function() {
                throw new Error("Matrices not supported");
            },
            index: function() {
                throw new Error("Matrix indexes not supported");
            },
            pi: Math.PI,
            e: Math.E,
            true: true,
            false: false,
            null: null
        });
        var allFromMath = {};
        Object.getOwnPropertyNames(Math).forEach(function(name) {
            if (!Object.prototype.hasOwnProperty(name)) {
                allFromMath[name] = Math[name];
            }
        });
        math.import(allFromMath);
        module.exports = math;
    }, {
        "mathjs/core": 60,
        "mathjs/lib/expression/function/compile": 68,
        "mathjs/lib/expression/function/eval": 69,
        "mathjs/lib/expression/function/parse": 70,
        "mathjs/lib/function/string/format": 94
    } ],
    60: [ function(require, module, exports) {
        module.exports = require("./lib/core/core");
    }, {
        "./lib/core/core": 61
    } ],
    61: [ function(require, module, exports) {
        "use strict";
        require("./../utils/polyfills");
        var isFactory = require("./../utils/object").isFactory;
        var typedFactory = require("./typed");
        var emitter = require("./../utils/emitter");
        var importFactory = require("./function/import");
        var configFactory = require("./function/config");
        exports.create = function create(options) {
            if (typeof Object.create !== "function") {
                throw new Error("ES5 not supported by this JavaScript engine. " + "Please load the es5-shim and es5-sham library for compatibility.");
            }
            var factories = [];
            var instances = [];
            var math = emitter.mixin({});
            math.type = {};
            math.expression = {
                transform: {},
                mathWithTransform: {}
            };
            math.typed = typedFactory.create(math.type);
            var _config = {
                epsilon: 1e-12,
                matrix: "Matrix",
                number: "number",
                precision: 64,
                predictable: false,
                randomSeed: null
            };
            function load(factory) {
                if (!isFactory(factory)) {
                    throw new Error("Factory object with properties `type`, `name`, and `factory` expected");
                }
                var index = factories.indexOf(factory);
                var instance;
                if (index === -1) {
                    if (factory.math === true) {
                        instance = factory.factory(math.type, _config, load, math.typed, math);
                    } else {
                        instance = factory.factory(math.type, _config, load, math.typed);
                    }
                    factories.push(factory);
                    instances.push(instance);
                } else {
                    instance = instances[index];
                }
                return instance;
            }
            math["import"] = load(importFactory);
            math["config"] = load(configFactory);
            math.expression.mathWithTransform["config"] = math["config"];
            if (options) {
                math.config(options);
            }
            return math;
        };
    }, {
        "./../utils/emitter": 109,
        "./../utils/object": 112,
        "./../utils/polyfills": 113,
        "./function/config": 62,
        "./function/import": 63,
        "./typed": 64
    } ],
    62: [ function(require, module, exports) {
        "use strict";
        var object = require("../../utils/object");
        function factory(type, config, load, typed, math) {
            var MATRIX = [ "Matrix", "Array" ];
            var NUMBER = [ "number", "BigNumber", "Fraction" ];
            function _config(options) {
                if (options) {
                    var prev = object.map(config, object.clone);
                    validateOption(options, "matrix", MATRIX);
                    validateOption(options, "number", NUMBER);
                    object.deepExtend(config, options);
                    var curr = object.map(config, object.clone);
                    var changes = object.map(options, object.clone);
                    math.emit("config", curr, prev, changes);
                    return curr;
                } else {
                    return object.map(config, object.clone);
                }
            }
            _config.MATRIX = MATRIX;
            _config.NUMBER = NUMBER;
            return _config;
        }
        function contains(array, item) {
            return array.indexOf(item) !== -1;
        }
        function findIndex(array, item) {
            return array.map(function(i) {
                return i.toLowerCase();
            }).indexOf(item.toLowerCase());
        }
        function validateOption(options, name, values) {
            if (options[name] !== undefined && !contains(values, options[name])) {
                var index = findIndex(values, options[name]);
                if (index !== -1) {
                    console.warn('Warning: Wrong casing for configuration option "' + name + '", should be "' + values[index] + '" instead of "' + options[name] + '".');
                    options[name] = values[index];
                } else {
                    console.warn('Warning: Unknown value "' + options[name] + '" for configuration option "' + name + '". Available options: ' + values.map(JSON.stringify).join(", ") + ".");
                }
            }
        }
        exports.name = "config";
        exports.math = true;
        exports.factory = factory;
    }, {
        "../../utils/object": 112
    } ],
    63: [ function(require, module, exports) {
        "use strict";
        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }
        var lazy = require("../../utils/object").lazy;
        var isFactory = require("../../utils/object").isFactory;
        var traverse = require("../../utils/object").traverse;
        var ArgumentsError = require("../../error/ArgumentsError");
        function factory(type, config, load, typed, math) {
            function mathImport(object, options) {
                var num = arguments.length;
                if (num !== 1 && num !== 2) {
                    throw new ArgumentsError("import", num, 1, 2);
                }
                if (!options) {
                    options = {};
                }
                if (isFactory(object)) {
                    _importFactory(object, options);
                } else if (Array.isArray(object)) {
                    object.forEach(function(entry) {
                        mathImport(entry, options);
                    });
                } else if (_typeof(object) === "object") {
                    for (var name in object) {
                        if (object.hasOwnProperty(name)) {
                            var value = object[name];
                            if (isSupportedType(value)) {
                                _import(name, value, options);
                            } else if (isFactory(object)) {
                                _importFactory(object, options);
                            } else {
                                mathImport(value, options);
                            }
                        }
                    }
                } else {
                    if (!options.silent) {
                        throw new TypeError("Factory, Object, or Array expected");
                    }
                }
            }
            function _import(name, value, options) {
                if (options.wrap && typeof value === "function") {
                    value = _wrap(value);
                }
                if (isTypedFunction(math[name]) && isTypedFunction(value)) {
                    if (options.override) {
                        value = typed(name, value.signatures);
                    } else {
                        value = typed(math[name], value);
                    }
                    math[name] = value;
                    _importTransform(name, value);
                    math.emit("import", name, function resolver() {
                        return value;
                    });
                    return;
                }
                if (math[name] === undefined || options.override) {
                    math[name] = value;
                    _importTransform(name, value);
                    math.emit("import", name, function resolver() {
                        return value;
                    });
                    return;
                }
                if (!options.silent) {
                    throw new Error('Cannot import "' + name + '": already exists');
                }
            }
            function _importTransform(name, value) {
                if (value && typeof value.transform === "function") {
                    math.expression.transform[name] = value.transform;
                    if (allowedInExpressions(name)) {
                        math.expression.mathWithTransform[name] = value.transform;
                    }
                } else {
                    delete math.expression.transform[name];
                    if (allowedInExpressions(name)) {
                        math.expression.mathWithTransform[name] = value;
                    }
                }
            }
            function _deleteTransform(name) {
                delete math.expression.transform[name];
                if (allowedInExpressions(name)) {
                    math.expression.mathWithTransform[name] = math[name];
                } else {
                    delete math.expression.mathWithTransform[name];
                }
            }
            function _wrap(fn) {
                var wrapper = function wrapper() {
                    var args = [];
                    for (var i = 0, len = arguments.length; i < len; i++) {
                        var arg = arguments[i];
                        args[i] = arg && arg.valueOf();
                    }
                    return fn.apply(math, args);
                };
                if (fn.transform) {
                    wrapper.transform = fn.transform;
                }
                return wrapper;
            }
            function _importFactory(factory, options) {
                if (typeof factory.name === "string") {
                    var name = factory.name;
                    var existingTransform = name in math.expression.transform;
                    var namespace = factory.path ? traverse(math, factory.path) : math;
                    var existing = namespace.hasOwnProperty(name) ? namespace[name] : undefined;
                    var resolver = function resolver() {
                        var instance = load(factory);
                        if (instance && typeof instance.transform === "function") {
                            throw new Error("Transforms cannot be attached to factory functions. " + 'Please create a separate function for it with exports.path="expression.transform"');
                        }
                        if (isTypedFunction(existing) && isTypedFunction(instance)) {
                            if (options.override) {} else {
                                instance = typed(existing, instance);
                            }
                            return instance;
                        }
                        if (existing === undefined || options.override) {
                            return instance;
                        }
                        if (!options.silent) {
                            throw new Error('Cannot import "' + name + '": already exists');
                        }
                    };
                    if (factory.lazy !== false) {
                        lazy(namespace, name, resolver);
                        if (existingTransform) {
                            _deleteTransform(name);
                        } else {
                            if (factory.path === "expression.transform" || factoryAllowedInExpressions(factory)) {
                                lazy(math.expression.mathWithTransform, name, resolver);
                            }
                        }
                    } else {
                        namespace[name] = resolver();
                        if (existingTransform) {
                            _deleteTransform(name);
                        } else {
                            if (factory.path === "expression.transform" || factoryAllowedInExpressions(factory)) {
                                math.expression.mathWithTransform[name] = resolver();
                            }
                        }
                    }
                    math.emit("import", name, resolver, factory.path);
                } else {
                    load(factory);
                }
            }
            function isSupportedType(object) {
                return typeof object === "function" || typeof object === "number" || typeof object === "string" || typeof object === "boolean" || object === null || object && type.isUnit(object) || object && type.isComplex(object) || object && type.isBigNumber(object) || object && type.isFraction(object) || object && type.isMatrix(object) || object && Array.isArray(object);
            }
            function isTypedFunction(fn) {
                return typeof fn === "function" && _typeof(fn.signatures) === "object";
            }
            function allowedInExpressions(name) {
                return !unsafe.hasOwnProperty(name);
            }
            function factoryAllowedInExpressions(factory) {
                return factory.path === undefined && !unsafe.hasOwnProperty(factory.name);
            }
            var unsafe = {
                expression: true,
                type: true,
                docs: true,
                error: true,
                json: true,
                chain: true
            };
            return mathImport;
        }
        exports.math = true;
        exports.name = "import";
        exports.factory = factory;
        exports.lazy = true;
    }, {
        "../../error/ArgumentsError": 65,
        "../../utils/object": 112
    } ],
    64: [ function(require, module, exports) {
        "use strict";
        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }
        var typedFunction = require("typed-function");
        var digits = require("./../utils/number").digits;
        var isBigNumber = require("./../utils/bignumber/isBigNumber");
        var isMatrix = require("./../utils/collection/isMatrix");
        var _createTyped = function createTyped() {
            _createTyped = typedFunction.create;
            return typedFunction;
        };
        exports.create = function create(type) {
            type.isNumber = function(x) {
                return typeof x === "number";
            };
            type.isComplex = function(x) {
                return type.Complex && x instanceof type.Complex || false;
            };
            type.isBigNumber = isBigNumber;
            type.isFraction = function(x) {
                return type.Fraction && x instanceof type.Fraction || false;
            };
            type.isUnit = function(x) {
                return x && x.constructor.prototype.isUnit || false;
            };
            type.isString = function(x) {
                return typeof x === "string";
            };
            type.isArray = Array.isArray;
            type.isMatrix = isMatrix;
            type.isDenseMatrix = function(x) {
                return x && x.isDenseMatrix && x.constructor.prototype.isMatrix || false;
            };
            type.isSparseMatrix = function(x) {
                return x && x.isSparseMatrix && x.constructor.prototype.isMatrix || false;
            };
            type.isRange = function(x) {
                return x && x.constructor.prototype.isRange || false;
            };
            type.isIndex = function(x) {
                return x && x.constructor.prototype.isIndex || false;
            };
            type.isBoolean = function(x) {
                return typeof x === "boolean";
            };
            type.isResultSet = function(x) {
                return x && x.constructor.prototype.isResultSet || false;
            };
            type.isHelp = function(x) {
                return x && x.constructor.prototype.isHelp || false;
            };
            type.isFunction = function(x) {
                return typeof x === "function";
            };
            type.isDate = function(x) {
                return x instanceof Date;
            };
            type.isRegExp = function(x) {
                return x instanceof RegExp;
            };
            type.isObject = function(x) {
                return _typeof(x) === "object" && x.constructor === Object && !type.isComplex(x) && !type.isFraction(x);
            };
            type.isNull = function(x) {
                return x === null;
            };
            type.isUndefined = function(x) {
                return x === undefined;
            };
            type.isAccessorNode = function(x) {
                return x && x.isAccessorNode && x.constructor.prototype.isNode || false;
            };
            type.isArrayNode = function(x) {
                return x && x.isArrayNode && x.constructor.prototype.isNode || false;
            };
            type.isAssignmentNode = function(x) {
                return x && x.isAssignmentNode && x.constructor.prototype.isNode || false;
            };
            type.isBlockNode = function(x) {
                return x && x.isBlockNode && x.constructor.prototype.isNode || false;
            };
            type.isConditionalNode = function(x) {
                return x && x.isConditionalNode && x.constructor.prototype.isNode || false;
            };
            type.isConstantNode = function(x) {
                return x && x.isConstantNode && x.constructor.prototype.isNode || false;
            };
            type.isFunctionAssignmentNode = function(x) {
                return x && x.isFunctionAssignmentNode && x.constructor.prototype.isNode || false;
            };
            type.isFunctionNode = function(x) {
                return x && x.isFunctionNode && x.constructor.prototype.isNode || false;
            };
            type.isIndexNode = function(x) {
                return x && x.isIndexNode && x.constructor.prototype.isNode || false;
            };
            type.isNode = function(x) {
                return x && x.isNode && x.constructor.prototype.isNode || false;
            };
            type.isObjectNode = function(x) {
                return x && x.isObjectNode && x.constructor.prototype.isNode || false;
            };
            type.isOperatorNode = function(x) {
                return x && x.isOperatorNode && x.constructor.prototype.isNode || false;
            };
            type.isParenthesisNode = function(x) {
                return x && x.isParenthesisNode && x.constructor.prototype.isNode || false;
            };
            type.isRangeNode = function(x) {
                return x && x.isRangeNode && x.constructor.prototype.isNode || false;
            };
            type.isSymbolNode = function(x) {
                return x && x.isSymbolNode && x.constructor.prototype.isNode || false;
            };
            type.isChain = function(x) {
                return x && x.constructor.prototype.isChain || false;
            };
            var typed = _createTyped();
            typed.types = [ {
                name: "number",
                test: type.isNumber
            }, {
                name: "Complex",
                test: type.isComplex
            }, {
                name: "BigNumber",
                test: type.isBigNumber
            }, {
                name: "Fraction",
                test: type.isFraction
            }, {
                name: "Unit",
                test: type.isUnit
            }, {
                name: "string",
                test: type.isString
            }, {
                name: "Array",
                test: type.isArray
            }, {
                name: "Matrix",
                test: type.isMatrix
            }, {
                name: "DenseMatrix",
                test: type.isDenseMatrix
            }, {
                name: "SparseMatrix",
                test: type.isSparseMatrix
            }, {
                name: "Range",
                test: type.isRange
            }, {
                name: "Index",
                test: type.isIndex
            }, {
                name: "boolean",
                test: type.isBoolean
            }, {
                name: "ResultSet",
                test: type.isResultSet
            }, {
                name: "Help",
                test: type.isHelp
            }, {
                name: "function",
                test: type.isFunction
            }, {
                name: "Date",
                test: type.isDate
            }, {
                name: "RegExp",
                test: type.isRegExp
            }, {
                name: "null",
                test: type.isNull
            }, {
                name: "undefined",
                test: type.isUndefined
            }, {
                name: "OperatorNode",
                test: type.isOperatorNode
            }, {
                name: "ConstantNode",
                test: type.isConstantNode
            }, {
                name: "SymbolNode",
                test: type.isSymbolNode
            }, {
                name: "ParenthesisNode",
                test: type.isParenthesisNode
            }, {
                name: "FunctionNode",
                test: type.isFunctionNode
            }, {
                name: "FunctionAssignmentNode",
                test: type.isFunctionAssignmentNode
            }, {
                name: "ArrayNode",
                test: type.isArrayNode
            }, {
                name: "AssignmentNode",
                test: type.isAssignmentNode
            }, {
                name: "BlockNode",
                test: type.isBlockNode
            }, {
                name: "ConditionalNode",
                test: type.isConditionalNode
            }, {
                name: "IndexNode",
                test: type.isIndexNode
            }, {
                name: "RangeNode",
                test: type.isRangeNode
            }, {
                name: "Node",
                test: type.isNode
            }, {
                name: "Object",
                test: type.isObject
            } ];
            typed.conversions = [ {
                from: "number",
                to: "BigNumber",
                convert: function convert(x) {
                    if (digits(x) > 15) {
                        throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber " + "(value: " + x + "). " + "Use function bignumber(x) to convert to BigNumber.");
                    }
                    return new type.BigNumber(x);
                }
            }, {
                from: "number",
                to: "Complex",
                convert: function convert(x) {
                    return new type.Complex(x, 0);
                }
            }, {
                from: "number",
                to: "string",
                convert: function convert(x) {
                    return x + "";
                }
            }, {
                from: "BigNumber",
                to: "Complex",
                convert: function convert(x) {
                    return new type.Complex(x.toNumber(), 0);
                }
            }, {
                from: "Fraction",
                to: "BigNumber",
                convert: function convert(x) {
                    throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. " + "Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
                }
            }, {
                from: "Fraction",
                to: "Complex",
                convert: function convert(x) {
                    return new type.Complex(x.valueOf(), 0);
                }
            }, {
                from: "number",
                to: "Fraction",
                convert: function convert(x) {
                    var f = new type.Fraction(x);
                    if (f.valueOf() !== x) {
                        throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision " + "(value: " + x + "). " + "Use function fraction(x) to convert to Fraction.");
                    }
                    return new type.Fraction(x);
                }
            }, {
                from: "string",
                to: "number",
                convert: function convert(x) {
                    var n = Number(x);
                    if (isNaN(n)) {
                        throw new Error('Cannot convert "' + x + '" to a number');
                    }
                    return n;
                }
            }, {
                from: "string",
                to: "BigNumber",
                convert: function convert(x) {
                    try {
                        return new type.BigNumber(x);
                    } catch (err) {
                        throw new Error('Cannot convert "' + x + '" to BigNumber');
                    }
                }
            }, {
                from: "string",
                to: "Fraction",
                convert: function convert(x) {
                    try {
                        return new type.Fraction(x);
                    } catch (err) {
                        throw new Error('Cannot convert "' + x + '" to Fraction');
                    }
                }
            }, {
                from: "string",
                to: "Complex",
                convert: function convert(x) {
                    try {
                        return new type.Complex(x);
                    } catch (err) {
                        throw new Error('Cannot convert "' + x + '" to Complex');
                    }
                }
            }, {
                from: "boolean",
                to: "number",
                convert: function convert(x) {
                    return +x;
                }
            }, {
                from: "boolean",
                to: "BigNumber",
                convert: function convert(x) {
                    return new type.BigNumber(+x);
                }
            }, {
                from: "boolean",
                to: "Fraction",
                convert: function convert(x) {
                    return new type.Fraction(+x);
                }
            }, {
                from: "boolean",
                to: "string",
                convert: function convert(x) {
                    return +x;
                }
            }, {
                from: "Array",
                to: "Matrix",
                convert: function convert(array) {
                    return new type.DenseMatrix(array);
                }
            }, {
                from: "Matrix",
                to: "Array",
                convert: function convert(matrix) {
                    return matrix.valueOf();
                }
            } ];
            return typed;
        };
    }, {
        "./../utils/bignumber/isBigNumber": 105,
        "./../utils/collection/isMatrix": 107,
        "./../utils/number": 111,
        "typed-function": 136
    } ],
    65: [ function(require, module, exports) {
        "use strict";
        function ArgumentsError(fn, count, min, max) {
            if (!(this instanceof ArgumentsError)) {
                throw new SyntaxError("Constructor must be called with the new operator");
            }
            this.fn = fn;
            this.count = count;
            this.min = min;
            this.max = max;
            this.message = "Wrong number of arguments in function " + fn + " (" + count + " provided, " + min + (max !== undefined && max !== null ? "-" + max : "") + " expected)";
            this.stack = new Error().stack;
        }
        ArgumentsError.prototype = new Error();
        ArgumentsError.prototype.constructor = Error;
        ArgumentsError.prototype.name = "ArgumentsError";
        ArgumentsError.prototype.isArgumentsError = true;
        module.exports = ArgumentsError;
    }, {} ],
    66: [ function(require, module, exports) {
        "use strict";
        function DimensionError(actual, expected, relation) {
            if (!(this instanceof DimensionError)) {
                throw new SyntaxError("Constructor must be called with the new operator");
            }
            this.actual = actual;
            this.expected = expected;
            this.relation = relation;
            this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
            this.stack = new Error().stack;
        }
        DimensionError.prototype = new RangeError();
        DimensionError.prototype.constructor = RangeError;
        DimensionError.prototype.name = "DimensionError";
        DimensionError.prototype.isDimensionError = true;
        module.exports = DimensionError;
    }, {} ],
    67: [ function(require, module, exports) {
        "use strict";
        function IndexError(index, min, max) {
            if (!(this instanceof IndexError)) {
                throw new SyntaxError("Constructor must be called with the new operator");
            }
            this.index = index;
            if (arguments.length < 3) {
                this.min = 0;
                this.max = min;
            } else {
                this.min = min;
                this.max = max;
            }
            if (this.min !== undefined && this.index < this.min) {
                this.message = "Index out of range (" + this.index + " < " + this.min + ")";
            } else if (this.max !== undefined && this.index >= this.max) {
                this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
            } else {
                this.message = "Index out of range (" + this.index + ")";
            }
            this.stack = new Error().stack;
        }
        IndexError.prototype = new RangeError();
        IndexError.prototype.constructor = RangeError;
        IndexError.prototype.name = "IndexError";
        IndexError.prototype.isIndexError = true;
        module.exports = IndexError;
    }, {} ],
    68: [ function(require, module, exports) {
        "use strict";
        var deepMap = require("../../utils/collection/deepMap");
        function factory(type, config, load, typed) {
            var parse = load(require("../parse"));
            return typed("compile", {
                string: function string(expr) {
                    return parse(expr).compile();
                },
                "Array | Matrix": function ArrayMatrix(expr) {
                    return deepMap(expr, function(entry) {
                        return parse(entry).compile();
                    });
                }
            });
        }
        exports.name = "compile";
        exports.factory = factory;
    }, {
        "../../utils/collection/deepMap": 106,
        "../parse": 91
    } ],
    69: [ function(require, module, exports) {
        "use strict";
        var deepMap = require("../../utils/collection/deepMap");
        function factory(type, config, load, typed) {
            var parse = load(require("../parse"));
            return typed("compile", {
                string: function string(expr) {
                    var scope = {};
                    return parse(expr).compile().eval(scope);
                },
                "string, Object": function stringObject(expr, scope) {
                    return parse(expr).compile().eval(scope);
                },
                "Array | Matrix": function ArrayMatrix(expr) {
                    var scope = {};
                    return deepMap(expr, function(entry) {
                        return parse(entry).compile().eval(scope);
                    });
                },
                "Array | Matrix, Object": function ArrayMatrixObject(expr, scope) {
                    return deepMap(expr, function(entry) {
                        return parse(entry).compile().eval(scope);
                    });
                }
            });
        }
        exports.name = "eval";
        exports.factory = factory;
    }, {
        "../../utils/collection/deepMap": 106,
        "../parse": 91
    } ],
    70: [ function(require, module, exports) {
        "use strict";
        function factory(type, config, load, typed) {
            var parse = load(require("../parse"));
            return typed("parse", {
                "string | Array | Matrix": parse,
                "string | Array | Matrix, Object": parse
            });
        }
        exports.name = "parse";
        exports.factory = factory;
    }, {
        "../parse": 91
    } ],
    71: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            end: true
        };
    }, {} ],
    72: [ function(require, module, exports) {
        "use strict";
        var getSafeProperty = require("../../utils/customs").getSafeProperty;
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            var access = load(require("./utils/access"));
            function AccessorNode(object, index) {
                if (!(this instanceof AccessorNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                if (!type.isNode(object)) {
                    throw new TypeError('Node expected for parameter "object"');
                }
                if (!type.isIndexNode(index)) {
                    throw new TypeError('IndexNode expected for parameter "index"');
                }
                this.object = object || null;
                this.index = index;
                Object.defineProperty(this, "name", {
                    get: function() {
                        if (this.index) {
                            return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
                        } else {
                            return this.object.name || "";
                        }
                    }.bind(this),
                    set: function set() {
                        throw new Error("Cannot assign a new name, name is read-only");
                    }
                });
            }
            AccessorNode.prototype = new Node();
            AccessorNode.prototype.type = "AccessorNode";
            AccessorNode.prototype.isAccessorNode = true;
            AccessorNode.prototype._compile = function(math, argNames) {
                var evalObject = this.object._compile(math, argNames);
                var evalIndex = this.index._compile(math, argNames);
                if (this.index.isObjectProperty()) {
                    var prop = this.index.getObjectProperty();
                    return function evalAccessorNode(scope, args, context) {
                        return getSafeProperty(evalObject(scope, args, context), prop);
                    };
                } else {
                    return function evalAccessorNode(scope, args, context) {
                        var object = evalObject(scope, args, context);
                        var index = evalIndex(scope, args, object);
                        return access(object, index);
                    };
                }
            };
            AccessorNode.prototype.forEach = function(callback) {
                callback(this.object, "object", this);
                callback(this.index, "index", this);
            };
            AccessorNode.prototype.map = function(callback) {
                return new AccessorNode(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
            };
            AccessorNode.prototype.clone = function() {
                return new AccessorNode(this.object, this.index);
            };
            AccessorNode.prototype._toString = function(options) {
                var object = this.object.toString(options);
                if (needParenthesis(this.object)) {
                    object = "(" + object + ")";
                }
                return object + this.index.toString(options);
            };
            AccessorNode.prototype.toHTML = function(options) {
                var object = this.object.toHTML(options);
                if (needParenthesis(this.object)) {
                    object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                return object + this.index.toHTML(options);
            };
            AccessorNode.prototype._toTex = function(options) {
                var object = this.object.toTex(options);
                if (needParenthesis(this.object)) {
                    object = "\\left(' + object + '\\right)";
                }
                return object + this.index.toTex(options);
            };
            AccessorNode.prototype.toJSON = function() {
                return {
                    mathjs: "AccessorNode",
                    object: this.object,
                    index: this.index
                };
            };
            AccessorNode.fromJSON = function(json) {
                return new AccessorNode(json.object, json.index);
            };
            function needParenthesis(node) {
                return !(type.isAccessorNode(node) || type.isArrayNode(node) || type.isConstantNode(node) || type.isFunctionNode(node) || type.isObjectNode(node) || type.isParenthesisNode(node) || type.isSymbolNode(node));
            }
            return AccessorNode;
        }
        exports.name = "AccessorNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../../utils/customs": 108,
        "./Node": 81,
        "./utils/access": 88
    } ],
    73: [ function(require, module, exports) {
        "use strict";
        var map = require("../../utils/array").map;
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            function ArrayNode(items) {
                if (!(this instanceof ArrayNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                this.items = items || [];
                if (!Array.isArray(this.items) || !this.items.every(type.isNode)) {
                    throw new TypeError("Array containing Nodes expected");
                }
                var deprecated = function deprecated() {
                    throw new Error("Property `ArrayNode.nodes` is deprecated, use `ArrayNode.items` instead");
                };
                Object.defineProperty(this, "nodes", {
                    get: deprecated,
                    set: deprecated
                });
            }
            ArrayNode.prototype = new Node();
            ArrayNode.prototype.type = "ArrayNode";
            ArrayNode.prototype.isArrayNode = true;
            ArrayNode.prototype._compile = function(math, argNames) {
                var evalItems = map(this.items, function(item) {
                    return item._compile(math, argNames);
                });
                var asMatrix = math.config().matrix !== "Array";
                if (asMatrix) {
                    var matrix = math.matrix;
                    return function evalArrayNode(scope, args, context) {
                        return matrix(map(evalItems, function(evalItem) {
                            return evalItem(scope, args, context);
                        }));
                    };
                } else {
                    return function evalArrayNode(scope, args, context) {
                        return map(evalItems, function(evalItem) {
                            return evalItem(scope, args, context);
                        });
                    };
                }
            };
            ArrayNode.prototype.forEach = function(callback) {
                for (var i = 0; i < this.items.length; i++) {
                    var node = this.items[i];
                    callback(node, "items[" + i + "]", this);
                }
            };
            ArrayNode.prototype.map = function(callback) {
                var items = [];
                for (var i = 0; i < this.items.length; i++) {
                    items[i] = this._ifNode(callback(this.items[i], "items[" + i + "]", this));
                }
                return new ArrayNode(items);
            };
            ArrayNode.prototype.clone = function() {
                return new ArrayNode(this.items.slice(0));
            };
            ArrayNode.prototype._toString = function(options) {
                var items = this.items.map(function(node) {
                    return node.toString(options);
                });
                return "[" + items.join(", ") + "]";
            };
            ArrayNode.prototype.toJSON = function() {
                return {
                    mathjs: "ArrayNode",
                    items: this.items
                };
            };
            ArrayNode.fromJSON = function(json) {
                return new ArrayNode(json.items);
            };
            ArrayNode.prototype.toHTML = function(options) {
                var items = this.items.map(function(node) {
                    return node.toHTML(options);
                });
                return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
            };
            ArrayNode.prototype._toTex = function(options) {
                var s = "\\begin{bmatrix}";
                this.items.forEach(function(node) {
                    if (node.items) {
                        s += node.items.map(function(childNode) {
                            return childNode.toTex(options);
                        }).join("&");
                    } else {
                        s += node.toTex(options);
                    }
                    s += "\\\\";
                });
                s += "\\end{bmatrix}";
                return s;
            };
            return ArrayNode;
        }
        exports.name = "ArrayNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../../utils/array": 103,
        "./Node": 81
    } ],
    74: [ function(require, module, exports) {
        "use strict";
        var getSafeProperty = require("../../utils/customs").getSafeProperty;
        var setSafeProperty = require("../../utils/customs").setSafeProperty;
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            var assign = load(require("./utils/assign"));
            var access = load(require("./utils/access"));
            var operators = require("../operators");
            function AssignmentNode(object, index, value) {
                if (!(this instanceof AssignmentNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                this.object = object;
                this.index = value ? index : null;
                this.value = value || index;
                if (!type.isSymbolNode(object) && !type.isAccessorNode(object)) {
                    throw new TypeError('SymbolNode or AccessorNode expected as "object"');
                }
                if (type.isSymbolNode(object) && object.name === "end") {
                    throw new Error('Cannot assign to symbol "end"');
                }
                if (this.index && !type.isIndexNode(this.index)) {
                    throw new TypeError('IndexNode expected as "index"');
                }
                if (!type.isNode(this.value)) {
                    throw new TypeError('Node expected as "value"');
                }
                Object.defineProperty(this, "name", {
                    get: function() {
                        if (this.index) {
                            return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
                        } else {
                            return this.object.name || "";
                        }
                    }.bind(this),
                    set: function set() {
                        throw new Error("Cannot assign a new name, name is read-only");
                    }
                });
            }
            AssignmentNode.prototype = new Node();
            AssignmentNode.prototype.type = "AssignmentNode";
            AssignmentNode.prototype.isAssignmentNode = true;
            AssignmentNode.prototype._compile = function(math, argNames) {
                var evalObject = this.object._compile(math, argNames);
                var evalIndex = this.index ? this.index._compile(math, argNames) : null;
                var evalValue = this.value._compile(math, argNames);
                var name = this.object.name;
                if (!this.index) {
                    if (!type.isSymbolNode(this.object)) {
                        throw new TypeError("SymbolNode expected as object");
                    }
                    return function evalAssignmentNode(scope, args, context) {
                        return setSafeProperty(scope, name, evalValue(scope, args, context));
                    };
                } else if (this.index.isObjectProperty()) {
                    var prop = this.index.getObjectProperty();
                    return function evalAssignmentNode(scope, args, context) {
                        var object = evalObject(scope, args, context);
                        var value = evalValue(scope, args, context);
                        return setSafeProperty(object, prop, value);
                    };
                } else if (type.isSymbolNode(this.object)) {
                    return function evalAssignmentNode(scope, args, context) {
                        var childObject = evalObject(scope, args, context);
                        var value = evalValue(scope, args, context);
                        var index = evalIndex(scope, args, childObject);
                        setSafeProperty(scope, name, assign(childObject, index, value));
                        return value;
                    };
                } else {
                    var evalParentObject = this.object.object._compile(math, argNames);
                    if (this.object.index.isObjectProperty()) {
                        var parentProp = this.object.index.getObjectProperty();
                        return function evalAssignmentNode(scope, args, context) {
                            var parent = evalParentObject(scope, args, context);
                            var childObject = getSafeProperty(parent, parentProp);
                            var index = evalIndex(scope, args, childObject);
                            var value = evalValue(scope, args, context);
                            setSafeProperty(parent, parentProp, assign(childObject, index, value));
                            return value;
                        };
                    } else {
                        var evalParentIndex = this.object.index._compile(math, argNames);
                        return function evalAssignmentNode(scope, args, context) {
                            var parent = evalParentObject(scope, args, context);
                            var parentIndex = evalParentIndex(scope, args, parent);
                            var childObject = access(parent, parentIndex);
                            var index = evalIndex(scope, args, childObject);
                            var value = evalValue(scope, args, context);
                            assign(parent, parentIndex, assign(childObject, index, value));
                            return value;
                        };
                    }
                }
            };
            AssignmentNode.prototype.forEach = function(callback) {
                callback(this.object, "object", this);
                if (this.index) {
                    callback(this.index, "index", this);
                }
                callback(this.value, "value", this);
            };
            AssignmentNode.prototype.map = function(callback) {
                var object = this._ifNode(callback(this.object, "object", this));
                var index = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
                var value = this._ifNode(callback(this.value, "value", this));
                return new AssignmentNode(object, index, value);
            };
            AssignmentNode.prototype.clone = function() {
                return new AssignmentNode(this.object, this.index, this.value);
            };
            function needParenthesis(node, parenthesis) {
                if (!parenthesis) {
                    parenthesis = "keep";
                }
                var precedence = operators.getPrecedence(node, parenthesis);
                var exprPrecedence = operators.getPrecedence(node.value, parenthesis);
                return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
            }
            AssignmentNode.prototype._toString = function(options) {
                var object = this.object.toString(options);
                var index = this.index ? this.index.toString(options) : "";
                var value = this.value.toString(options);
                if (needParenthesis(this, options && options.parenthesis)) {
                    value = "(" + value + ")";
                }
                return object + index + " = " + value;
            };
            AssignmentNode.prototype.toJSON = function() {
                return {
                    mathjs: "AssignmentNode",
                    object: this.object,
                    index: this.index,
                    value: this.value
                };
            };
            AssignmentNode.fromJSON = function(json) {
                return new AssignmentNode(json.object, json.index, json.value);
            };
            AssignmentNode.prototype.toHTML = function(options) {
                var object = this.object.toHTML(options);
                var index = this.index ? this.index.toHTML(options) : "";
                var value = this.value.toHTML(options);
                if (needParenthesis(this, options && options.parenthesis)) {
                    value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
                }
                return object + index + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
            };
            AssignmentNode.prototype._toTex = function(options) {
                var object = this.object.toTex(options);
                var index = this.index ? this.index.toTex(options) : "";
                var value = this.value.toTex(options);
                if (needParenthesis(this, options && options.parenthesis)) {
                    value = "\\left(".concat(value, "\\right)");
                }
                return object + index + ":=" + value;
            };
            return AssignmentNode;
        }
        exports.name = "AssignmentNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../../utils/customs": 108,
        "../operators": 90,
        "./Node": 81,
        "./utils/access": 88,
        "./utils/assign": 89
    } ],
    75: [ function(require, module, exports) {
        "use strict";
        var forEach = require("../../utils/array").forEach;
        var map = require("../../utils/array").map;
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            var ResultSet = load(require("../../type/resultset/ResultSet"));
            function BlockNode(blocks) {
                if (!(this instanceof BlockNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                if (!Array.isArray(blocks)) throw new Error("Array expected");
                this.blocks = blocks.map(function(block) {
                    var node = block && block.node;
                    var visible = block && block.visible !== undefined ? block.visible : true;
                    if (!type.isNode(node)) throw new TypeError('Property "node" must be a Node');
                    if (typeof visible !== "boolean") throw new TypeError('Property "visible" must be a boolean');
                    return {
                        node: node,
                        visible: visible
                    };
                });
            }
            BlockNode.prototype = new Node();
            BlockNode.prototype.type = "BlockNode";
            BlockNode.prototype.isBlockNode = true;
            BlockNode.prototype._compile = function(math, argNames) {
                var evalBlocks = map(this.blocks, function(block) {
                    return {
                        eval: block.node._compile(math, argNames),
                        visible: block.visible
                    };
                });
                return function evalBlockNodes(scope, args, context) {
                    var results = [];
                    forEach(evalBlocks, function evalBlockNode(block) {
                        var result = block.eval(scope, args, context);
                        if (block.visible) {
                            results.push(result);
                        }
                    });
                    return new ResultSet(results);
                };
            };
            BlockNode.prototype.forEach = function(callback) {
                for (var i = 0; i < this.blocks.length; i++) {
                    callback(this.blocks[i].node, "blocks[" + i + "].node", this);
                }
            };
            BlockNode.prototype.map = function(callback) {
                var blocks = [];
                for (var i = 0; i < this.blocks.length; i++) {
                    var block = this.blocks[i];
                    var node = this._ifNode(callback(block.node, "blocks[" + i + "].node", this));
                    blocks[i] = {
                        node: node,
                        visible: block.visible
                    };
                }
                return new BlockNode(blocks);
            };
            BlockNode.prototype.clone = function() {
                var blocks = this.blocks.map(function(block) {
                    return {
                        node: block.node,
                        visible: block.visible
                    };
                });
                return new BlockNode(blocks);
            };
            BlockNode.prototype._toString = function(options) {
                return this.blocks.map(function(param) {
                    return param.node.toString(options) + (param.visible ? "" : ";");
                }).join("\n");
            };
            BlockNode.prototype.toJSON = function() {
                return {
                    mathjs: "BlockNode",
                    blocks: this.blocks
                };
            };
            BlockNode.fromJSON = function(json) {
                return new BlockNode(json.blocks);
            };
            BlockNode.prototype.toHTML = function(options) {
                return this.blocks.map(function(param) {
                    return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
                }).join('<span class="math-separator"><br /></span>');
            };
            BlockNode.prototype._toTex = function(options) {
                return this.blocks.map(function(param) {
                    return param.node.toTex(options) + (param.visible ? "" : ";");
                }).join("\\;\\;\n");
            };
            return BlockNode;
        }
        exports.name = "BlockNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../../type/resultset/ResultSet": 102,
        "../../utils/array": 103,
        "./Node": 81
    } ],
    76: [ function(require, module, exports) {
        "use strict";
        var operators = require("../operators");
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            var mathTypeOf = load(require("../../function/utils/typeof"));
            function ConditionalNode(condition, trueExpr, falseExpr) {
                if (!(this instanceof ConditionalNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                if (!type.isNode(condition)) throw new TypeError("Parameter condition must be a Node");
                if (!type.isNode(trueExpr)) throw new TypeError("Parameter trueExpr must be a Node");
                if (!type.isNode(falseExpr)) throw new TypeError("Parameter falseExpr must be a Node");
                this.condition = condition;
                this.trueExpr = trueExpr;
                this.falseExpr = falseExpr;
            }
            ConditionalNode.prototype = new Node();
            ConditionalNode.prototype.type = "ConditionalNode";
            ConditionalNode.prototype.isConditionalNode = true;
            ConditionalNode.prototype._compile = function(math, argNames) {
                var evalCondition = this.condition._compile(math, argNames);
                var evalTrueExpr = this.trueExpr._compile(math, argNames);
                var evalFalseExpr = this.falseExpr._compile(math, argNames);
                return function evalConditionalNode(scope, args, context) {
                    return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
                };
            };
            ConditionalNode.prototype.forEach = function(callback) {
                callback(this.condition, "condition", this);
                callback(this.trueExpr, "trueExpr", this);
                callback(this.falseExpr, "falseExpr", this);
            };
            ConditionalNode.prototype.map = function(callback) {
                return new ConditionalNode(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
            };
            ConditionalNode.prototype.clone = function() {
                return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);
            };
            ConditionalNode.prototype._toString = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var precedence = operators.getPrecedence(this, parenthesis);
                var condition = this.condition.toString(options);
                var conditionPrecedence = operators.getPrecedence(this.condition, parenthesis);
                if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
                    condition = "(" + condition + ")";
                }
                var trueExpr = this.trueExpr.toString(options);
                var truePrecedence = operators.getPrecedence(this.trueExpr, parenthesis);
                if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
                    trueExpr = "(" + trueExpr + ")";
                }
                var falseExpr = this.falseExpr.toString(options);
                var falsePrecedence = operators.getPrecedence(this.falseExpr, parenthesis);
                if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
                    falseExpr = "(" + falseExpr + ")";
                }
                return condition + " ? " + trueExpr + " : " + falseExpr;
            };
            ConditionalNode.prototype.toJSON = function() {
                return {
                    mathjs: "ConditionalNode",
                    condition: this.condition,
                    trueExpr: this.trueExpr,
                    falseExpr: this.falseExpr
                };
            };
            ConditionalNode.fromJSON = function(json) {
                return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);
            };
            ConditionalNode.prototype.toHTML = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var precedence = operators.getPrecedence(this, parenthesis);
                var condition = this.condition.toHTML(options);
                var conditionPrecedence = operators.getPrecedence(this.condition, parenthesis);
                if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
                    condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                var trueExpr = this.trueExpr.toHTML(options);
                var truePrecedence = operators.getPrecedence(this.trueExpr, parenthesis);
                if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
                    trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                var falseExpr = this.falseExpr.toHTML(options);
                var falsePrecedence = operators.getPrecedence(this.falseExpr, parenthesis);
                if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
                    falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
            };
            ConditionalNode.prototype._toTex = function(options) {
                return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
            };
            function testCondition(condition) {
                if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
                    return !!condition;
                }
                if (condition) {
                    if (type.isBigNumber(condition)) {
                        return !condition.isZero();
                    }
                    if (type.isComplex(condition)) {
                        return !!(condition.re || condition.im);
                    }
                    if (type.isUnit(condition)) {
                        return !!condition.value;
                    }
                }
                if (condition === null || condition === undefined) {
                    return false;
                }
                throw new TypeError('Unsupported type of condition "' + mathTypeOf(condition) + '"');
            }
            return ConditionalNode;
        }
        exports.name = "ConditionalNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../../function/utils/typeof": 95,
        "../operators": 90,
        "./Node": 81
    } ],
    77: [ function(require, module, exports) {
        "use strict";
        var format = require("../../utils/string").format;
        var escapeLatex = require("../../utils/latex").escape;
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            var getType = load(require("../../function/utils/typeof"));
            function ConstantNode(value) {
                if (!(this instanceof ConstantNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                if (arguments.length === 2) {
                    throw new SyntaxError("new ConstantNode(valueStr, valueType) is not supported anymore since math v4.0.0. Use new ConstantNode(value) instead, where value is a non-stringified value.");
                }
                this.value = value;
            }
            ConstantNode.prototype = new Node();
            ConstantNode.prototype.type = "ConstantNode";
            ConstantNode.prototype.isConstantNode = true;
            ConstantNode.prototype._compile = function(math, argNames) {
                var value = this.value;
                return function evalConstantNode() {
                    return value;
                };
            };
            ConstantNode.prototype.forEach = function(callback) {};
            ConstantNode.prototype.map = function(callback) {
                return this.clone();
            };
            ConstantNode.prototype.clone = function() {
                return new ConstantNode(this.value);
            };
            ConstantNode.prototype._toString = function(options) {
                return format(this.value, options);
            };
            ConstantNode.prototype.toHTML = function(options) {
                var value = this._toString(options);
                switch (getType(this.value)) {
                  case "number":
                  case "BigNumber":
                  case "Fraction":
                    return '<span class="math-number">' + value + "</span>";

                  case "string":
                    return '<span class="math-string">' + value + "</span>";

                  case "boolean":
                    return '<span class="math-boolean">' + value + "</span>";

                  case "null":
                    return '<span class="math-null-symbol">' + value + "</span>";

                  case "undefined":
                    return '<span class="math-undefined">' + value + "</span>";

                  default:
                    return '<span class="math-symbol">' + value + "</span>";
                }
            };
            ConstantNode.prototype.toJSON = function() {
                return {
                    mathjs: "ConstantNode",
                    value: this.value
                };
            };
            ConstantNode.fromJSON = function(json) {
                return new ConstantNode(json.value);
            };
            ConstantNode.prototype._toTex = function(options) {
                var value = this._toString(options);
                switch (getType(this.value)) {
                  case "string":
                    return "\\mathtt{" + escapeLatex(value) + "}";

                  case "number":
                  case "BigNumber":
                    var index = value.toLowerCase().indexOf("e");
                    if (index !== -1) {
                        return value.substring(0, index) + "\\cdot10^{" + value.substring(index + 1) + "}";
                    }
                    return value;

                  case "Fraction":
                    return this.value.toLatex();

                  default:
                    return value;
                }
            };
            return ConstantNode;
        }
        exports.name = "ConstantNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../../function/utils/typeof": 95,
        "../../utils/latex": 110,
        "../../utils/string": 114,
        "./Node": 81
    } ],
    78: [ function(require, module, exports) {
        "use strict";
        var keywords = require("../keywords");
        var escape = require("../../utils/string").escape;
        var forEach = require("../../utils/array").forEach;
        var join = require("../../utils/array").join;
        var latex = require("../../utils/latex");
        var operators = require("../operators");
        var setSafeProperty = require("../../utils/customs").setSafeProperty;
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            function FunctionAssignmentNode(name, params, expr) {
                if (!(this instanceof FunctionAssignmentNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                if (typeof name !== "string") throw new TypeError('String expected for parameter "name"');
                if (!Array.isArray(params)) throw new TypeError('Array containing strings or objects expected for parameter "params"');
                if (!type.isNode(expr)) throw new TypeError('Node expected for parameter "expr"');
                if (name in keywords) throw new Error('Illegal function name, "' + name + '" is a reserved keyword');
                this.name = name;
                this.params = params.map(function(param) {
                    return param && param.name || param;
                });
                this.types = params.map(function(param) {
                    return param && param.type || "any";
                });
                this.expr = expr;
            }
            FunctionAssignmentNode.prototype = new Node();
            FunctionAssignmentNode.prototype.type = "FunctionAssignmentNode";
            FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;
            FunctionAssignmentNode.prototype._compile = function(math, argNames) {
                var childArgNames = Object.create(argNames);
                forEach(this.params, function(param) {
                    childArgNames[param] = true;
                });
                var evalExpr = this.expr._compile(math, childArgNames);
                var name = this.name;
                var params = this.params;
                var signature = join(this.types, ",");
                var syntax = name + "(" + join(this.params, ", ") + ")";
                return function evalFunctionAssignmentNode(scope, args, context) {
                    var signatures = {};
                    signatures[signature] = function() {
                        var childArgs = Object.create(args);
                        for (var i = 0; i < params.length; i++) {
                            childArgs[params[i]] = arguments[i];
                        }
                        return evalExpr(scope, childArgs, context);
                    };
                    var fn = typed(name, signatures);
                    fn.syntax = syntax;
                    setSafeProperty(scope, name, fn);
                    return fn;
                };
            };
            FunctionAssignmentNode.prototype.forEach = function(callback) {
                callback(this.expr, "expr", this);
            };
            FunctionAssignmentNode.prototype.map = function(callback) {
                var expr = this._ifNode(callback(this.expr, "expr", this));
                return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
            };
            FunctionAssignmentNode.prototype.clone = function() {
                return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);
            };
            function needParenthesis(node, parenthesis) {
                var precedence = operators.getPrecedence(node, parenthesis);
                var exprPrecedence = operators.getPrecedence(node.expr, parenthesis);
                return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
            }
            FunctionAssignmentNode.prototype._toString = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var expr = this.expr.toString(options);
                if (needParenthesis(this, parenthesis)) {
                    expr = "(" + expr + ")";
                }
                return this.name + "(" + this.params.join(", ") + ") = " + expr;
            };
            FunctionAssignmentNode.prototype.toJSON = function() {
                var types = this.types;
                return {
                    mathjs: "FunctionAssignmentNode",
                    name: this.name,
                    params: this.params.map(function(param, index) {
                        return {
                            name: param,
                            type: types[index]
                        };
                    }),
                    expr: this.expr
                };
            };
            FunctionAssignmentNode.fromJSON = function(json) {
                return new FunctionAssignmentNode(json.name, json.params, json.expr);
            };
            FunctionAssignmentNode.prototype.toHTML = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var params = [];
                for (var i = 0; i < this.params.length; i++) {
                    params.push('<span class="math-symbol math-parameter">' + escape(this.params[i]) + "</span>");
                }
                var expr = this.expr.toHTML(options);
                if (needParenthesis(this, parenthesis)) {
                    expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                return '<span class="math-function">' + escape(this.name) + "</span>" + '<span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
            };
            FunctionAssignmentNode.prototype._toTex = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var expr = this.expr.toTex(options);
                if (needParenthesis(this, parenthesis)) {
                    expr = "\\left(".concat(expr, "\\right)");
                }
                return "\\mathrm{" + this.name + "}\\left(" + this.params.map(latex.toSymbol).join(",") + "\\right):=" + expr;
            };
            return FunctionAssignmentNode;
        }
        exports.name = "FunctionAssignmentNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../../utils/array": 103,
        "../../utils/customs": 108,
        "../../utils/latex": 110,
        "../../utils/string": 114,
        "../keywords": 71,
        "../operators": 90,
        "./Node": 81
    } ],
    79: [ function(require, module, exports) {
        "use strict";
        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }
        function _extends() {
            _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }
                return target;
            };
            return _extends.apply(this, arguments);
        }
        var latex = require("../../utils/latex");
        var escape = require("../../utils/string").escape;
        var hasOwnProperty = require("../../utils/object").hasOwnProperty;
        var map = require("../../utils/array").map;
        var validateSafeMethod = require("../../utils/customs").validateSafeMethod;
        var getSafeProperty = require("../../utils/customs").getSafeProperty;
        function factory(type, config, load, typed, math) {
            var Node = load(require("./Node"));
            var SymbolNode = load(require("./SymbolNode"));
            function FunctionNode(fn, args) {
                if (!(this instanceof FunctionNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                if (typeof fn === "string") {
                    fn = new SymbolNode(fn);
                }
                if (!type.isNode(fn)) throw new TypeError('Node expected as parameter "fn"');
                if (!Array.isArray(args) || !args.every(type.isNode)) {
                    throw new TypeError('Array containing Nodes expected for parameter "args"');
                }
                this.fn = fn;
                this.args = args || [];
                Object.defineProperty(this, "name", {
                    get: function() {
                        return this.fn.name || "";
                    }.bind(this),
                    set: function set() {
                        throw new Error("Cannot assign a new name, name is read-only");
                    }
                });
                var deprecated = function deprecated() {
                    throw new Error("Property `FunctionNode.object` is deprecated, use `FunctionNode.fn` instead");
                };
                Object.defineProperty(this, "object", {
                    get: deprecated,
                    set: deprecated
                });
            }
            FunctionNode.prototype = new Node();
            FunctionNode.prototype.type = "FunctionNode";
            FunctionNode.prototype.isFunctionNode = true;
            FunctionNode.prototype._compile = function(math, argNames) {
                if (!(this instanceof FunctionNode)) {
                    throw new TypeError("No valid FunctionNode");
                }
                var evalArgs = map(this.args, function(arg) {
                    return arg._compile(math, argNames);
                });
                if (type.isSymbolNode(this.fn)) {
                    var name = this.fn.name;
                    var fn = name in math ? getSafeProperty(math, name) : undefined;
                    var isRaw = typeof fn === "function" && fn.rawArgs === true;
                    if (isRaw) {
                        var rawArgs = this.args;
                        return function evalFunctionNode(scope, args, context) {
                            return (name in scope ? getSafeProperty(scope, name) : fn)(rawArgs, math, _extends({}, scope, args));
                        };
                    } else {
                        if (evalArgs.length === 1) {
                            var evalArg0 = evalArgs[0];
                            return function evalFunctionNode(scope, args, context) {
                                return (name in scope ? getSafeProperty(scope, name) : fn)(evalArg0(scope, args, context));
                            };
                        } else if (evalArgs.length === 2) {
                            var _evalArg = evalArgs[0];
                            var evalArg1 = evalArgs[1];
                            return function evalFunctionNode(scope, args, context) {
                                return (name in scope ? getSafeProperty(scope, name) : fn)(_evalArg(scope, args, context), evalArg1(scope, args, context));
                            };
                        } else {
                            return function evalFunctionNode(scope, args, context) {
                                return (name in scope ? getSafeProperty(scope, name) : fn).apply(null, map(evalArgs, function(evalArg) {
                                    return evalArg(scope, args, context);
                                }));
                            };
                        }
                    }
                } else if (type.isAccessorNode(this.fn) && type.isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
                    var evalObject = this.fn.object._compile(math, argNames);
                    var prop = this.fn.index.getObjectProperty();
                    var _rawArgs = this.args;
                    return function evalFunctionNode(scope, args, context) {
                        var object = evalObject(scope, args, context);
                        validateSafeMethod(object, prop);
                        var isRaw = object[prop] && object[prop].rawArgs;
                        return isRaw ? object[prop](_rawArgs, math, _extends({}, scope, args)) : object[prop].apply(object, map(evalArgs, function(evalArg) {
                            return evalArg(scope, args, context);
                        }));
                    };
                } else {
                    var evalFn = this.fn._compile(math, argNames);
                    var _rawArgs2 = this.args;
                    return function evalFunctionNode(scope, args, context) {
                        var fn = evalFn(scope, args, context);
                        var isRaw = fn && fn.rawArgs;
                        return isRaw ? fn(_rawArgs2, math, _extends({}, scope, args)) : fn.apply(fn, map(evalArgs, function(evalArg) {
                            return evalArg(scope, args, context);
                        }));
                    };
                }
            };
            FunctionNode.prototype.forEach = function(callback) {
                callback(this.fn, "fn", this);
                for (var i = 0; i < this.args.length; i++) {
                    callback(this.args[i], "args[" + i + "]", this);
                }
            };
            FunctionNode.prototype.map = function(callback) {
                var fn = this._ifNode(callback(this.fn, "fn", this));
                var args = [];
                for (var i = 0; i < this.args.length; i++) {
                    args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
                }
                return new FunctionNode(fn, args);
            };
            FunctionNode.prototype.clone = function() {
                return new FunctionNode(this.fn, this.args.slice(0));
            };
            var nodeToString = FunctionNode.prototype.toString;
            FunctionNode.prototype.toString = function(options) {
                var customString;
                var name = this.fn.toString(options);
                if (options && _typeof(options.handler) === "object" && hasOwnProperty(options.handler, name)) {
                    customString = options.handler[name](this, options);
                }
                if (typeof customString !== "undefined") {
                    return customString;
                }
                return nodeToString.call(this, options);
            };
            FunctionNode.prototype._toString = function(options) {
                var args = this.args.map(function(arg) {
                    return arg.toString(options);
                });
                var fn = type.isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
                return fn + "(" + args.join(", ") + ")";
            };
            FunctionNode.prototype.toJSON = function() {
                return {
                    mathjs: "FunctionNode",
                    fn: this.fn,
                    args: this.args
                };
            };
            FunctionNode.fromJSON = function(json) {
                return new FunctionNode(json.fn, json.args);
            };
            FunctionNode.prototype.toHTML = function(options) {
                var args = this.args.map(function(arg) {
                    return arg.toHTML(options);
                });
                return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
            };
            function expandTemplate(template, node, options) {
                var latex = "";
                var regex = new RegExp("\\$(?:\\{([a-z_][a-z_0-9]*)(?:\\[([0-9]+)\\])?\\}|\\$)", "ig");
                var inputPos = 0;
                var match;
                while ((match = regex.exec(template)) !== null) {
                    latex += template.substring(inputPos, match.index);
                    inputPos = match.index;
                    if (match[0] === "$$") {
                        latex += "$";
                        inputPos++;
                    } else {
                        inputPos += match[0].length;
                        var property = node[match[1]];
                        if (!property) {
                            throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
                        }
                        if (match[2] === undefined) {
                            switch (_typeof(property)) {
                              case "string":
                                latex += property;
                                break;

                              case "object":
                                if (type.isNode(property)) {
                                    latex += property.toTex(options);
                                } else if (Array.isArray(property)) {
                                    latex += property.map(function(arg, index) {
                                        if (type.isNode(arg)) {
                                            return arg.toTex(options);
                                        }
                                        throw new TypeError("Template: " + match[1] + "[" + index + "] is not a Node.");
                                    }).join(",");
                                } else {
                                    throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
                                }
                                break;

                              default:
                                throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
                            }
                        } else {
                            if (type.isNode(property[match[2]] && property[match[2]])) {
                                latex += property[match[2]].toTex(options);
                            } else {
                                throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
                            }
                        }
                    }
                }
                latex += template.slice(inputPos);
                return latex;
            }
            var nodeToTex = FunctionNode.prototype.toTex;
            FunctionNode.prototype.toTex = function(options) {
                var customTex;
                if (options && _typeof(options.handler) === "object" && hasOwnProperty(options.handler, this.name)) {
                    customTex = options.handler[this.name](this, options);
                }
                if (typeof customTex !== "undefined") {
                    return customTex;
                }
                return nodeToTex.call(this, options);
            };
            FunctionNode.prototype._toTex = function(options) {
                var args = this.args.map(function(arg) {
                    return arg.toTex(options);
                });
                var latexConverter;
                if (math[this.name] && (typeof math[this.name].toTex === "function" || _typeof(math[this.name].toTex) === "object" || typeof math[this.name].toTex === "string")) {
                    latexConverter = math[this.name].toTex;
                }
                var customToTex;
                switch (_typeof(latexConverter)) {
                  case "function":
                    customToTex = latexConverter(this, options);
                    break;

                  case "string":
                    customToTex = expandTemplate(latexConverter, this, options);
                    break;

                  case "object":
                    switch (_typeof(latexConverter[args.length])) {
                      case "function":
                        customToTex = latexConverter[args.length](this, options);
                        break;

                      case "string":
                        customToTex = expandTemplate(latexConverter[args.length], this, options);
                        break;
                    }
                }
                if (typeof customToTex !== "undefined") {
                    return customToTex;
                }
                return expandTemplate(latex.defaultTemplate, this, options);
            };
            FunctionNode.prototype.getIdentifier = function() {
                return this.type + ":" + this.name;
            };
            return FunctionNode;
        }
        exports.name = "FunctionNode";
        exports.path = "expression.node";
        exports.math = true;
        exports.factory = factory;
    }, {
        "../../utils/array": 103,
        "../../utils/customs": 108,
        "../../utils/latex": 110,
        "../../utils/object": 112,
        "../../utils/string": 114,
        "./Node": 81,
        "./SymbolNode": 87
    } ],
    80: [ function(require, module, exports) {
        "use strict";
        var map = require("../../utils/array").map;
        var escape = require("../../utils/string").escape;
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            var Range = load(require("../../type/matrix/Range"));
            var isArray = Array.isArray;
            function IndexNode(dimensions, dotNotation) {
                if (!(this instanceof IndexNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                this.dimensions = dimensions;
                this.dotNotation = dotNotation || false;
                if (!isArray(dimensions) || !dimensions.every(type.isNode)) {
                    throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
                }
                if (this.dotNotation && !this.isObjectProperty()) {
                    throw new Error("dotNotation only applicable for object properties");
                }
                var deprecated = function deprecated() {
                    throw new Error("Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead");
                };
                Object.defineProperty(this, "object", {
                    get: deprecated,
                    set: deprecated
                });
            }
            IndexNode.prototype = new Node();
            IndexNode.prototype.type = "IndexNode";
            IndexNode.prototype.isIndexNode = true;
            IndexNode.prototype._compile = function(math, argNames) {
                var evalDimensions = map(this.dimensions, function(range, i) {
                    if (type.isRangeNode(range)) {
                        if (range.needsEnd()) {
                            var childArgNames = Object.create(argNames);
                            childArgNames["end"] = true;
                            var evalStart = range.start._compile(math, childArgNames);
                            var evalEnd = range.end._compile(math, childArgNames);
                            var evalStep = range.step ? range.step._compile(math, childArgNames) : function() {
                                return 1;
                            };
                            return function evalDimension(scope, args, context) {
                                var size = math.size(context).valueOf();
                                var childArgs = Object.create(args);
                                childArgs["end"] = size[i];
                                return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));
                            };
                        } else {
                            var _evalStart = range.start._compile(math, argNames);
                            var _evalEnd = range.end._compile(math, argNames);
                            var _evalStep = range.step ? range.step._compile(math, argNames) : function() {
                                return 1;
                            };
                            return function evalDimension(scope, args, context) {
                                return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));
                            };
                        }
                    } else if (type.isSymbolNode(range) && range.name === "end") {
                        var _childArgNames = Object.create(argNames);
                        _childArgNames["end"] = true;
                        var evalRange = range._compile(math, _childArgNames);
                        return function evalDimension(scope, args, context) {
                            var size = math.size(context).valueOf();
                            var childArgs = Object.create(args);
                            childArgs["end"] = size[i];
                            return evalRange(scope, childArgs, context);
                        };
                    } else {
                        var _evalRange = range._compile(math, argNames);
                        return function evalDimension(scope, args, context) {
                            return _evalRange(scope, args, context);
                        };
                    }
                });
                return function evalIndexNode(scope, args, context) {
                    var dimensions = map(evalDimensions, function(evalDimension) {
                        return evalDimension(scope, args, context);
                    });
                    return math.index.apply(math, dimensions);
                };
            };
            IndexNode.prototype.forEach = function(callback) {
                for (var i = 0; i < this.dimensions.length; i++) {
                    callback(this.dimensions[i], "dimensions[" + i + "]", this);
                }
            };
            IndexNode.prototype.map = function(callback) {
                var dimensions = [];
                for (var i = 0; i < this.dimensions.length; i++) {
                    dimensions[i] = this._ifNode(callback(this.dimensions[i], "dimensions[" + i + "]", this));
                }
                return new IndexNode(dimensions);
            };
            IndexNode.prototype.clone = function() {
                return new IndexNode(this.dimensions.slice(0));
            };
            IndexNode.prototype.isObjectProperty = function() {
                return this.dimensions.length === 1 && type.isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
            };
            IndexNode.prototype.getObjectProperty = function() {
                return this.isObjectProperty() ? this.dimensions[0].value : null;
            };
            IndexNode.prototype._toString = function(options) {
                return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
            };
            IndexNode.prototype.toJSON = function() {
                return {
                    mathjs: "IndexNode",
                    dimensions: this.dimensions,
                    dotNotation: this.dotNotation
                };
            };
            IndexNode.fromJSON = function(json) {
                return new IndexNode(json.dimensions, json.dotNotation);
            };
            IndexNode.prototype.toHTML = function(options) {
                var dimensions = [];
                for (var i = 0; i < this.dimensions.length; i++) {
                    dimensions[i] = this.dimensions[i].toHTML();
                }
                if (this.dotNotation) {
                    return '<span class="math-operator math-accessor-operator">.</span>' + '<span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
                } else {
                    return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
                }
            };
            IndexNode.prototype._toTex = function(options) {
                var dimensions = this.dimensions.map(function(range) {
                    return range.toTex(options);
                });
                return this.dotNotation ? "." + this.getObjectProperty() + "" : "_{" + dimensions.join(",") + "}";
            };
            function createRange(start, end, step) {
                return new Range(type.isBigNumber(start) ? start.toNumber() : start, type.isBigNumber(end) ? end.toNumber() : end, type.isBigNumber(step) ? step.toNumber() : step);
            }
            return IndexNode;
        }
        exports.name = "IndexNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../../type/matrix/Range": 98,
        "../../utils/array": 103,
        "../../utils/string": 114,
        "./Node": 81
    } ],
    81: [ function(require, module, exports) {
        "use strict";
        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }
        var keywords = require("../keywords");
        var deepEqual = require("../../utils/object").deepEqual;
        var hasOwnProperty = require("../../utils/object").hasOwnProperty;
        function factory(type, config, load, typed, math) {
            function Node() {
                if (!(this instanceof Node)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
            }
            Node.prototype.eval = function(scope) {
                return this.compile().eval(scope);
            };
            Node.prototype.type = "Node";
            Node.prototype.isNode = true;
            Node.prototype.comment = "";
            Node.prototype.compile = function() {
                var expr = this._compile(math.expression.mathWithTransform, {});
                var args = {};
                var context = null;
                return {
                    eval: function evalNode(scope) {
                        var s = scope || {};
                        _validateScope(s);
                        return expr(s, args, context);
                    }
                };
            };
            Node.prototype._compile = function(math, argNames) {
                throw new Error("Method _compile should be implemented by type " + this.type);
            };
            Node.prototype.forEach = function(callback) {
                throw new Error("Cannot run forEach on a Node interface");
            };
            Node.prototype.map = function(callback) {
                throw new Error("Cannot run map on a Node interface");
            };
            Node.prototype._ifNode = function(node) {
                if (!type.isNode(node)) {
                    throw new TypeError("Callback function must return a Node");
                }
                return node;
            };
            Node.prototype.traverse = function(callback) {
                callback(this, null, null);
                function _traverse(node, callback) {
                    node.forEach(function(child, path, parent) {
                        callback(child, path, parent);
                        _traverse(child, callback);
                    });
                }
                _traverse(this, callback);
            };
            Node.prototype.transform = function(callback) {
                function _transform(node, callback) {
                    return node.map(function(child, path, parent) {
                        var replacement = callback(child, path, parent);
                        return _transform(replacement, callback);
                    });
                }
                var replacement = callback(this, null, null);
                return _transform(replacement, callback);
            };
            Node.prototype.filter = function(callback) {
                var nodes = [];
                this.traverse(function(node, path, parent) {
                    if (callback(node, path, parent)) {
                        nodes.push(node);
                    }
                });
                return nodes;
            };
            Node.prototype.find = function() {
                throw new Error("Function Node.find is deprecated. Use Node.filter instead.");
            };
            Node.prototype.match = function() {
                throw new Error("Function Node.match is deprecated. See functions Node.filter, Node.transform, Node.traverse.");
            };
            Node.prototype.clone = function() {
                throw new Error("Cannot clone a Node interface");
            };
            Node.prototype.cloneDeep = function() {
                return this.map(function(node) {
                    return node.cloneDeep();
                });
            };
            Node.prototype.equals = function(other) {
                return other ? deepEqual(this, other) : false;
            };
            Node.prototype.toString = function(options) {
                var customString;
                if (options && _typeof(options) === "object") {
                    switch (_typeof(options.handler)) {
                      case "object":
                      case "undefined":
                        break;

                      case "function":
                        customString = options.handler(this, options);
                        break;

                      default:
                        throw new TypeError("Object or function expected as callback");
                    }
                }
                if (typeof customString !== "undefined") {
                    return customString;
                }
                return this._toString(options);
            };
            Node.prototype.toJSON = function() {
                throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
            };
            Node.prototype.toHTML = function(options) {
                var customString;
                if (options && _typeof(options) === "object") {
                    switch (_typeof(options.handler)) {
                      case "object":
                      case "undefined":
                        break;

                      case "function":
                        customString = options.handler(this, options);
                        break;

                      default:
                        throw new TypeError("Object or function expected as callback");
                    }
                }
                if (typeof customString !== "undefined") {
                    return customString;
                }
                return this.toHTML(options);
            };
            Node.prototype._toString = function() {
                throw new Error("_toString not implemented for " + this.type);
            };
            Node.prototype.toTex = function(options) {
                var customTex;
                if (options && _typeof(options) === "object") {
                    switch (_typeof(options.handler)) {
                      case "object":
                      case "undefined":
                        break;

                      case "function":
                        customTex = options.handler(this, options);
                        break;

                      default:
                        throw new TypeError("Object or function expected as callback");
                    }
                }
                if (typeof customTex !== "undefined") {
                    return customTex;
                }
                return this._toTex(options);
            };
            Node.prototype._toTex = function(options) {
                throw new Error("_toTex not implemented for " + this.type);
            };
            Node.prototype.getIdentifier = function() {
                return this.type;
            };
            Node.prototype.getContent = function() {
                return this;
            };
            function _validateScope(scope) {
                for (var symbol in scope) {
                    if (hasOwnProperty(scope, symbol)) {
                        if (symbol in keywords) {
                            throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
                        }
                    }
                }
            }
            return Node;
        }
        exports.name = "Node";
        exports.path = "expression.node";
        exports.math = true;
        exports.factory = factory;
    }, {
        "../../utils/object": 112,
        "../keywords": 71
    } ],
    82: [ function(require, module, exports) {
        "use strict";
        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }
        var stringify = require("../../utils/string").stringify;
        var escape = require("../../utils/string").escape;
        var isSafeProperty = require("../../utils/customs").isSafeProperty;
        var hasOwnProperty = require("../../utils/object").hasOwnProperty;
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            function ObjectNode(properties) {
                if (!(this instanceof ObjectNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                this.properties = properties || {};
                if (properties) {
                    if (!(_typeof(properties) === "object") || !Object.keys(properties).every(function(key) {
                        return type.isNode(properties[key]);
                    })) {
                        throw new TypeError("Object containing Nodes expected");
                    }
                }
            }
            ObjectNode.prototype = new Node();
            ObjectNode.prototype.type = "ObjectNode";
            ObjectNode.prototype.isObjectNode = true;
            ObjectNode.prototype._compile = function(math, argNames) {
                var evalEntries = {};
                for (var key in this.properties) {
                    if (hasOwnProperty(this.properties, key)) {
                        var stringifiedKey = stringify(key);
                        var parsedKey = JSON.parse(stringifiedKey);
                        if (!isSafeProperty(this.properties, parsedKey)) {
                            throw new Error('No access to property "' + parsedKey + '"');
                        }
                        evalEntries[parsedKey] = this.properties[key]._compile(math, argNames);
                    }
                }
                return function evalObjectNode(scope, args, context) {
                    var obj = {};
                    for (var _key in evalEntries) {
                        if (hasOwnProperty(evalEntries, _key)) {
                            obj[_key] = evalEntries[_key](scope, args, context);
                        }
                    }
                    return obj;
                };
            };
            ObjectNode.prototype.forEach = function(callback) {
                for (var key in this.properties) {
                    if (this.properties.hasOwnProperty(key)) {
                        callback(this.properties[key], "properties[" + stringify(key) + "]", this);
                    }
                }
            };
            ObjectNode.prototype.map = function(callback) {
                var properties = {};
                for (var key in this.properties) {
                    if (this.properties.hasOwnProperty(key)) {
                        properties[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
                    }
                }
                return new ObjectNode(properties);
            };
            ObjectNode.prototype.clone = function() {
                var properties = {};
                for (var key in this.properties) {
                    if (this.properties.hasOwnProperty(key)) {
                        properties[key] = this.properties[key];
                    }
                }
                return new ObjectNode(properties);
            };
            ObjectNode.prototype._toString = function(options) {
                var entries = [];
                for (var key in this.properties) {
                    if (this.properties.hasOwnProperty(key)) {
                        entries.push(stringify(key) + ": " + this.properties[key].toString(options));
                    }
                }
                return "{" + entries.join(", ") + "}";
            };
            ObjectNode.prototype.toJSON = function() {
                return {
                    mathjs: "ObjectNode",
                    properties: this.properties
                };
            };
            ObjectNode.fromJSON = function(json) {
                return new ObjectNode(json.properties);
            };
            ObjectNode.prototype.toHTML = function(options) {
                var entries = [];
                for (var key in this.properties) {
                    if (this.properties.hasOwnProperty(key)) {
                        entries.push('<span class="math-symbol math-property">' + escape(key) + "</span>" + '<span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options));
                    }
                }
                return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
            };
            ObjectNode.prototype._toTex = function(options) {
                var entries = [];
                for (var key in this.properties) {
                    if (this.properties.hasOwnProperty(key)) {
                        entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
                    }
                }
                return "\\left\\{\\begin{array}{ll}".concat(entries.join("\n"), "\\end{array}\\right\\}");
            };
            return ObjectNode;
        }
        exports.name = "ObjectNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../../utils/customs": 108,
        "../../utils/object": 112,
        "../../utils/string": 114,
        "./Node": 81
    } ],
    83: [ function(require, module, exports) {
        "use strict";
        var latex = require("../../utils/latex");
        var map = require("../../utils/array").map;
        var escape = require("../../utils/string").escape;
        var isSafeMethod = require("../../utils/customs").isSafeMethod;
        var getSafeProperty = require("../../utils/customs").getSafeProperty;
        var operators = require("../operators");
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            function OperatorNode(op, fn, args, implicit) {
                if (!(this instanceof OperatorNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                if (typeof op !== "string") {
                    throw new TypeError('string expected for parameter "op"');
                }
                if (typeof fn !== "string") {
                    throw new TypeError('string expected for parameter "fn"');
                }
                if (!Array.isArray(args) || !args.every(type.isNode)) {
                    throw new TypeError('Array containing Nodes expected for parameter "args"');
                }
                this.implicit = implicit === true;
                this.op = op;
                this.fn = fn;
                this.args = args || [];
            }
            OperatorNode.prototype = new Node();
            OperatorNode.prototype.type = "OperatorNode";
            OperatorNode.prototype.isOperatorNode = true;
            OperatorNode.prototype._compile = function(math, argNames) {
                if (typeof this.fn !== "string" || !isSafeMethod(math, this.fn)) {
                    if (!math[this.fn]) {
                        throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
                    } else {
                        throw new Error('No access to function "' + this.fn + '"');
                    }
                }
                var fn = getSafeProperty(math, this.fn);
                var evalArgs = map(this.args, function(arg) {
                    return arg._compile(math, argNames);
                });
                if (evalArgs.length === 1) {
                    var evalArg0 = evalArgs[0];
                    return function evalOperatorNode(scope, args, context) {
                        return fn(evalArg0(scope, args, context));
                    };
                } else if (evalArgs.length === 2) {
                    var _evalArg = evalArgs[0];
                    var evalArg1 = evalArgs[1];
                    return function evalOperatorNode(scope, args, context) {
                        return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
                    };
                } else {
                    return function evalOperatorNode(scope, args, context) {
                        return fn.apply(null, map(evalArgs, function(evalArg) {
                            return evalArg(scope, args, context);
                        }));
                    };
                }
            };
            OperatorNode.prototype.forEach = function(callback) {
                for (var i = 0; i < this.args.length; i++) {
                    callback(this.args[i], "args[" + i + "]", this);
                }
            };
            OperatorNode.prototype.map = function(callback) {
                var args = [];
                for (var i = 0; i < this.args.length; i++) {
                    args[i] = this._ifNode(callback(this.args[i], "args[" + i + "]", this));
                }
                return new OperatorNode(this.op, this.fn, args, this.implicit);
            };
            OperatorNode.prototype.clone = function() {
                return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);
            };
            OperatorNode.prototype.isUnary = function() {
                return this.args.length === 1;
            };
            OperatorNode.prototype.isBinary = function() {
                return this.args.length === 2;
            };
            function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
                var precedence = operators.getPrecedence(root, parenthesis);
                var associativity = operators.getAssociativity(root, parenthesis);
                if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
                    var parens = args.map(function(arg) {
                        switch (arg.getContent().type) {
                          case "ArrayNode":
                          case "ConstantNode":
                          case "SymbolNode":
                          case "ParenthesisNode":
                            return false;

                          default:
                            return true;
                        }
                    });
                    return parens;
                }
                var result;
                switch (args.length) {
                  case 0:
                    result = [];
                    break;

                  case 1:
                    var operandPrecedence = operators.getPrecedence(args[0], parenthesis);
                    if (latex && operandPrecedence !== null) {
                        var operandIdentifier;
                        var rootIdentifier;
                        if (parenthesis === "keep") {
                            operandIdentifier = args[0].getIdentifier();
                            rootIdentifier = root.getIdentifier();
                        } else {
                            operandIdentifier = args[0].getContent().getIdentifier();
                            rootIdentifier = root.getContent().getIdentifier();
                        }
                        if (operators.properties[precedence][rootIdentifier].latexLeftParens === false) {
                            result = [ false ];
                            break;
                        }
                        if (operators.properties[operandPrecedence][operandIdentifier].latexParens === false) {
                            result = [ false ];
                            break;
                        }
                    }
                    if (operandPrecedence === null) {
                        result = [ false ];
                        break;
                    }
                    if (operandPrecedence <= precedence) {
                        result = [ true ];
                        break;
                    }
                    result = [ false ];
                    break;

                  case 2:
                    var lhsParens;
                    var lhsPrecedence = operators.getPrecedence(args[0], parenthesis);
                    var assocWithLhs = operators.isAssociativeWith(root, args[0], parenthesis);
                    if (lhsPrecedence === null) {
                        lhsParens = false;
                    } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
                        lhsParens = true;
                    } else if (lhsPrecedence < precedence) {
                        lhsParens = true;
                    } else {
                        lhsParens = false;
                    }
                    var rhsParens;
                    var rhsPrecedence = operators.getPrecedence(args[1], parenthesis);
                    var assocWithRhs = operators.isAssociativeWith(root, args[1], parenthesis);
                    if (rhsPrecedence === null) {
                        rhsParens = false;
                    } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
                        rhsParens = true;
                    } else if (rhsPrecedence < precedence) {
                        rhsParens = true;
                    } else {
                        rhsParens = false;
                    }
                    if (latex) {
                        var _rootIdentifier;
                        var lhsIdentifier;
                        var rhsIdentifier;
                        if (parenthesis === "keep") {
                            _rootIdentifier = root.getIdentifier();
                            lhsIdentifier = root.args[0].getIdentifier();
                            rhsIdentifier = root.args[1].getIdentifier();
                        } else {
                            _rootIdentifier = root.getContent().getIdentifier();
                            lhsIdentifier = root.args[0].getContent().getIdentifier();
                            rhsIdentifier = root.args[1].getContent().getIdentifier();
                        }
                        if (lhsPrecedence !== null) {
                            if (operators.properties[precedence][_rootIdentifier].latexLeftParens === false) {
                                lhsParens = false;
                            }
                            if (operators.properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                                lhsParens = false;
                            }
                        }
                        if (rhsPrecedence !== null) {
                            if (operators.properties[precedence][_rootIdentifier].latexRightParens === false) {
                                rhsParens = false;
                            }
                            if (operators.properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                                rhsParens = false;
                            }
                        }
                    }
                    result = [ lhsParens, rhsParens ];
                    break;

                  default:
                    if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
                        result = args.map(function(arg) {
                            var argPrecedence = operators.getPrecedence(arg, parenthesis);
                            var assocWithArg = operators.isAssociativeWith(root, arg, parenthesis);
                            var argAssociativity = operators.getAssociativity(arg, parenthesis);
                            if (argPrecedence === null) {
                                return false;
                            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
                                return true;
                            } else if (argPrecedence < precedence) {
                                return true;
                            }
                            return false;
                        });
                    }
                    break;
                }
                if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis === "auto" && implicit === "hide") {
                    result = args.map(function(arg, index) {
                        var isParenthesisNode = arg.getIdentifier() === "ParenthesisNode";
                        if (result[index] || isParenthesisNode) {
                            return true;
                        }
                        return false;
                    });
                }
                return result;
            }
            OperatorNode.prototype._toString = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var implicit = options && options.implicit ? options.implicit : "hide";
                var args = this.args;
                var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
                if (args.length === 1) {
                    var assoc = operators.getAssociativity(this, parenthesis);
                    var operand = args[0].toString(options);
                    if (parens[0]) {
                        operand = "(" + operand + ")";
                    }
                    var opIsNamed = /[a-zA-Z]+/.test(this.op);
                    if (assoc === "right") {
                        return this.op + (opIsNamed ? " " : "") + operand;
                    } else if (assoc === "left") {
                        return operand + (opIsNamed ? " " : "") + this.op;
                    }
                    return operand + this.op;
                } else if (args.length === 2) {
                    var lhs = args[0].toString(options);
                    var rhs = args[1].toString(options);
                    if (parens[0]) {
                        lhs = "(" + lhs + ")";
                    }
                    if (parens[1]) {
                        rhs = "(" + rhs + ")";
                    }
                    if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                        return lhs + " " + rhs;
                    }
                    return lhs + " " + this.op + " " + rhs;
                } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
                    var stringifiedArgs = args.map(function(arg, index) {
                        arg = arg.toString(options);
                        if (parens[index]) {
                            arg = "(" + arg + ")";
                        }
                        return arg;
                    });
                    if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                        return stringifiedArgs.join(" ");
                    }
                    return stringifiedArgs.join(" " + this.op + " ");
                } else {
                    return this.fn + "(" + this.args.join(", ") + ")";
                }
            };
            OperatorNode.prototype.toJSON = function() {
                return {
                    mathjs: "OperatorNode",
                    op: this.op,
                    fn: this.fn,
                    args: this.args,
                    implicit: this.implicit
                };
            };
            OperatorNode.fromJSON = function(json) {
                return new OperatorNode(json.op, json.fn, json.args, json.implicit);
            };
            OperatorNode.prototype.toHTML = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var implicit = options && options.implicit ? options.implicit : "hide";
                var args = this.args;
                var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
                if (args.length === 1) {
                    var assoc = operators.getAssociativity(this, parenthesis);
                    var operand = args[0].toHTML(options);
                    if (parens[0]) {
                        operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                    }
                    if (assoc === "right") {
                        return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
                    } else {
                        return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape(this.op) + "</span>";
                    }
                } else if (args.length === 2) {
                    var lhs = args[0].toHTML(options);
                    var rhs = args[1].toHTML(options);
                    if (parens[0]) {
                        lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                    }
                    if (parens[1]) {
                        rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                    }
                    if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                        return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
                    }
                    return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
                } else {
                    var stringifiedArgs = args.map(function(arg, index) {
                        arg = arg.toHTML(options);
                        if (parens[index]) {
                            arg = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                        }
                        return arg;
                    });
                    if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
                        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
                            return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
                        }
                        return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>");
                    } else {
                        return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
                    }
                }
            };
            OperatorNode.prototype._toTex = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var implicit = options && options.implicit ? options.implicit : "hide";
                var args = this.args;
                var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
                var op = latex.operators[this.fn];
                op = typeof op === "undefined" ? this.op : op;
                if (args.length === 1) {
                    var assoc = operators.getAssociativity(this, parenthesis);
                    var operand = args[0].toTex(options);
                    if (parens[0]) {
                        operand = "\\left(".concat(operand, "\\right)");
                    }
                    if (assoc === "right") {
                        return op + operand;
                    } else if (assoc === "left") {
                        return operand + op;
                    }
                    return operand + op;
                } else if (args.length === 2) {
                    var lhs = args[0];
                    var lhsTex = lhs.toTex(options);
                    if (parens[0]) {
                        lhsTex = "\\left(".concat(lhsTex, "\\right)");
                    }
                    var rhs = args[1];
                    var rhsTex = rhs.toTex(options);
                    if (parens[1]) {
                        rhsTex = "\\left(".concat(rhsTex, "\\right)");
                    }
                    var lhsIdentifier;
                    if (parenthesis === "keep") {
                        lhsIdentifier = lhs.getIdentifier();
                    } else {
                        lhsIdentifier = lhs.getContent().getIdentifier();
                    }
                    switch (this.getIdentifier()) {
                      case "OperatorNode:divide":
                        return op + "{" + lhsTex + "}" + "{" + rhsTex + "}";

                      case "OperatorNode:pow":
                        lhsTex = "{" + lhsTex + "}";
                        rhsTex = "{" + rhsTex + "}";
                        switch (lhsIdentifier) {
                          case "ConditionalNode":
                          case "OperatorNode:divide":
                            lhsTex = "\\left(".concat(lhsTex, "\\right)");
                        }
                        break;

                      case "OperatorNode:multiply":
                        if (this.implicit && implicit === "hide") {
                            return lhsTex + "~" + rhsTex;
                        }
                    }
                    return lhsTex + op + rhsTex;
                } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
                    var texifiedArgs = args.map(function(arg, index) {
                        arg = arg.toTex(options);
                        if (parens[index]) {
                            arg = "\\left(".concat(arg, "\\right)");
                        }
                        return arg;
                    });
                    if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit) {
                        return texifiedArgs.join("~");
                    }
                    return texifiedArgs.join(op);
                } else {
                    return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg) {
                        return arg.toTex(options);
                    }).join(",") + "\\right)";
                }
            };
            OperatorNode.prototype.getIdentifier = function() {
                return this.type + ":" + this.fn;
            };
            return OperatorNode;
        }
        exports.name = "OperatorNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../../utils/array": 103,
        "../../utils/customs": 108,
        "../../utils/latex": 110,
        "../../utils/string": 114,
        "../operators": 90,
        "./Node": 81
    } ],
    84: [ function(require, module, exports) {
        "use strict";
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            function ParenthesisNode(content) {
                if (!(this instanceof ParenthesisNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                if (!type.isNode(content)) {
                    throw new TypeError('Node expected for parameter "content"');
                }
                this.content = content;
            }
            ParenthesisNode.prototype = new Node();
            ParenthesisNode.prototype.type = "ParenthesisNode";
            ParenthesisNode.prototype.isParenthesisNode = true;
            ParenthesisNode.prototype._compile = function(math, argNames) {
                return this.content._compile(math, argNames);
            };
            ParenthesisNode.prototype.getContent = function() {
                return this.content.getContent();
            };
            ParenthesisNode.prototype.forEach = function(callback) {
                callback(this.content, "content", this);
            };
            ParenthesisNode.prototype.map = function(callback) {
                var content = callback(this.content, "content", this);
                return new ParenthesisNode(content);
            };
            ParenthesisNode.prototype.clone = function() {
                return new ParenthesisNode(this.content);
            };
            ParenthesisNode.prototype._toString = function(options) {
                if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
                    return "(" + this.content.toString(options) + ")";
                }
                return this.content.toString(options);
            };
            ParenthesisNode.prototype.toJSON = function() {
                return {
                    mathjs: "ParenthesisNode",
                    content: this.content
                };
            };
            ParenthesisNode.fromJSON = function(json) {
                return new ParenthesisNode(json.content);
            };
            ParenthesisNode.prototype.toHTML = function(options) {
                if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
                    return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                return this.content.toHTML(options);
            };
            ParenthesisNode.prototype._toTex = function(options) {
                if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
                    return "\\left(".concat(this.content.toTex(options), "\\right)");
                }
                return this.content.toTex(options);
            };
            return ParenthesisNode;
        }
        exports.name = "ParenthesisNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "./Node": 81
    } ],
    85: [ function(require, module, exports) {
        "use strict";
        var operators = require("../operators");
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            function RangeNode(start, end, step) {
                if (!(this instanceof RangeNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                if (!type.isNode(start)) throw new TypeError("Node expected");
                if (!type.isNode(end)) throw new TypeError("Node expected");
                if (step && !type.isNode(step)) throw new TypeError("Node expected");
                if (arguments.length > 3) throw new Error("Too many arguments");
                this.start = start;
                this.end = end;
                this.step = step || null;
            }
            RangeNode.prototype = new Node();
            RangeNode.prototype.type = "RangeNode";
            RangeNode.prototype.isRangeNode = true;
            RangeNode.prototype.needsEnd = function() {
                var endSymbols = this.filter(function(node) {
                    return type.isSymbolNode(node) && node.name === "end";
                });
                return endSymbols.length > 0;
            };
            RangeNode.prototype._compile = function(math, argNames) {
                var range = math.range;
                var evalStart = this.start._compile(math, argNames);
                var evalEnd = this.end._compile(math, argNames);
                if (this.step) {
                    var evalStep = this.step._compile(math, argNames);
                    return function evalRangeNode(scope, args, context) {
                        return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
                    };
                } else {
                    return function evalRangeNode(scope, args, context) {
                        return range(evalStart(scope, args, context), evalEnd(scope, args, context));
                    };
                }
            };
            RangeNode.prototype.forEach = function(callback) {
                callback(this.start, "start", this);
                callback(this.end, "end", this);
                if (this.step) {
                    callback(this.step, "step", this);
                }
            };
            RangeNode.prototype.map = function(callback) {
                return new RangeNode(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
            };
            RangeNode.prototype.clone = function() {
                return new RangeNode(this.start, this.end, this.step && this.step);
            };
            function calculateNecessaryParentheses(node, parenthesis) {
                var precedence = operators.getPrecedence(node, parenthesis);
                var parens = {};
                var startPrecedence = operators.getPrecedence(node.start, parenthesis);
                parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
                if (node.step) {
                    var stepPrecedence = operators.getPrecedence(node.step, parenthesis);
                    parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
                }
                var endPrecedence = operators.getPrecedence(node.end, parenthesis);
                parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
                return parens;
            }
            RangeNode.prototype._toString = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var parens = calculateNecessaryParentheses(this, parenthesis);
                var str;
                var start = this.start.toString(options);
                if (parens.start) {
                    start = "(" + start + ")";
                }
                str = start;
                if (this.step) {
                    var step = this.step.toString(options);
                    if (parens.step) {
                        step = "(" + step + ")";
                    }
                    str += ":" + step;
                }
                var end = this.end.toString(options);
                if (parens.end) {
                    end = "(" + end + ")";
                }
                str += ":" + end;
                return str;
            };
            RangeNode.prototype.toJSON = function() {
                return {
                    mathjs: "RangeNode",
                    start: this.start,
                    end: this.end,
                    step: this.step
                };
            };
            RangeNode.fromJSON = function(json) {
                return new RangeNode(json.start, json.end, json.step);
            };
            RangeNode.prototype.toHTML = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var parens = calculateNecessaryParentheses(this, parenthesis);
                var str;
                var start = this.start.toHTML(options);
                if (parens.start) {
                    start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                str = start;
                if (this.step) {
                    var step = this.step.toHTML(options);
                    if (parens.step) {
                        step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                    }
                    str += '<span class="math-operator math-range-operator">:</span>' + step;
                }
                var end = this.end.toHTML(options);
                if (parens.end) {
                    end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
                }
                str += '<span class="math-operator math-range-operator">:</span>' + end;
                return str;
            };
            RangeNode.prototype._toTex = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var parens = calculateNecessaryParentheses(this, parenthesis);
                var str = this.start.toTex(options);
                if (parens.start) {
                    str = "\\left(".concat(str, "\\right)");
                }
                if (this.step) {
                    var step = this.step.toTex(options);
                    if (parens.step) {
                        step = "\\left(".concat(step, "\\right)");
                    }
                    str += ":" + step;
                }
                var end = this.end.toTex(options);
                if (parens.end) {
                    end = "\\left(".concat(end, "\\right)");
                }
                str += ":" + end;
                return str;
            };
            return RangeNode;
        }
        exports.name = "RangeNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../operators": 90,
        "./Node": 81
    } ],
    86: [ function(require, module, exports) {
        "use strict";
        var operators = require("../operators");
        var latex = require("../../utils/latex");
        var escape = require("../../utils/string").escape;
        function factory(type, config, load, typed) {
            var Node = load(require("./Node"));
            var getSafeProperty = require("../../utils/customs").getSafeProperty;
            function RelationalNode(conditionals, params) {
                if (!(this instanceof RelationalNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                if (!Array.isArray(conditionals)) throw new TypeError("Parameter conditionals must be an array");
                if (!Array.isArray(params)) throw new TypeError("Parameter params must be an array");
                if (conditionals.length !== params.length - 1) throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
                this.conditionals = conditionals;
                this.params = params;
            }
            RelationalNode.prototype = new Node();
            RelationalNode.prototype.type = "RelationalNode";
            RelationalNode.prototype.isRelationalNode = true;
            RelationalNode.prototype._compile = function(math, argNames) {
                var self = this;
                var compiled = this.params.map(function(p) {
                    return p._compile(math, argNames);
                });
                return function evalRelationalNode(scope, args, context) {
                    var evalLhs;
                    var evalRhs = compiled[0](scope, args, context);
                    for (var i = 0; i < self.conditionals.length; i++) {
                        evalLhs = evalRhs;
                        evalRhs = compiled[i + 1](scope, args, context);
                        var condFn = getSafeProperty(math, self.conditionals[i]);
                        if (!condFn(evalLhs, evalRhs)) {
                            return false;
                        }
                    }
                    return true;
                };
            };
            RelationalNode.prototype.forEach = function(callback) {
                var _this = this;
                this.params.forEach(function(n, i) {
                    return callback(n, "params[" + i + "]", _this);
                }, this);
            };
            RelationalNode.prototype.map = function(callback) {
                var _this2 = this;
                return new RelationalNode(this.conditionals.slice(), this.params.map(function(n, i) {
                    return _this2._ifNode(callback(n, "params[" + i + "]", _this2));
                }, this));
            };
            RelationalNode.prototype.clone = function() {
                return new RelationalNode(this.conditionals, this.params);
            };
            RelationalNode.prototype._toString = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var precedence = operators.getPrecedence(this, parenthesis);
                var paramStrings = this.params.map(function(p, index) {
                    var paramPrecedence = operators.getPrecedence(p, parenthesis);
                    return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options) + ")" : p.toString(options);
                });
                var operatorMap = {
                    equal: "==",
                    unequal: "!=",
                    smaller: "<",
                    larger: ">",
                    smallerEq: "<=",
                    largerEq: ">="
                };
                var ret = paramStrings[0];
                for (var i = 0; i < this.conditionals.length; i++) {
                    ret += " " + operatorMap[this.conditionals[i]] + " " + paramStrings[i + 1];
                }
                return ret;
            };
            RelationalNode.prototype.toJSON = function() {
                return {
                    mathjs: "RelationalNode",
                    conditionals: this.conditionals,
                    params: this.params
                };
            };
            RelationalNode.fromJSON = function(json) {
                return new RelationalNode(json.conditionals, json.params);
            };
            RelationalNode.prototype.toHTML = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var precedence = operators.getPrecedence(this, parenthesis);
                var paramStrings = this.params.map(function(p, index) {
                    var paramPrecedence = operators.getPrecedence(p, parenthesis);
                    return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
                });
                var operatorMap = {
                    equal: "==",
                    unequal: "!=",
                    smaller: "<",
                    larger: ">",
                    smallerEq: "<=",
                    largerEq: ">="
                };
                var ret = paramStrings[0];
                for (var i = 0; i < this.conditionals.length; i++) {
                    ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i]]) + "</span>" + paramStrings[i + 1];
                }
                return ret;
            };
            RelationalNode.prototype._toTex = function(options) {
                var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
                var precedence = operators.getPrecedence(this, parenthesis);
                var paramStrings = this.params.map(function(p, index) {
                    var paramPrecedence = operators.getPrecedence(p, parenthesis);
                    return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options) + "\right)" : p.toTex(options);
                });
                var ret = paramStrings[0];
                for (var i = 0; i < this.conditionals.length; i++) {
                    ret += latex.operators[this.conditionals[i]] + paramStrings[i + 1];
                }
                return ret;
            };
            return RelationalNode;
        }
        exports.name = "RelationalNode";
        exports.path = "expression.node";
        exports.factory = factory;
    }, {
        "../../utils/customs": 108,
        "../../utils/latex": 110,
        "../../utils/string": 114,
        "../operators": 90,
        "./Node": 81
    } ],
    87: [ function(require, module, exports) {
        "use strict";
        var latex = require("../../utils/latex");
        var escape = require("../../utils/string").escape;
        var hasOwnProperty = require("../../utils/object").hasOwnProperty;
        var getSafeProperty = require("../../utils/customs").getSafeProperty;
        function factory(type, config, load, typed, math) {
            var Node = load(require("./Node"));
            function isValuelessUnit(name) {
                return type.Unit ? type.Unit.isValuelessUnit(name) : false;
            }
            function SymbolNode(name) {
                if (!(this instanceof SymbolNode)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                if (typeof name !== "string") throw new TypeError('String expected for parameter "name"');
                this.name = name;
            }
            SymbolNode.prototype = new Node();
            SymbolNode.prototype.type = "SymbolNode";
            SymbolNode.prototype.isSymbolNode = true;
            SymbolNode.prototype._compile = function(math, argNames) {
                var name = this.name;
                if (hasOwnProperty(argNames, name)) {
                    return function(scope, args, context) {
                        return args[name];
                    };
                } else if (name in math) {
                    return function(scope, args, context) {
                        return name in scope ? getSafeProperty(scope, name) : getSafeProperty(math, name);
                    };
                } else {
                    var isUnit = isValuelessUnit(name);
                    return function(scope, args, context) {
                        return name in scope ? getSafeProperty(scope, name) : isUnit ? new type.Unit(null, name) : undef(name);
                    };
                }
            };
            SymbolNode.prototype.forEach = function(callback) {};
            SymbolNode.prototype.map = function(callback) {
                return this.clone();
            };
            function undef(name) {
                throw new Error("Undefined symbol " + name);
            }
            SymbolNode.prototype.clone = function() {
                return new SymbolNode(this.name);
            };
            SymbolNode.prototype._toString = function(options) {
                return this.name;
            };
            SymbolNode.prototype.toHTML = function(options) {
                var name = escape(this.name);
                if (name === "true" || name === "false") {
                    return '<span class="math-symbol math-boolean">' + name + "</span>";
                } else if (name === "i") {
                    return '<span class="math-symbol math-imaginary-symbol">' + name + "</span>";
                } else if (name === "Infinity") {
                    return '<span class="math-symbol math-infinity-symbol">' + name + "</span>";
                } else if (name === "NaN") {
                    return '<span class="math-symbol math-nan-symbol">' + name + "</span>";
                } else if (name === "null") {
                    return '<span class="math-symbol math-null-symbol">' + name + "</span>";
                } else if (name === "undefined") {
                    return '<span class="math-symbol math-undefined-symbol">' + name + "</span>";
                }
                return '<span class="math-symbol">' + name + "</span>";
            };
            SymbolNode.prototype.toJSON = function() {
                return {
                    mathjs: "SymbolNode",
                    name: this.name
                };
            };
            SymbolNode.fromJSON = function(json) {
                return new SymbolNode(json.name);
            };
            SymbolNode.prototype._toTex = function(options) {
                var isUnit = false;
                if (typeof math[this.name] === "undefined" && isValuelessUnit(this.name)) {
                    isUnit = true;
                }
                var symbol = latex.toSymbol(this.name, isUnit);
                if (symbol[0] === "\\") {
                    return symbol;
                }
                return " " + symbol;
            };
            return SymbolNode;
        }
        exports.name = "SymbolNode";
        exports.path = "expression.node";
        exports.math = true;
        exports.factory = factory;
    }, {
        "../../utils/customs": 108,
        "../../utils/latex": 110,
        "../../utils/object": 112,
        "../../utils/string": 114,
        "./Node": 81
    } ],
    88: [ function(require, module, exports) {
        "use strict";
        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }
        var errorTransform = require("../../transform/error.transform").transform;
        var getSafeProperty = require("../../../utils/customs").getSafeProperty;
        function factory(type, config, load, typed) {
            var subset = load(require("../../../function/matrix/subset"));
            return function access(object, index) {
                try {
                    if (Array.isArray(object)) {
                        return subset(object, index);
                    } else if (object && typeof object.subset === "function") {
                        return object.subset(index);
                    } else if (typeof object === "string") {
                        return subset(object, index);
                    } else if (_typeof(object) === "object") {
                        if (!index.isObjectProperty()) {
                            throw new TypeError("Cannot apply a numeric index as object property");
                        }
                        return getSafeProperty(object, index.getObjectProperty());
                    } else {
                        throw new TypeError("Cannot apply index: unsupported type of object");
                    }
                } catch (err) {
                    throw errorTransform(err);
                }
            };
        }
        exports.factory = factory;
    }, {
        "../../../function/matrix/subset": 93,
        "../../../utils/customs": 108,
        "../../transform/error.transform": 92
    } ],
    89: [ function(require, module, exports) {
        "use strict";
        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }
        var errorTransform = require("../../transform/error.transform").transform;
        var setSafeProperty = require("../../../utils/customs").setSafeProperty;
        function factory(type, config, load, typed) {
            var subset = load(require("../../../function/matrix/subset"));
            var matrix = load(require("../../../type/matrix/function/matrix"));
            return function assign(object, index, value) {
                try {
                    if (Array.isArray(object)) {
                        return matrix(object).subset(index, value).valueOf();
                    } else if (object && typeof object.subset === "function") {
                        return object.subset(index, value);
                    } else if (typeof object === "string") {
                        return subset(object, index, value);
                    } else if (_typeof(object) === "object") {
                        if (!index.isObjectProperty()) {
                            throw TypeError("Cannot apply a numeric index as object property");
                        }
                        setSafeProperty(object, index.getObjectProperty(), value);
                        return object;
                    } else {
                        throw new TypeError("Cannot apply index: unsupported type of object");
                    }
                } catch (err) {
                    throw errorTransform(err);
                }
            };
        }
        exports.factory = factory;
    }, {
        "../../../function/matrix/subset": 93,
        "../../../type/matrix/function/matrix": 99,
        "../../../utils/customs": 108,
        "../../transform/error.transform": 92
    } ],
    90: [ function(require, module, exports) {
        "use strict";
        var properties = [ {
            AssignmentNode: {},
            FunctionAssignmentNode: {}
        }, {
            ConditionalNode: {
                latexLeftParens: false,
                latexRightParens: false,
                latexParens: false
            }
        }, {
            "OperatorNode:or": {
                associativity: "left",
                associativeWith: []
            }
        }, {
            "OperatorNode:xor": {
                associativity: "left",
                associativeWith: []
            }
        }, {
            "OperatorNode:and": {
                associativity: "left",
                associativeWith: []
            }
        }, {
            "OperatorNode:bitOr": {
                associativity: "left",
                associativeWith: []
            }
        }, {
            "OperatorNode:bitXor": {
                associativity: "left",
                associativeWith: []
            }
        }, {
            "OperatorNode:bitAnd": {
                associativity: "left",
                associativeWith: []
            }
        }, {
            "OperatorNode:equal": {
                associativity: "left",
                associativeWith: []
            },
            "OperatorNode:unequal": {
                associativity: "left",
                associativeWith: []
            },
            "OperatorNode:smaller": {
                associativity: "left",
                associativeWith: []
            },
            "OperatorNode:larger": {
                associativity: "left",
                associativeWith: []
            },
            "OperatorNode:smallerEq": {
                associativity: "left",
                associativeWith: []
            },
            "OperatorNode:largerEq": {
                associativity: "left",
                associativeWith: []
            },
            RelationalNode: {
                associativity: "left",
                associativeWith: []
            }
        }, {
            "OperatorNode:leftShift": {
                associativity: "left",
                associativeWith: []
            },
            "OperatorNode:rightArithShift": {
                associativity: "left",
                associativeWith: []
            },
            "OperatorNode:rightLogShift": {
                associativity: "left",
                associativeWith: []
            }
        }, {
            "OperatorNode:to": {
                associativity: "left",
                associativeWith: []
            }
        }, {
            RangeNode: {}
        }, {
            "OperatorNode:add": {
                associativity: "left",
                associativeWith: [ "OperatorNode:add", "OperatorNode:subtract" ]
            },
            "OperatorNode:subtract": {
                associativity: "left",
                associativeWith: []
            }
        }, {
            "OperatorNode:multiply": {
                associativity: "left",
                associativeWith: [ "OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide" ]
            },
            "OperatorNode:divide": {
                associativity: "left",
                associativeWith: [],
                latexLeftParens: false,
                latexRightParens: false,
                latexParens: false
            },
            "OperatorNode:dotMultiply": {
                associativity: "left",
                associativeWith: [ "OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide" ]
            },
            "OperatorNode:dotDivide": {
                associativity: "left",
                associativeWith: []
            },
            "OperatorNode:mod": {
                associativity: "left",
                associativeWith: []
            }
        }, {
            "OperatorNode:unaryPlus": {
                associativity: "right"
            },
            "OperatorNode:unaryMinus": {
                associativity: "right"
            },
            "OperatorNode:bitNot": {
                associativity: "right"
            },
            "OperatorNode:not": {
                associativity: "right"
            }
        }, {
            "OperatorNode:pow": {
                associativity: "right",
                associativeWith: [],
                latexRightParens: false
            },
            "OperatorNode:dotPow": {
                associativity: "right",
                associativeWith: []
            }
        }, {
            "OperatorNode:factorial": {
                associativity: "left"
            }
        }, {
            "OperatorNode:transpose": {
                associativity: "left"
            }
        } ];
        function getPrecedence(_node, parenthesis) {
            var node = _node;
            if (parenthesis !== "keep") {
                node = _node.getContent();
            }
            var identifier = node.getIdentifier();
            for (var i = 0; i < properties.length; i++) {
                if (identifier in properties[i]) {
                    return i;
                }
            }
            return null;
        }
        function getAssociativity(_node, parenthesis) {
            var node = _node;
            if (parenthesis !== "keep") {
                node = _node.getContent();
            }
            var identifier = node.getIdentifier();
            var index = getPrecedence(node, parenthesis);
            if (index === null) {
                return null;
            }
            var property = properties[index][identifier];
            if (property.hasOwnProperty("associativity")) {
                if (property.associativity === "left") {
                    return "left";
                }
                if (property.associativity === "right") {
                    return "right";
                }
                throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
            }
            return null;
        }
        function isAssociativeWith(nodeA, nodeB, parenthesis) {
            var a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
            var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
            var identifierA = a.getIdentifier();
            var identifierB = b.getIdentifier();
            var index = getPrecedence(a, parenthesis);
            if (index === null) {
                return null;
            }
            var property = properties[index][identifierA];
            if (property.hasOwnProperty("associativeWith") && property.associativeWith instanceof Array) {
                for (var i = 0; i < property.associativeWith.length; i++) {
                    if (property.associativeWith[i] === identifierB) {
                        return true;
                    }
                }
                return false;
            }
            return null;
        }
        module.exports.properties = properties;
        module.exports.getPrecedence = getPrecedence;
        module.exports.getAssociativity = getAssociativity;
        module.exports.isAssociativeWith = isAssociativeWith;
    }, {} ],
    91: [ function(require, module, exports) {
        "use strict";
        function _extends() {
            _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }
                return target;
            };
            return _extends.apply(this, arguments);
        }
        var ArgumentsError = require("../error/ArgumentsError");
        var deepMap = require("../utils/collection/deepMap");
        function factory(type, config, load, typed) {
            var numeric = load(require("../type/numeric"));
            var AccessorNode = load(require("./node/AccessorNode"));
            var ArrayNode = load(require("./node/ArrayNode"));
            var AssignmentNode = load(require("./node/AssignmentNode"));
            var BlockNode = load(require("./node/BlockNode"));
            var ConditionalNode = load(require("./node/ConditionalNode"));
            var ConstantNode = load(require("./node/ConstantNode"));
            var FunctionAssignmentNode = load(require("./node/FunctionAssignmentNode"));
            var IndexNode = load(require("./node/IndexNode"));
            var ObjectNode = load(require("./node/ObjectNode"));
            var OperatorNode = load(require("./node/OperatorNode"));
            var ParenthesisNode = load(require("./node/ParenthesisNode"));
            var FunctionNode = load(require("./node/FunctionNode"));
            var RangeNode = load(require("./node/RangeNode"));
            var RelationalNode = load(require("./node/RelationalNode"));
            var SymbolNode = load(require("./node/SymbolNode"));
            function parse(expr, options) {
                if (arguments.length !== 1 && arguments.length !== 2) {
                    throw new ArgumentsError("parse", arguments.length, 1, 2);
                }
                var extraNodes = options && options.nodes ? options.nodes : {};
                if (typeof expr === "string") {
                    return parseStart(expr, extraNodes);
                } else if (Array.isArray(expr) || expr instanceof type.Matrix) {
                    return deepMap(expr, function(elem) {
                        if (typeof elem !== "string") throw new TypeError("String expected");
                        return parseStart(elem, extraNodes);
                    });
                } else {
                    throw new TypeError("String or matrix expected");
                }
            }
            var TOKENTYPE = {
                NULL: 0,
                DELIMITER: 1,
                NUMBER: 2,
                SYMBOL: 3,
                UNKNOWN: 4
            };
            var DELIMITERS = {
                ",": true,
                "(": true,
                ")": true,
                "[": true,
                "]": true,
                "{": true,
                "}": true,
                '"': true,
                "'": true,
                ";": true,
                "+": true,
                "-": true,
                "*": true,
                ".*": true,
                "/": true,
                "./": true,
                "%": true,
                "^": true,
                ".^": true,
                "~": true,
                "!": true,
                "&": true,
                "|": true,
                "^|": true,
                "=": true,
                ":": true,
                "?": true,
                "==": true,
                "!=": true,
                "<": true,
                ">": true,
                "<=": true,
                ">=": true,
                "<<": true,
                ">>": true,
                ">>>": true
            };
            var NAMED_DELIMITERS = {
                mod: true,
                to: true,
                in: true,
                and: true,
                xor: true,
                or: true,
                not: true
            };
            var CONSTANTS = {
                true: true,
                false: false,
                null: null,
                undefined: undefined
            };
            var NUMERIC_CONSTANTS = [ "NaN", "Infinity" ];
            function initialState() {
                return {
                    extraNodes: {},
                    expression: "",
                    comment: "",
                    index: 0,
                    token: "",
                    tokenType: TOKENTYPE.NULL,
                    nestingLevel: 0,
                    conditionalLevel: null
                };
            }
            function currentString(state, length) {
                return state.expression.substr(state.index, length);
            }
            function currentCharacter(state) {
                return currentString(state, 1);
            }
            function next(state) {
                state.index++;
            }
            function prevCharacter(state) {
                return state.expression.charAt(state.index - 1);
            }
            function nextCharacter(state) {
                return state.expression.charAt(state.index + 1);
            }
            function getToken(state) {
                state.tokenType = TOKENTYPE.NULL;
                state.token = "";
                state.comment = "";
                while (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {
                    next(state);
                }
                if (currentCharacter(state) === "#") {
                    while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
                        state.comment += currentCharacter(state);
                        next(state);
                    }
                }
                if (currentCharacter(state) === "") {
                    state.tokenType = TOKENTYPE.DELIMITER;
                    return;
                }
                if (currentCharacter(state) === "\n" && !state.nestingLevel) {
                    state.tokenType = TOKENTYPE.DELIMITER;
                    state.token = currentCharacter(state);
                    next(state);
                    return;
                }
                var c1 = currentCharacter(state);
                var c2 = currentString(state, 2);
                var c3 = currentString(state, 3);
                if (c3.length === 3 && DELIMITERS[c3]) {
                    state.tokenType = TOKENTYPE.DELIMITER;
                    state.token = c3;
                    next(state);
                    next(state);
                    next(state);
                    return;
                }
                if (c2.length === 2 && DELIMITERS[c2]) {
                    state.tokenType = TOKENTYPE.DELIMITER;
                    state.token = c2;
                    next(state);
                    next(state);
                    return;
                }
                if (DELIMITERS[c1]) {
                    state.tokenType = TOKENTYPE.DELIMITER;
                    state.token = c1;
                    next(state);
                    return;
                }
                if (parse.isDigitDot(c1)) {
                    state.tokenType = TOKENTYPE.NUMBER;
                    if (currentCharacter(state) === ".") {
                        state.token += currentCharacter(state);
                        next(state);
                        if (!parse.isDigit(currentCharacter(state))) {
                            state.tokenType = TOKENTYPE.DELIMITER;
                        }
                    } else {
                        while (parse.isDigit(currentCharacter(state))) {
                            state.token += currentCharacter(state);
                            next(state);
                        }
                        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
                            state.token += currentCharacter(state);
                            next(state);
                        }
                    }
                    while (parse.isDigit(currentCharacter(state))) {
                        state.token += currentCharacter(state);
                        next(state);
                    }
                    if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
                        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
                            state.token += currentCharacter(state);
                            next(state);
                            if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
                                state.token += currentCharacter(state);
                                next(state);
                            }
                            if (!parse.isDigit(currentCharacter(state))) {
                                throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
                            }
                            while (parse.isDigit(currentCharacter(state))) {
                                state.token += currentCharacter(state);
                                next(state);
                            }
                            if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
                                throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
                            }
                        } else if (nextCharacter(state) === ".") {
                            next(state);
                            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
                        }
                    }
                    return;
                }
                if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
                    while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {
                        state.token += currentCharacter(state);
                        next(state);
                    }
                    if (NAMED_DELIMITERS.hasOwnProperty(state.token)) {
                        state.tokenType = TOKENTYPE.DELIMITER;
                    } else {
                        state.tokenType = TOKENTYPE.SYMBOL;
                    }
                    return;
                }
                state.tokenType = TOKENTYPE.UNKNOWN;
                while (currentCharacter(state) !== "") {
                    state.token += currentCharacter(state);
                    next(state);
                }
                throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
            }
            function getTokenSkipNewline(state) {
                do {
                    getToken(state);
                } while (state.token === "\n");
            }
            function openParams(state) {
                state.nestingLevel++;
            }
            function closeParams(state) {
                state.nestingLevel--;
            }
            parse.isAlpha = function isAlpha(c, cPrev, cNext) {
                return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);
            };
            parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
                return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
            };
            parse.isValidMathSymbol = function isValidMathSymbol(high, low) {
                return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
            };
            parse.isWhitespace = function isWhitespace(c, nestingLevel) {
                return c === " " || c === "\t" || c === "\n" && nestingLevel > 0;
            };
            parse.isDecimalMark = function isDecimalMark(c, cNext) {
                return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
            };
            parse.isDigitDot = function isDigitDot(c) {
                return c >= "0" && c <= "9" || c === ".";
            };
            parse.isDigit = function isDigit(c) {
                return c >= "0" && c <= "9";
            };
            function parseStart(expression, extraNodes) {
                var state = initialState();
                _extends(state, {
                    expression: expression,
                    extraNodes: extraNodes
                });
                getToken(state);
                var node = parseBlock(state);
                if (state.token !== "") {
                    if (state.tokenType === TOKENTYPE.DELIMITER) {
                        throw createError(state, "Unexpected operator " + state.token);
                    } else {
                        throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
                    }
                }
                return node;
            }
            function parseBlock(state) {
                var node;
                var blocks = [];
                var visible;
                if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
                    node = parseAssignment(state);
                    node.comment = state.comment;
                }
                while (state.token === "\n" || state.token === ";") {
                    if (blocks.length === 0 && node) {
                        visible = state.token !== ";";
                        blocks.push({
                            node: node,
                            visible: visible
                        });
                    }
                    getToken(state);
                    if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
                        node = parseAssignment(state);
                        node.comment = state.comment;
                        visible = state.token !== ";";
                        blocks.push({
                            node: node,
                            visible: visible
                        });
                    }
                }
                if (blocks.length > 0) {
                    return new BlockNode(blocks);
                } else {
                    if (!node) {
                        node = new ConstantNode(undefined);
                        node.comment = state.comment;
                    }
                    return node;
                }
            }
            function parseAssignment(state) {
                var name, args, value, valid;
                var node = parseConditional(state);
                if (state.token === "=") {
                    if (type.isSymbolNode(node)) {
                        name = node.name;
                        getTokenSkipNewline(state);
                        value = parseAssignment(state);
                        return new AssignmentNode(new SymbolNode(name), value);
                    } else if (type.isAccessorNode(node)) {
                        getTokenSkipNewline(state);
                        value = parseAssignment(state);
                        return new AssignmentNode(node.object, node.index, value);
                    } else if (type.isFunctionNode(node) && type.isSymbolNode(node.fn)) {
                        valid = true;
                        args = [];
                        name = node.name;
                        node.args.forEach(function(arg, index) {
                            if (type.isSymbolNode(arg)) {
                                args[index] = arg.name;
                            } else {
                                valid = false;
                            }
                        });
                        if (valid) {
                            getTokenSkipNewline(state);
                            value = parseAssignment(state);
                            return new FunctionAssignmentNode(name, args, value);
                        }
                    }
                    throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
                }
                return node;
            }
            function parseConditional(state) {
                var node = parseLogicalOr(state);
                while (state.token === "?") {
                    var prev = state.conditionalLevel;
                    state.conditionalLevel = state.nestingLevel;
                    getTokenSkipNewline(state);
                    var condition = node;
                    var trueExpr = parseAssignment(state);
                    if (state.token !== ":") throw createSyntaxError(state, "False part of conditional expression expected");
                    state.conditionalLevel = null;
                    getTokenSkipNewline(state);
                    var falseExpr = parseAssignment(state);
                    node = new ConditionalNode(condition, trueExpr, falseExpr);
                    state.conditionalLevel = prev;
                }
                return node;
            }
            function parseLogicalOr(state) {
                var node = parseLogicalXor(state);
                while (state.token === "or") {
                    getTokenSkipNewline(state);
                    node = new OperatorNode("or", "or", [ node, parseLogicalXor(state) ]);
                }
                return node;
            }
            function parseLogicalXor(state) {
                var node = parseLogicalAnd(state);
                while (state.token === "xor") {
                    getTokenSkipNewline(state);
                    node = new OperatorNode("xor", "xor", [ node, parseLogicalAnd(state) ]);
                }
                return node;
            }
            function parseLogicalAnd(state) {
                var node = parseBitwiseOr(state);
                while (state.token === "and") {
                    getTokenSkipNewline(state);
                    node = new OperatorNode("and", "and", [ node, parseBitwiseOr(state) ]);
                }
                return node;
            }
            function parseBitwiseOr(state) {
                var node = parseBitwiseXor(state);
                while (state.token === "|") {
                    getTokenSkipNewline(state);
                    node = new OperatorNode("|", "bitOr", [ node, parseBitwiseXor(state) ]);
                }
                return node;
            }
            function parseBitwiseXor(state) {
                var node = parseBitwiseAnd(state);
                while (state.token === "^|") {
                    getTokenSkipNewline(state);
                    node = new OperatorNode("^|", "bitXor", [ node, parseBitwiseAnd(state) ]);
                }
                return node;
            }
            function parseBitwiseAnd(state) {
                var node = parseRelational(state);
                while (state.token === "&") {
                    getTokenSkipNewline(state);
                    node = new OperatorNode("&", "bitAnd", [ node, parseRelational(state) ]);
                }
                return node;
            }
            function parseRelational(state) {
                var params = [ parseShift(state) ];
                var conditionals = [];
                var operators = {
                    "==": "equal",
                    "!=": "unequal",
                    "<": "smaller",
                    ">": "larger",
                    "<=": "smallerEq",
                    ">=": "largerEq"
                };
                while (operators.hasOwnProperty(state.token)) {
                    var cond = {
                        name: state.token,
                        fn: operators[state.token]
                    };
                    conditionals.push(cond);
                    getTokenSkipNewline(state);
                    params.push(parseShift(state));
                }
                if (params.length === 1) {
                    return params[0];
                } else if (params.length === 2) {
                    return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);
                } else {
                    return new RelationalNode(conditionals.map(function(c) {
                        return c.fn;
                    }), params);
                }
            }
            function parseShift(state) {
                var node, operators, name, fn, params;
                node = parseConversion(state);
                operators = {
                    "<<": "leftShift",
                    ">>": "rightArithShift",
                    ">>>": "rightLogShift"
                };
                while (operators.hasOwnProperty(state.token)) {
                    name = state.token;
                    fn = operators[name];
                    getTokenSkipNewline(state);
                    params = [ node, parseConversion(state) ];
                    node = new OperatorNode(name, fn, params);
                }
                return node;
            }
            function parseConversion(state) {
                var node, operators, name, fn, params;
                node = parseRange(state);
                operators = {
                    to: "to",
                    in: "to"
                };
                while (operators.hasOwnProperty(state.token)) {
                    name = state.token;
                    fn = operators[name];
                    getTokenSkipNewline(state);
                    if (name === "in" && state.token === "") {
                        node = new OperatorNode("*", "multiply", [ node, new SymbolNode("in") ], true);
                    } else {
                        params = [ node, parseRange(state) ];
                        node = new OperatorNode(name, fn, params);
                    }
                }
                return node;
            }
            function parseRange(state) {
                var node;
                var params = [];
                if (state.token === ":") {
                    node = new ConstantNode(1);
                } else {
                    node = parseAddSubtract(state);
                }
                if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
                    params.push(node);
                    while (state.token === ":" && params.length < 3) {
                        getTokenSkipNewline(state);
                        if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
                            params.push(new SymbolNode("end"));
                        } else {
                            params.push(parseAddSubtract(state));
                        }
                    }
                    if (params.length === 3) {
                        node = new RangeNode(params[0], params[2], params[1]);
                    } else {
                        node = new RangeNode(params[0], params[1]);
                    }
                }
                return node;
            }
            function parseAddSubtract(state) {
                var node, operators, name, fn, params;
                node = parseMultiplyDivide(state);
                operators = {
                    "+": "add",
                    "-": "subtract"
                };
                while (operators.hasOwnProperty(state.token)) {
                    name = state.token;
                    fn = operators[name];
                    getTokenSkipNewline(state);
                    params = [ node, parseMultiplyDivide(state) ];
                    node = new OperatorNode(name, fn, params);
                }
                return node;
            }
            function parseMultiplyDivide(state) {
                var node, last, operators, name, fn;
                node = parseImplicitMultiplication(state);
                last = node;
                operators = {
                    "*": "multiply",
                    ".*": "dotMultiply",
                    "/": "divide",
                    "./": "dotDivide",
                    "%": "mod",
                    mod: "mod"
                };
                while (true) {
                    if (operators.hasOwnProperty(state.token)) {
                        name = state.token;
                        fn = operators[name];
                        getTokenSkipNewline(state);
                        last = parseImplicitMultiplication(state);
                        node = new OperatorNode(name, fn, [ node, last ]);
                    } else {
                        break;
                    }
                }
                return node;
            }
            function parseImplicitMultiplication(state) {
                var node, last;
                node = parseRule2(state);
                last = node;
                while (true) {
                    if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && type.isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !type.isConstantNode(last) && (!type.isOperatorNode(last) || last.op === "!") || state.token === "(") {
                        last = parseRule2(state);
                        node = new OperatorNode("*", "multiply", [ node, last ], true);
                    } else {
                        break;
                    }
                }
                return node;
            }
            function parseRule2(state) {
                var node = parseUnary(state);
                var last = node;
                var tokenStates = [];
                while (true) {
                    if (state.token === "/" && type.isConstantNode(last)) {
                        tokenStates.push(_extends({}, state));
                        getTokenSkipNewline(state);
                        if (state.tokenType === TOKENTYPE.NUMBER) {
                            tokenStates.push(_extends({}, state));
                            getTokenSkipNewline(state);
                            if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(") {
                                _extends(state, tokenStates.pop());
                                tokenStates.pop();
                                last = parseUnary(state);
                                node = new OperatorNode("/", "divide", [ node, last ]);
                            } else {
                                tokenStates.pop();
                                _extends(state, tokenStates.pop());
                                break;
                            }
                        } else {
                            _extends(state, tokenStates.pop());
                            break;
                        }
                    } else {
                        break;
                    }
                }
                return node;
            }
            function parseUnary(state) {
                var name, params, fn;
                var operators = {
                    "-": "unaryMinus",
                    "+": "unaryPlus",
                    "~": "bitNot",
                    not: "not"
                };
                if (operators.hasOwnProperty(state.token)) {
                    fn = operators[state.token];
                    name = state.token;
                    getTokenSkipNewline(state);
                    params = [ parseUnary(state) ];
                    return new OperatorNode(name, fn, params);
                }
                return parsePow(state);
            }
            function parsePow(state) {
                var node, name, fn, params;
                node = parseLeftHandOperators(state);
                if (state.token === "^" || state.token === ".^") {
                    name = state.token;
                    fn = name === "^" ? "pow" : "dotPow";
                    getTokenSkipNewline(state);
                    params = [ node, parseUnary(state) ];
                    node = new OperatorNode(name, fn, params);
                }
                return node;
            }
            function parseLeftHandOperators(state) {
                var node, operators, name, fn, params;
                node = parseCustomNodes(state);
                operators = {
                    "!": "factorial",
                    "'": "ctranspose"
                };
                while (operators.hasOwnProperty(state.token)) {
                    name = state.token;
                    fn = operators[name];
                    getToken(state);
                    params = [ node ];
                    node = new OperatorNode(name, fn, params);
                    node = parseAccessors(state, node);
                }
                return node;
            }
            function parseCustomNodes(state) {
                var params = [];
                if (state.tokenType === TOKENTYPE.SYMBOL && state.extraNodes.hasOwnProperty(state.token)) {
                    var CustomNode = state.extraNodes[state.token];
                    getToken(state);
                    if (state.token === "(") {
                        params = [];
                        openParams(state);
                        getToken(state);
                        if (state.token !== ")") {
                            params.push(parseAssignment(state));
                            while (state.token === ",") {
                                getToken(state);
                                params.push(parseAssignment(state));
                            }
                        }
                        if (state.token !== ")") {
                            throw createSyntaxError(state, "Parenthesis ) expected");
                        }
                        closeParams(state);
                        getToken(state);
                    }
                    return new CustomNode(params);
                }
                return parseSymbol(state);
            }
            function parseSymbol(state) {
                var node, name;
                if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
                    name = state.token;
                    getToken(state);
                    if (CONSTANTS.hasOwnProperty(name)) {
                        node = new ConstantNode(CONSTANTS[name]);
                    } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {
                        node = new ConstantNode(numeric(name, "number"));
                    } else {
                        node = new SymbolNode(name);
                    }
                    node = parseAccessors(state, node);
                    return node;
                }
                return parseDoubleQuotesString(state);
            }
            function parseAccessors(state, node, types) {
                var params;
                while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types || types.indexOf(state.token) !== -1)) {
                    params = [];
                    if (state.token === "(") {
                        if (type.isSymbolNode(node) || type.isAccessorNode(node)) {
                            openParams(state);
                            getToken(state);
                            if (state.token !== ")") {
                                params.push(parseAssignment(state));
                                while (state.token === ",") {
                                    getToken(state);
                                    params.push(parseAssignment(state));
                                }
                            }
                            if (state.token !== ")") {
                                throw createSyntaxError(state, "Parenthesis ) expected");
                            }
                            closeParams(state);
                            getToken(state);
                            node = new FunctionNode(node, params);
                        } else {
                            return node;
                        }
                    } else if (state.token === "[") {
                        openParams(state);
                        getToken(state);
                        if (state.token !== "]") {
                            params.push(parseAssignment(state));
                            while (state.token === ",") {
                                getToken(state);
                                params.push(parseAssignment(state));
                            }
                        }
                        if (state.token !== "]") {
                            throw createSyntaxError(state, "Parenthesis ] expected");
                        }
                        closeParams(state);
                        getToken(state);
                        node = new AccessorNode(node, new IndexNode(params));
                    } else {
                        getToken(state);
                        if (state.tokenType !== TOKENTYPE.SYMBOL) {
                            throw createSyntaxError(state, "Property name expected after dot");
                        }
                        params.push(new ConstantNode(state.token));
                        getToken(state);
                        var dotNotation = true;
                        node = new AccessorNode(node, new IndexNode(params, dotNotation));
                    }
                }
                return node;
            }
            function parseDoubleQuotesString(state) {
                var node, str;
                if (state.token === '"') {
                    str = parseDoubleQuotesStringToken(state);
                    node = new ConstantNode(str);
                    node = parseAccessors(state, node);
                    return node;
                }
                return parseSingleQuotesString(state);
            }
            function parseDoubleQuotesStringToken(state) {
                var str = "";
                while (currentCharacter(state) !== "" && currentCharacter(state) !== '"') {
                    if (currentCharacter(state) === "\\") {
                        str += currentCharacter(state);
                        next(state);
                    }
                    str += currentCharacter(state);
                    next(state);
                }
                getToken(state);
                if (state.token !== '"') {
                    throw createSyntaxError(state, 'End of string " expected');
                }
                getToken(state);
                return JSON.parse('"' + str + '"');
            }
            function parseSingleQuotesString(state) {
                var node, str;
                if (state.token === "'") {
                    str = parseSingleQuotesStringToken(state);
                    node = new ConstantNode(str);
                    node = parseAccessors(state, node);
                    return node;
                }
                return parseMatrix(state);
            }
            function parseSingleQuotesStringToken(state) {
                var str = "";
                while (currentCharacter(state) !== "" && currentCharacter(state) !== "'") {
                    if (currentCharacter(state) === "\\") {
                        str += currentCharacter(state);
                        next(state);
                    }
                    str += currentCharacter(state);
                    next(state);
                }
                getToken(state);
                if (state.token !== "'") {
                    throw createSyntaxError(state, "End of string ' expected");
                }
                getToken(state);
                return JSON.parse('"' + str + '"');
            }
            function parseMatrix(state) {
                var array, params, rows, cols;
                if (state.token === "[") {
                    openParams(state);
                    getToken(state);
                    if (state.token !== "]") {
                        var row = parseRow(state);
                        if (state.token === ";") {
                            rows = 1;
                            params = [ row ];
                            while (state.token === ";") {
                                getToken(state);
                                params[rows] = parseRow(state);
                                rows++;
                            }
                            if (state.token !== "]") {
                                throw createSyntaxError(state, "End of matrix ] expected");
                            }
                            closeParams(state);
                            getToken(state);
                            cols = params[0].items.length;
                            for (var r = 1; r < rows; r++) {
                                if (params[r].items.length !== cols) {
                                    throw createError(state, "Column dimensions mismatch " + "(" + params[r].items.length + " !== " + cols + ")");
                                }
                            }
                            array = new ArrayNode(params);
                        } else {
                            if (state.token !== "]") {
                                throw createSyntaxError(state, "End of matrix ] expected");
                            }
                            closeParams(state);
                            getToken(state);
                            array = row;
                        }
                    } else {
                        closeParams(state);
                        getToken(state);
                        array = new ArrayNode([]);
                    }
                    return parseAccessors(state, array);
                }
                return parseObject(state);
            }
            function parseRow(state) {
                var params = [ parseAssignment(state) ];
                var len = 1;
                while (state.token === ",") {
                    getToken(state);
                    params[len] = parseAssignment(state);
                    len++;
                }
                return new ArrayNode(params);
            }
            function parseObject(state) {
                if (state.token === "{") {
                    openParams(state);
                    var key;
                    var properties = {};
                    do {
                        getToken(state);
                        if (state.token !== "}") {
                            if (state.token === '"') {
                                key = parseDoubleQuotesStringToken(state);
                            } else if (state.token === "'") {
                                key = parseSingleQuotesStringToken(state);
                            } else if (state.tokenType === TOKENTYPE.SYMBOL) {
                                key = state.token;
                                getToken(state);
                            } else {
                                throw createSyntaxError(state, "Symbol or string expected as object key");
                            }
                            if (state.token !== ":") {
                                throw createSyntaxError(state, "Colon : expected after object key");
                            }
                            getToken(state);
                            properties[key] = parseAssignment(state);
                        }
                    } while (state.token === ",");
                    if (state.token !== "}") {
                        throw createSyntaxError(state, "Comma , or bracket } expected after object value");
                    }
                    closeParams(state);
                    getToken(state);
                    var node = new ObjectNode(properties);
                    node = parseAccessors(state, node);
                    return node;
                }
                return parseNumber(state);
            }
            function parseNumber(state) {
                var numberStr;
                if (state.tokenType === TOKENTYPE.NUMBER) {
                    numberStr = state.token;
                    getToken(state);
                    return new ConstantNode(numeric(numberStr, config.number));
                }
                return parseParentheses(state);
            }
            function parseParentheses(state) {
                var node;
                if (state.token === "(") {
                    openParams(state);
                    getToken(state);
                    node = parseAssignment(state);
                    if (state.token !== ")") {
                        throw createSyntaxError(state, "Parenthesis ) expected");
                    }
                    closeParams(state);
                    getToken(state);
                    node = new ParenthesisNode(node);
                    node = parseAccessors(state, node);
                    return node;
                }
                return parseEnd(state);
            }
            function parseEnd(state) {
                if (state.token === "") {
                    throw createSyntaxError(state, "Unexpected end of expression");
                } else {
                    throw createSyntaxError(state, "Value expected");
                }
            }
            function col(state) {
                return state.index - state.token.length + 1;
            }
            function createSyntaxError(state, message) {
                var c = col(state);
                var error = new SyntaxError(message + " (char " + c + ")");
                error["char"] = c;
                return error;
            }
            function createError(state, message) {
                var c = col(state);
                var error = new SyntaxError(message + " (char " + c + ")");
                error["char"] = c;
                return error;
            }
            return parse;
        }
        exports.name = "parse";
        exports.path = "expression";
        exports.factory = factory;
    }, {
        "../error/ArgumentsError": 65,
        "../type/numeric": 101,
        "../utils/collection/deepMap": 106,
        "./node/AccessorNode": 72,
        "./node/ArrayNode": 73,
        "./node/AssignmentNode": 74,
        "./node/BlockNode": 75,
        "./node/ConditionalNode": 76,
        "./node/ConstantNode": 77,
        "./node/FunctionAssignmentNode": 78,
        "./node/FunctionNode": 79,
        "./node/IndexNode": 80,
        "./node/ObjectNode": 82,
        "./node/OperatorNode": 83,
        "./node/ParenthesisNode": 84,
        "./node/RangeNode": 85,
        "./node/RelationalNode": 86,
        "./node/SymbolNode": 87
    } ],
    92: [ function(require, module, exports) {
        "use strict";
        var IndexError = require("../../error/IndexError");
        exports.transform = function(err) {
            if (err && err.isIndexError) {
                return new IndexError(err.index + 1, err.min + 1, err.max !== undefined ? err.max + 1 : undefined);
            }
            return err;
        };
    }, {
        "../../error/IndexError": 67
    } ],
    93: [ function(require, module, exports) {
        "use strict";
        var clone = require("../../utils/object").clone;
        var validateIndex = require("../../utils/array").validateIndex;
        var getSafeProperty = require("../../utils/customs").getSafeProperty;
        var setSafeProperty = require("../../utils/customs").setSafeProperty;
        var DimensionError = require("../../error/DimensionError");
        function factory(type, config, load, typed) {
            var matrix = load(require("../../type/matrix/function/matrix"));
            var subset = typed("subset", {
                "Array, Index": function ArrayIndex(value, index) {
                    var m = matrix(value);
                    var subset = m.subset(index);
                    return index.isScalar() ? subset : subset.valueOf();
                },
                "Matrix, Index": function MatrixIndex(value, index) {
                    return value.subset(index);
                },
                "Object, Index": _getObjectProperty,
                "string, Index": _getSubstring,
                "Array, Index, any": function ArrayIndexAny(value, index, replacement) {
                    return matrix(clone(value)).subset(index, replacement, undefined).valueOf();
                },
                "Array, Index, any, any": function ArrayIndexAnyAny(value, index, replacement, defaultValue) {
                    return matrix(clone(value)).subset(index, replacement, defaultValue).valueOf();
                },
                "Matrix, Index, any": function MatrixIndexAny(value, index, replacement) {
                    return value.clone().subset(index, replacement);
                },
                "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index, replacement, defaultValue) {
                    return value.clone().subset(index, replacement, defaultValue);
                },
                "string, Index, string": _setSubstring,
                "string, Index, string, string": _setSubstring,
                "Object, Index, any": _setObjectProperty
            });
            subset.toTex = undefined;
            return subset;
            function _getSubstring(str, index) {
                if (!type.isIndex(index)) {
                    throw new TypeError("Index expected");
                }
                if (index.size().length !== 1) {
                    throw new DimensionError(index.size().length, 1);
                }
                var strLen = str.length;
                validateIndex(index.min()[0], strLen);
                validateIndex(index.max()[0], strLen);
                var range = index.dimension(0);
                var substr = "";
                range.forEach(function(v) {
                    substr += str.charAt(v);
                });
                return substr;
            }
            function _setSubstring(str, index, replacement, defaultValue) {
                if (!index || index.isIndex !== true) {
                    throw new TypeError("Index expected");
                }
                if (index.size().length !== 1) {
                    throw new DimensionError(index.size().length, 1);
                }
                if (defaultValue !== undefined) {
                    if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
                        throw new TypeError("Single character expected as defaultValue");
                    }
                } else {
                    defaultValue = " ";
                }
                var range = index.dimension(0);
                var len = range.size()[0];
                if (len !== replacement.length) {
                    throw new DimensionError(range.size()[0], replacement.length);
                }
                var strLen = str.length;
                validateIndex(index.min()[0]);
                validateIndex(index.max()[0]);
                var chars = [];
                for (var i = 0; i < strLen; i++) {
                    chars[i] = str.charAt(i);
                }
                range.forEach(function(v, i) {
                    chars[v] = replacement.charAt(i[0]);
                });
                if (chars.length > strLen) {
                    for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
                        if (!chars[_i]) {
                            chars[_i] = defaultValue;
                        }
                    }
                }
                return chars.join("");
            }
        }
        function _getObjectProperty(object, index) {
            if (index.size().length !== 1) {
                throw new DimensionError(index.size(), 1);
            }
            var key = index.dimension(0);
            if (typeof key !== "string") {
                throw new TypeError("String expected as index to retrieve an object property");
            }
            return getSafeProperty(object, key);
        }
        function _setObjectProperty(object, index, replacement) {
            if (index.size().length !== 1) {
                throw new DimensionError(index.size(), 1);
            }
            var key = index.dimension(0);
            if (typeof key !== "string") {
                throw new TypeError("String expected as index to retrieve an object property");
            }
            var updated = clone(object);
            setSafeProperty(updated, key, replacement);
            return updated;
        }
        exports.name = "subset";
        exports.factory = factory;
    }, {
        "../../error/DimensionError": 66,
        "../../type/matrix/function/matrix": 99,
        "../../utils/array": 103,
        "../../utils/customs": 108,
        "../../utils/object": 112
    } ],
    94: [ function(require, module, exports) {
        "use strict";
        var string = require("../../utils/string");
        function factory(type, config, load, typed) {
            var format = typed("format", {
                any: string.format,
                "any, Object | function | number": string.format
            });
            format.toTex = undefined;
            return format;
        }
        exports.name = "format";
        exports.factory = factory;
    }, {
        "../../utils/string": 114
    } ],
    95: [ function(require, module, exports) {
        "use strict";
        function _typeof2(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof2 = function _typeof2(obj) {
                    return typeof obj;
                };
            } else {
                _typeof2 = function _typeof2(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof2(obj);
        }
        function factory(type, config, load, typed) {
            var _typeof = typed("_typeof", {
                any: function any(x) {
                    var t = _typeof2(x);
                    if (t === "object") {
                        if (x === null) return "null";
                        if (Array.isArray(x)) return "Array";
                        if (x instanceof Date) return "Date";
                        if (x instanceof RegExp) return "RegExp";
                        if (type.isBigNumber(x)) return "BigNumber";
                        if (type.isComplex(x)) return "Complex";
                        if (type.isFraction(x)) return "Fraction";
                        if (type.isMatrix(x)) return "Matrix";
                        if (type.isUnit(x)) return "Unit";
                        if (type.isIndex(x)) return "Index";
                        if (type.isRange(x)) return "Range";
                        if (type.isResultSet(x)) return "ResultSet";
                        if (type.isNode(x)) return x.type;
                        if (type.isChain(x)) return "Chain";
                        if (type.isHelp(x)) return "Help";
                        return "Object";
                    }
                    if (t === "function") return "Function";
                    return t;
                }
            });
            _typeof.toTex = undefined;
            return _typeof;
        }
        exports.name = "typeof";
        exports.factory = factory;
    }, {} ],
    96: [ function(require, module, exports) {
        "use strict";
        var deepMap = require("../../../utils/collection/deepMap");
        function factory(type, config, load, typed) {
            var bignumber = typed("bignumber", {
                "": function _() {
                    return new type.BigNumber(0);
                },
                number: function number(x) {
                    return new type.BigNumber(x + "");
                },
                string: function string(x) {
                    return new type.BigNumber(x);
                },
                BigNumber: function BigNumber(x) {
                    return x;
                },
                Fraction: function Fraction(x) {
                    return new type.BigNumber(x.n).div(x.d).times(x.s);
                },
                null: function _null(x) {
                    return new type.BigNumber(0);
                },
                "Array | Matrix": function ArrayMatrix(x) {
                    return deepMap(x, bignumber);
                }
            });
            bignumber.toTex = {
                0: "0",
                1: "\\left(${args[0]}\\right)"
            };
            return bignumber;
        }
        exports.name = "bignumber";
        exports.factory = factory;
    }, {
        "../../../utils/collection/deepMap": 106
    } ],
    97: [ function(require, module, exports) {
        "use strict";
        var deepMap = require("../../../utils/collection/deepMap");
        function factory(type, config, load, typed) {
            var fraction = typed("fraction", {
                number: function number(x) {
                    if (!isFinite(x) || isNaN(x)) {
                        throw new Error(x + " cannot be represented as a fraction");
                    }
                    return new type.Fraction(x);
                },
                string: function string(x) {
                    return new type.Fraction(x);
                },
                "number, number": function numberNumber(numerator, denominator) {
                    return new type.Fraction(numerator, denominator);
                },
                null: function _null(x) {
                    return new type.Fraction(0);
                },
                BigNumber: function BigNumber(x) {
                    return new type.Fraction(x.toString());
                },
                Fraction: function Fraction(x) {
                    return x;
                },
                Object: function Object(x) {
                    return new type.Fraction(x);
                },
                "Array | Matrix": function ArrayMatrix(x) {
                    return deepMap(x, fraction);
                }
            });
            return fraction;
        }
        exports.name = "fraction";
        exports.factory = factory;
    }, {
        "../../../utils/collection/deepMap": 106
    } ],
    98: [ function(require, module, exports) {
        "use strict";
        var number = require("../../utils/number");
        function factory(type, config, load, typed) {
            function Range(start, end, step) {
                if (!(this instanceof Range)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                var hasStart = start !== null && start !== undefined;
                var hasEnd = end !== null && end !== undefined;
                var hasStep = step !== null && step !== undefined;
                if (hasStart) {
                    if (type.isBigNumber(start)) {
                        start = start.toNumber();
                    } else if (typeof start !== "number") {
                        throw new TypeError("Parameter start must be a number");
                    }
                }
                if (hasEnd) {
                    if (type.isBigNumber(end)) {
                        end = end.toNumber();
                    } else if (typeof end !== "number") {
                        throw new TypeError("Parameter end must be a number");
                    }
                }
                if (hasStep) {
                    if (type.isBigNumber(step)) {
                        step = step.toNumber();
                    } else if (typeof step !== "number") {
                        throw new TypeError("Parameter step must be a number");
                    }
                }
                this.start = hasStart ? parseFloat(start) : 0;
                this.end = hasEnd ? parseFloat(end) : 0;
                this.step = hasStep ? parseFloat(step) : 1;
            }
            Range.prototype.type = "Range";
            Range.prototype.isRange = true;
            Range.parse = function(str) {
                if (typeof str !== "string") {
                    return null;
                }
                var args = str.split(":");
                var nums = args.map(function(arg) {
                    return parseFloat(arg);
                });
                var invalid = nums.some(function(num) {
                    return isNaN(num);
                });
                if (invalid) {
                    return null;
                }
                switch (nums.length) {
                  case 2:
                    return new Range(nums[0], nums[1]);

                  case 3:
                    return new Range(nums[0], nums[2], nums[1]);

                  default:
                    return null;
                }
            };
            Range.prototype.clone = function() {
                return new Range(this.start, this.end, this.step);
            };
            Range.prototype.size = function() {
                var len = 0;
                var start = this.start;
                var step = this.step;
                var end = this.end;
                var diff = end - start;
                if (number.sign(step) === number.sign(diff)) {
                    len = Math.ceil(diff / step);
                } else if (diff === 0) {
                    len = 0;
                }
                if (isNaN(len)) {
                    len = 0;
                }
                return [ len ];
            };
            Range.prototype.min = function() {
                var size = this.size()[0];
                if (size > 0) {
                    if (this.step > 0) {
                        return this.start;
                    } else {
                        return this.start + (size - 1) * this.step;
                    }
                } else {
                    return undefined;
                }
            };
            Range.prototype.max = function() {
                var size = this.size()[0];
                if (size > 0) {
                    if (this.step > 0) {
                        return this.start + (size - 1) * this.step;
                    } else {
                        return this.start;
                    }
                } else {
                    return undefined;
                }
            };
            Range.prototype.forEach = function(callback) {
                var x = this.start;
                var step = this.step;
                var end = this.end;
                var i = 0;
                if (step > 0) {
                    while (x < end) {
                        callback(x, [ i ], this);
                        x += step;
                        i++;
                    }
                } else if (step < 0) {
                    while (x > end) {
                        callback(x, [ i ], this);
                        x += step;
                        i++;
                    }
                }
            };
            Range.prototype.map = function(callback) {
                var array = [];
                this.forEach(function(value, index, obj) {
                    array[index[0]] = callback(value, index, obj);
                });
                return array;
            };
            Range.prototype.toArray = function() {
                var array = [];
                this.forEach(function(value, index) {
                    array[index[0]] = value;
                });
                return array;
            };
            Range.prototype.valueOf = function() {
                return this.toArray();
            };
            Range.prototype.format = function(options) {
                var str = number.format(this.start, options);
                if (this.step !== 1) {
                    str += ":" + number.format(this.step, options);
                }
                str += ":" + number.format(this.end, options);
                return str;
            };
            Range.prototype.toString = function() {
                return this.format();
            };
            Range.prototype.toJSON = function() {
                return {
                    mathjs: "Range",
                    start: this.start,
                    end: this.end,
                    step: this.step
                };
            };
            Range.fromJSON = function(json) {
                return new Range(json.start, json.end, json.step);
            };
            return Range;
        }
        exports.name = "Range";
        exports.path = "type";
        exports.factory = factory;
    }, {
        "../../utils/number": 111
    } ],
    99: [ function(require, module, exports) {
        "use strict";
        function factory(type, config, load, typed) {
            var matrix = typed("matrix", {
                "": function _() {
                    return _create([]);
                },
                string: function string(format) {
                    return _create([], format);
                },
                "string, string": function stringString(format, datatype) {
                    return _create([], format, datatype);
                },
                Array: function Array(data) {
                    return _create(data);
                },
                Matrix: function Matrix(data) {
                    return _create(data, data.storage());
                },
                "Array | Matrix, string": _create,
                "Array | Matrix, string, string": _create
            });
            matrix.toTex = {
                0: "\\begin{bmatrix}\\end{bmatrix}",
                1: "\\left(${args[0]}\\right)",
                2: "\\left(${args[0]}\\right)"
            };
            return matrix;
            function _create(data, format, datatype) {
                var M = type.Matrix.storage(format || "default");
                return new M(data, datatype);
            }
        }
        exports.name = "matrix";
        exports.factory = factory;
    }, {} ],
    100: [ function(require, module, exports) {
        "use strict";
        var deepMap = require("./../utils/collection/deepMap");
        function factory(type, config, load, typed) {
            var number = typed("number", {
                "": function _() {
                    return 0;
                },
                number: function number(x) {
                    return x;
                },
                string: function string(x) {
                    if (x === "NaN") return NaN;
                    var num = Number(x);
                    if (isNaN(num)) {
                        throw new SyntaxError('String "' + x + '" is no valid number');
                    }
                    return num;
                },
                BigNumber: function BigNumber(x) {
                    return x.toNumber();
                },
                Fraction: function Fraction(x) {
                    return x.valueOf();
                },
                Unit: function Unit(x) {
                    throw new Error("Second argument with valueless unit expected");
                },
                null: function _null(x) {
                    return 0;
                },
                "Unit, string | Unit": function UnitStringUnit(unit, valuelessUnit) {
                    return unit.toNumber(valuelessUnit);
                },
                "Array | Matrix": function ArrayMatrix(x) {
                    return deepMap(x, number);
                }
            });
            number.toTex = {
                0: "0",
                1: "\\left(${args[0]}\\right)",
                2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
            };
            return number;
        }
        exports.name = "number";
        exports.factory = factory;
    }, {
        "./../utils/collection/deepMap": 106
    } ],
    101: [ function(require, module, exports) {
        "use strict";
        function factory(type, config, load, typed) {
            var getTypeOf = load(require("../function/utils/typeof"));
            var validInputTypes = {
                string: true,
                number: true,
                BigNumber: true,
                Fraction: true
            };
            var validOutputTypes = {
                number: load(require("./number")),
                BigNumber: load(require("./bignumber/function/bignumber")),
                Fraction: load(require("./fraction/function/fraction"))
            };
            var numeric = function numeric(value, outputType) {
                var inputType = getTypeOf(value);
                if (!(inputType in validInputTypes)) {
                    throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
                }
                if (!(outputType in validOutputTypes)) {
                    throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
                }
                if (outputType === inputType) {
                    return value;
                } else {
                    return validOutputTypes[outputType](value);
                }
            };
            numeric.toTex = function(node, options) {
                return node.args[0].toTex();
            };
            return numeric;
        }
        exports.path = "type";
        exports.name = "_numeric";
        exports.factory = factory;
    }, {
        "../function/utils/typeof": 95,
        "./bignumber/function/bignumber": 96,
        "./fraction/function/fraction": 97,
        "./number": 100
    } ],
    102: [ function(require, module, exports) {
        "use strict";
        function factory(type, config, load, typed) {
            function ResultSet(entries) {
                if (!(this instanceof ResultSet)) {
                    throw new SyntaxError("Constructor must be called with the new operator");
                }
                this.entries = entries || [];
            }
            ResultSet.prototype.type = "ResultSet";
            ResultSet.prototype.isResultSet = true;
            ResultSet.prototype.valueOf = function() {
                return this.entries;
            };
            ResultSet.prototype.toString = function() {
                return "[" + this.entries.join(", ") + "]";
            };
            ResultSet.prototype.toJSON = function() {
                return {
                    mathjs: "ResultSet",
                    entries: this.entries
                };
            };
            ResultSet.fromJSON = function(json) {
                return new ResultSet(json.entries);
            };
            return ResultSet;
        }
        exports.name = "ResultSet";
        exports.path = "type";
        exports.factory = factory;
    }, {} ],
    103: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.size = size;
        exports.validate = validate;
        exports.validateIndex = validateIndex;
        exports.resize = resize;
        exports.reshape = reshape;
        exports.squeeze = squeeze;
        exports.unsqueeze = unsqueeze;
        exports.flatten = flatten;
        exports.map = map;
        exports.forEach = forEach;
        exports.filter = filter;
        exports.filterRegExp = filterRegExp;
        exports.join = join;
        exports.identify = identify;
        exports.generalize = generalize;
        var _number = _interopRequireDefault(require("./number"));
        var _string = _interopRequireDefault(require("./string"));
        var _DimensionError = _interopRequireDefault(require("../error/DimensionError"));
        var _IndexError = _interopRequireDefault(require("../error/IndexError"));
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function size(x) {
            var s = [];
            while (Array.isArray(x)) {
                s.push(x.length);
                x = x[0];
            }
            return s;
        }
        function _validate(array, size, dim) {
            var i;
            var len = array.length;
            if (len !== size[dim]) {
                throw new _DimensionError["default"](len, size[dim]);
            }
            if (dim < size.length - 1) {
                var dimNext = dim + 1;
                for (i = 0; i < len; i++) {
                    var child = array[i];
                    if (!Array.isArray(child)) {
                        throw new _DimensionError["default"](size.length - 1, size.length, "<");
                    }
                    _validate(array[i], size, dimNext);
                }
            } else {
                for (i = 0; i < len; i++) {
                    if (Array.isArray(array[i])) {
                        throw new _DimensionError["default"](size.length + 1, size.length, ">");
                    }
                }
            }
        }
        function validate(array, size) {
            var isScalar = size.length === 0;
            if (isScalar) {
                if (Array.isArray(array)) {
                    throw new _DimensionError["default"](array.length, 0);
                }
            } else {
                _validate(array, size, 0);
            }
        }
        function validateIndex(index, length) {
            if (!_number["default"].isNumber(index) || !_number["default"].isInteger(index)) {
                throw new TypeError("Index must be an integer (value: " + index + ")");
            }
            if (index < 0 || typeof length === "number" && index >= length) {
                throw new _IndexError["default"](index, length);
            }
        }
        function resize(array, size, defaultValue) {
            if (!Array.isArray(array) || !Array.isArray(size)) {
                throw new TypeError("Array expected");
            }
            if (size.length === 0) {
                throw new Error("Resizing to scalar is not supported");
            }
            size.forEach(function(value) {
                if (!_number["default"].isNumber(value) || !_number["default"].isInteger(value) || value < 0) {
                    throw new TypeError("Invalid size, must contain positive integers " + "(size: " + _string["default"].format(size) + ")");
                }
            });
            var _defaultValue = defaultValue !== undefined ? defaultValue : 0;
            _resize(array, size, 0, _defaultValue);
            return array;
        }
        function _resize(array, size, dim, defaultValue) {
            var i;
            var elem;
            var oldLen = array.length;
            var newLen = size[dim];
            var minLen = Math.min(oldLen, newLen);
            array.length = newLen;
            if (dim < size.length - 1) {
                var dimNext = dim + 1;
                for (i = 0; i < minLen; i++) {
                    elem = array[i];
                    if (!Array.isArray(elem)) {
                        elem = [ elem ];
                        array[i] = elem;
                    }
                    _resize(elem, size, dimNext, defaultValue);
                }
                for (i = minLen; i < newLen; i++) {
                    elem = [];
                    array[i] = elem;
                    _resize(elem, size, dimNext, defaultValue);
                }
            } else {
                for (i = 0; i < minLen; i++) {
                    while (Array.isArray(array[i])) {
                        array[i] = array[i][0];
                    }
                }
                for (i = minLen; i < newLen; i++) {
                    array[i] = defaultValue;
                }
            }
        }
        function reshape(array, sizes) {
            var flatArray = flatten(array);
            var newArray;
            function product(arr) {
                return arr.reduce(function(prev, curr) {
                    return prev * curr;
                });
            }
            if (!Array.isArray(array) || !Array.isArray(sizes)) {
                throw new TypeError("Array expected");
            }
            if (sizes.length === 0) {
                throw new _DimensionError["default"](0, product(size(array)), "!=");
            }
            var totalSize = 1;
            for (var sizeIndex = 0; sizeIndex < sizes.length; sizeIndex++) {
                totalSize *= sizes[sizeIndex];
            }
            if (flatArray.length !== totalSize) {
                throw new _DimensionError["default"](product(sizes), product(size(array)), "!=");
            }
            try {
                newArray = _reshape(flatArray, sizes);
            } catch (e) {
                if (e instanceof _DimensionError["default"]) {
                    throw new _DimensionError["default"](product(sizes), product(size(array)), "!=");
                }
                throw e;
            }
            return newArray;
        }
        function _reshape(array, sizes) {
            var tmpArray = array;
            var tmpArray2;
            for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
                var size = sizes[sizeIndex];
                tmpArray2 = [];
                var length = tmpArray.length / size;
                for (var i = 0; i < length; i++) {
                    tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
                }
                tmpArray = tmpArray2;
            }
            return tmpArray;
        }
        function squeeze(array, arraySize) {
            var s = arraySize || size(array);
            while (Array.isArray(array) && array.length === 1) {
                array = array[0];
                s.shift();
            }
            var dims = s.length;
            while (s[dims - 1] === 1) {
                dims--;
            }
            if (dims < s.length) {
                array = _squeeze(array, dims, 0);
                s.length = dims;
            }
            return array;
        }
        function _squeeze(array, dims, dim) {
            var i, ii;
            if (dim < dims) {
                var next = dim + 1;
                for (i = 0, ii = array.length; i < ii; i++) {
                    array[i] = _squeeze(array[i], dims, next);
                }
            } else {
                while (Array.isArray(array)) {
                    array = array[0];
                }
            }
            return array;
        }
        function unsqueeze(array, dims, outer, arraySize) {
            var s = arraySize || size(array);
            if (outer) {
                for (var i = 0; i < outer; i++) {
                    array = [ array ];
                    s.unshift(1);
                }
            }
            array = _unsqueeze(array, dims, 0);
            while (s.length < dims) {
                s.push(1);
            }
            return array;
        }
        function _unsqueeze(array, dims, dim) {
            var i, ii;
            if (Array.isArray(array)) {
                var next = dim + 1;
                for (i = 0, ii = array.length; i < ii; i++) {
                    array[i] = _unsqueeze(array[i], dims, next);
                }
            } else {
                for (var d = dim; d < dims; d++) {
                    array = [ array ];
                }
            }
            return array;
        }
        function flatten(array) {
            if (!Array.isArray(array)) {
                return array;
            }
            var flat = [];
            array.forEach(function callback(value) {
                if (Array.isArray(value)) {
                    value.forEach(callback);
                } else {
                    flat.push(value);
                }
            });
            return flat;
        }
        function map(array, callback) {
            return Array.prototype.map.call(array, callback);
        }
        function forEach(array, callback) {
            Array.prototype.forEach.call(array, callback);
        }
        function filter(array, callback) {
            if (size(array).length !== 1) {
                throw new Error("Only one dimensional matrices supported");
            }
            return Array.prototype.filter.call(array, callback);
        }
        function filterRegExp(array, regexp) {
            if (size(array).length !== 1) {
                throw new Error("Only one dimensional matrices supported");
            }
            return Array.prototype.filter.call(array, function(entry) {
                return regexp.test(entry);
            });
        }
        function join(array, separator) {
            return Array.prototype.join.call(array, separator);
        }
        function identify(a) {
            if (!Array.isArray(a)) {
                throw new TypeError("Array input expected");
            }
            if (a.length === 0) {
                return a;
            }
            var b = [];
            var count = 0;
            b[0] = {
                value: a[0],
                identifier: 0
            };
            for (var i = 1; i < a.length; i++) {
                if (a[i] === a[i - 1]) {
                    count++;
                } else {
                    count = 0;
                }
                b.push({
                    value: a[i],
                    identifier: count
                });
            }
            return b;
        }
        function generalize(a) {
            if (!Array.isArray(a)) {
                throw new TypeError("Array input expected");
            }
            if (a.length === 0) {
                return a;
            }
            var b = [];
            for (var i = 0; i < a.length; i++) {
                b.push(a[i].value);
            }
            return b;
        }
    }, {
        "../error/DimensionError": 66,
        "../error/IndexError": 67,
        "./number": 111,
        "./string": 114
    } ],
    104: [ function(require, module, exports) {
        "use strict";
        var objectUtils = require("../object");
        exports.format = function(value, options) {
            if (typeof options === "function") {
                return options(value);
            }
            if (!value.isFinite()) {
                return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
            }
            var notation = "auto";
            var precision;
            if (options !== undefined) {
                if (options.notation) {
                    notation = options.notation;
                }
                if (typeof options === "number") {
                    precision = options;
                } else if (options.precision) {
                    precision = options.precision;
                }
            }
            switch (notation) {
              case "fixed":
                return exports.toFixed(value, precision);

              case "exponential":
                return exports.toExponential(value, precision);

              case "engineering":
                return exports.toEngineering(value, precision);

              case "auto":
                if (options && options.exponential && (options.exponential.lower !== undefined || options.exponential.upper !== undefined)) {
                    var fixedOptions = objectUtils.map(options, function(x) {
                        return x;
                    });
                    fixedOptions.exponential = undefined;
                    if (options.exponential.lower !== undefined) {
                        fixedOptions.lowerExp = Math.round(Math.log(options.exponential.lower) / Math.LN10);
                    }
                    if (options.exponential.upper !== undefined) {
                        fixedOptions.upperExp = Math.round(Math.log(options.exponential.upper) / Math.LN10);
                    }
                    console.warn("Deprecation warning: Formatting options exponential.lower and exponential.upper " + "(minimum and maximum value) " + "are replaced with exponential.lowerExp and exponential.upperExp " + "(minimum and maximum exponent) since version 4.0.0. " + "Replace " + JSON.stringify(options) + " with " + JSON.stringify(fixedOptions));
                    return exports.format(value, fixedOptions);
                }
                var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
                var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;
                if (value.isZero()) return "0";
                var str;
                var exp = value.e;
                if (exp >= lowerExp && exp < upperExp) {
                    str = value.toSignificantDigits(precision).toFixed();
                } else {
                    str = exports.toExponential(value, precision);
                }
                return str.replace(/((\.\d*?)(0+))($|e)/, function() {
                    var digits = arguments[2];
                    var e = arguments[4];
                    return digits !== "." ? digits + e : e;
                });

              default:
                throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", or "fixed".');
            }
        };
        exports.toEngineering = function(value, precision) {
            var e = value.e;
            var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
            var valueWithoutExp = value.mul(Math.pow(10, -newExp));
            var valueStr = valueWithoutExp.toPrecision(precision);
            if (valueStr.indexOf("e") !== -1) {
                valueStr = valueWithoutExp.toString();
            }
            return valueStr + "e" + (e >= 0 ? "+" : "") + newExp.toString();
        };
        exports.toExponential = function(value, precision) {
            if (precision !== undefined) {
                return value.toExponential(precision - 1);
            } else {
                return value.toExponential();
            }
        };
        exports.toFixed = function(value, precision) {
            return value.toFixed(precision);
        };
    }, {
        "../object": 112
    } ],
    105: [ function(require, module, exports) {
        "use strict";
        module.exports = function isBigNumber(x) {
            return x && x.constructor.prototype.isBigNumber || false;
        };
    }, {} ],
    106: [ function(require, module, exports) {
        "use strict";
        module.exports = function deepMap(array, callback, skipZeros) {
            if (array && typeof array.map === "function") {
                return array.map(function(x) {
                    return deepMap(x, callback, skipZeros);
                });
            } else {
                return callback(array);
            }
        };
    }, {} ],
    107: [ function(require, module, exports) {
        "use strict";
        module.exports = function isMatrix(x) {
            return x && x.constructor.prototype.isMatrix || false;
        };
    }, {} ],
    108: [ function(require, module, exports) {
        "use strict";
        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }
        var hasOwnProperty = require("./object").hasOwnProperty;
        function getSafeProperty(object, prop) {
            if (isPlainObject(object) && isSafeProperty(object, prop)) {
                return object[prop];
            }
            if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
                throw new Error('Cannot access method "' + prop + '" as a property');
            }
            throw new Error('No access to property "' + prop + '"');
        }
        function setSafeProperty(object, prop, value) {
            if (isPlainObject(object) && isSafeProperty(object, prop)) {
                object[prop] = value;
                return value;
            }
            throw new Error('No access to property "' + prop + '"');
        }
        function isSafeProperty(object, prop) {
            if (!object || _typeof(object) !== "object") {
                return false;
            }
            if (hasOwnProperty(safeNativeProperties, prop)) {
                return true;
            }
            if (prop in Object.prototype) {
                return false;
            }
            if (prop in Function.prototype) {
                return false;
            }
            return true;
        }
        function validateSafeMethod(object, method) {
            if (!isSafeMethod(object, method)) {
                throw new Error('No access to method "' + method + '"');
            }
        }
        function isSafeMethod(object, method) {
            if (!object || typeof object[method] !== "function") {
                return false;
            }
            if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
                return false;
            }
            if (hasOwnProperty(safeNativeMethods, method)) {
                return true;
            }
            if (method in Object.prototype) {
                return false;
            }
            if (method in Function.prototype) {
                return false;
            }
            return true;
        }
        function isPlainObject(object) {
            return _typeof(object) === "object" && object && object.constructor === Object;
        }
        var safeNativeProperties = {
            length: true,
            name: true
        };
        var safeNativeMethods = {
            toString: true,
            valueOf: true,
            toLocaleString: true
        };
        exports.getSafeProperty = getSafeProperty;
        exports.setSafeProperty = setSafeProperty;
        exports.isSafeProperty = isSafeProperty;
        exports.validateSafeMethod = validateSafeMethod;
        exports.isSafeMethod = isSafeMethod;
        exports.isPlainObject = isPlainObject;
    }, {
        "./object": 112
    } ],
    109: [ function(require, module, exports) {
        "use strict";
        var Emitter = require("tiny-emitter");
        exports.mixin = function(obj) {
            var emitter = new Emitter();
            obj.on = emitter.on.bind(emitter);
            obj.off = emitter.off.bind(emitter);
            obj.once = emitter.once.bind(emitter);
            obj.emit = emitter.emit.bind(emitter);
            return obj;
        };
    }, {
        "tiny-emitter": 135
    } ],
    110: [ function(require, module, exports) {
        "use strict";
        var escapeLatex = require("escape-latex");
        exports.symbols = {
            Alpha: "A",
            alpha: "\\alpha",
            Beta: "B",
            beta: "\\beta",
            Gamma: "\\Gamma",
            gamma: "\\gamma",
            Delta: "\\Delta",
            delta: "\\delta",
            Epsilon: "E",
            epsilon: "\\epsilon",
            varepsilon: "\\varepsilon",
            Zeta: "Z",
            zeta: "\\zeta",
            Eta: "H",
            eta: "\\eta",
            Theta: "\\Theta",
            theta: "\\theta",
            vartheta: "\\vartheta",
            Iota: "I",
            iota: "\\iota",
            Kappa: "K",
            kappa: "\\kappa",
            varkappa: "\\varkappa",
            Lambda: "\\Lambda",
            lambda: "\\lambda",
            Mu: "M",
            mu: "\\mu",
            Nu: "N",
            nu: "\\nu",
            Xi: "\\Xi",
            xi: "\\xi",
            Omicron: "O",
            omicron: "o",
            Pi: "\\Pi",
            pi: "\\pi",
            varpi: "\\varpi",
            Rho: "P",
            rho: "\\rho",
            varrho: "\\varrho",
            Sigma: "\\Sigma",
            sigma: "\\sigma",
            varsigma: "\\varsigma",
            Tau: "T",
            tau: "\\tau",
            Upsilon: "\\Upsilon",
            upsilon: "\\upsilon",
            Phi: "\\Phi",
            phi: "\\phi",
            varphi: "\\varphi",
            Chi: "X",
            chi: "\\chi",
            Psi: "\\Psi",
            psi: "\\psi",
            Omega: "\\Omega",
            omega: "\\omega",
            true: "\\mathrm{True}",
            false: "\\mathrm{False}",
            i: "i",
            inf: "\\infty",
            Inf: "\\infty",
            infinity: "\\infty",
            Infinity: "\\infty",
            oo: "\\infty",
            lim: "\\lim",
            undefined: "\\mathbf{?}"
        };
        exports.operators = {
            transpose: "^\\top",
            ctranspose: "^H",
            factorial: "!",
            pow: "^",
            dotPow: ".^\\wedge",
            unaryPlus: "+",
            unaryMinus: "-",
            bitNot: "\\~",
            not: "\\neg",
            multiply: "\\cdot",
            divide: "\\frac",
            dotMultiply: ".\\cdot",
            dotDivide: ".:",
            mod: "\\mod",
            add: "+",
            subtract: "-",
            to: "\\rightarrow",
            leftShift: "<<",
            rightArithShift: ">>",
            rightLogShift: ">>>",
            equal: "=",
            unequal: "\\neq",
            smaller: "<",
            larger: ">",
            smallerEq: "\\leq",
            largerEq: "\\geq",
            bitAnd: "\\&",
            bitXor: "\\underline{|}",
            bitOr: "|",
            and: "\\wedge",
            xor: "\\veebar",
            or: "\\vee"
        };
        exports.defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
        var units = {
            deg: "^\\circ"
        };
        exports.escape = function(string) {
            return escapeLatex(string, {
                preserveFormatting: true
            });
        };
        exports.toSymbol = function(name, isUnit) {
            isUnit = typeof isUnit === "undefined" ? false : isUnit;
            if (isUnit) {
                if (units.hasOwnProperty(name)) {
                    return units[name];
                }
                return "\\mathrm{" + exports.escape(name) + "}";
            }
            if (exports.symbols.hasOwnProperty(name)) {
                return exports.symbols[name];
            }
            return exports.escape(name);
        };
    }, {
        "escape-latex": 48
    } ],
    111: [ function(require, module, exports) {
        "use strict";
        var objectUtils = require("./object");
        exports.isNumber = function(value) {
            return typeof value === "number";
        };
        exports.isInteger = function(value) {
            if (typeof value === "boolean") {
                return true;
            }
            return isFinite(value) ? value === Math.round(value) : false;
        };
        exports.sign = Math.sign || function(x) {
            if (x > 0) {
                return 1;
            } else if (x < 0) {
                return -1;
            } else {
                return 0;
            }
        };
        exports.format = function(value, options) {
            if (typeof options === "function") {
                return options(value);
            }
            if (value === Infinity) {
                return "Infinity";
            } else if (value === -Infinity) {
                return "-Infinity";
            } else if (isNaN(value)) {
                return "NaN";
            }
            var notation = "auto";
            var precision;
            if (options) {
                if (options.notation) {
                    notation = options.notation;
                }
                if (exports.isNumber(options)) {
                    precision = options;
                } else if (exports.isNumber(options.precision)) {
                    precision = options.precision;
                }
            }
            switch (notation) {
              case "fixed":
                return exports.toFixed(value, precision);

              case "exponential":
                return exports.toExponential(value, precision);

              case "engineering":
                return exports.toEngineering(value, precision);

              case "auto":
                if (options && options.exponential && (options.exponential.lower !== undefined || options.exponential.upper !== undefined)) {
                    var fixedOptions = objectUtils.map(options, function(x) {
                        return x;
                    });
                    fixedOptions.exponential = undefined;
                    if (options.exponential.lower !== undefined) {
                        fixedOptions.lowerExp = Math.round(Math.log(options.exponential.lower) / Math.LN10);
                    }
                    if (options.exponential.upper !== undefined) {
                        fixedOptions.upperExp = Math.round(Math.log(options.exponential.upper) / Math.LN10);
                    }
                    console.warn("Deprecation warning: Formatting options exponential.lower and exponential.upper " + "(minimum and maximum value) " + "are replaced with exponential.lowerExp and exponential.upperExp " + "(minimum and maximum exponent) since version 4.0.0. " + "Replace " + JSON.stringify(options) + " with " + JSON.stringify(fixedOptions));
                    return exports.toPrecision(value, precision, fixedOptions);
                }
                return exports.toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function() {
                    var digits = arguments[2];
                    var e = arguments[4];
                    return digits !== "." ? digits + e : e;
                });

              default:
                throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", or "fixed".');
            }
        };
        exports.splitNumber = function(value) {
            var match = String(value).toLowerCase().match(/^0*?(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
            if (!match) {
                throw new SyntaxError("Invalid number " + value);
            }
            var sign = match[1];
            var digits = match[2];
            var exponent = parseFloat(match[4] || "0");
            var dot = digits.indexOf(".");
            exponent += dot !== -1 ? dot - 1 : digits.length - 1;
            var coefficients = digits.replace(".", "").replace(/^0*/, function(zeros) {
                exponent -= zeros.length;
                return "";
            }).replace(/0*$/, "").split("").map(function(d) {
                return parseInt(d);
            });
            if (coefficients.length === 0) {
                coefficients.push(0);
                exponent++;
            }
            return {
                sign: sign,
                coefficients: coefficients,
                exponent: exponent
            };
        };
        exports.toEngineering = function(value, precision) {
            if (isNaN(value) || !isFinite(value)) {
                return String(value);
            }
            var rounded = exports.roundDigits(exports.splitNumber(value), precision);
            var e = rounded.exponent;
            var c = rounded.coefficients;
            var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
            if (exports.isNumber(precision)) {
                while (precision > c.length || e - newExp + 1 > c.length) {
                    c.push(0);
                }
            } else {
                var significandsDiff = e >= 0 ? e : Math.abs(newExp);
                while (c.length - 1 < significandsDiff) {
                    c.push(0);
                }
            }
            var expDiff = Math.abs(e - newExp);
            var decimalIdx = 1;
            while (expDiff > 0) {
                decimalIdx++;
                expDiff--;
            }
            var decimals = c.slice(decimalIdx).join("");
            var decimalVal = exports.isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
            var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e >= 0 ? "+" : "") + newExp.toString();
            return rounded.sign + str;
        };
        exports.toFixed = function(value, precision) {
            if (isNaN(value) || !isFinite(value)) {
                return String(value);
            }
            var splitValue = exports.splitNumber(value);
            var rounded = typeof precision === "number" ? exports.roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
            var c = rounded.coefficients;
            var p = rounded.exponent + 1;
            var pp = p + (precision || 0);
            if (c.length < pp) {
                c = c.concat(zeros(pp - c.length));
            }
            if (p < 0) {
                c = zeros(-p + 1).concat(c);
                p = 1;
            }
            if (p < c.length) {
                c.splice(p, 0, p === 0 ? "0." : ".");
            }
            return rounded.sign + c.join("");
        };
        exports.toExponential = function(value, precision) {
            if (isNaN(value) || !isFinite(value)) {
                return String(value);
            }
            var split = exports.splitNumber(value);
            var rounded = precision ? exports.roundDigits(split, precision) : split;
            var c = rounded.coefficients;
            var e = rounded.exponent;
            if (c.length < precision) {
                c = c.concat(zeros(precision - c.length));
            }
            var first = c.shift();
            return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e >= 0 ? "+" : "") + e;
        };
        exports.toPrecision = function(value, precision, options) {
            if (isNaN(value) || !isFinite(value)) {
                return String(value);
            }
            var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
            var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;
            var split = exports.splitNumber(value);
            if (split.exponent < lowerExp || split.exponent >= upperExp) {
                return exports.toExponential(value, precision);
            } else {
                var rounded = precision ? exports.roundDigits(split, precision) : split;
                var c = rounded.coefficients;
                var e = rounded.exponent;
                if (c.length < precision) {
                    c = c.concat(zeros(precision - c.length));
                }
                c = c.concat(zeros(e - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
                c = zeros(-e).concat(c);
                var dot = e > 0 ? e : 0;
                if (dot < c.length - 1) {
                    c.splice(dot + 1, 0, ".");
                }
                return rounded.sign + c.join("");
            }
        };
        exports.roundDigits = function(split, precision) {
            var rounded = {
                sign: split.sign,
                coefficients: split.coefficients,
                exponent: split.exponent
            };
            var c = rounded.coefficients;
            while (precision <= 0) {
                c.unshift(0);
                rounded.exponent++;
                precision++;
            }
            if (c.length > precision) {
                var removed = c.splice(precision, c.length - precision);
                if (removed[0] >= 5) {
                    var i = precision - 1;
                    c[i]++;
                    while (c[i] === 10) {
                        c.pop();
                        if (i === 0) {
                            c.unshift(0);
                            rounded.exponent++;
                            i++;
                        }
                        i--;
                        c[i]++;
                    }
                }
            }
            return rounded;
        };
        function zeros(length) {
            var arr = [];
            for (var i = 0; i < length; i++) {
                arr.push(0);
            }
            return arr;
        }
        exports.digits = function(value) {
            return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
        };
        exports.DBL_EPSILON = Number.EPSILON || 2.220446049250313e-16;
        exports.nearlyEqual = function(x, y, epsilon) {
            if (epsilon === null || epsilon === undefined) {
                return x === y;
            }
            if (x === y) {
                return true;
            }
            if (isNaN(x) || isNaN(y)) {
                return false;
            }
            if (isFinite(x) && isFinite(y)) {
                var diff = Math.abs(x - y);
                if (diff < exports.DBL_EPSILON) {
                    return true;
                } else {
                    return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
                }
            }
            return false;
        };
    }, {
        "./object": 112
    } ],
    112: [ function(require, module, exports) {
        "use strict";
        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }
        var isBigNumber = require("./bignumber/isBigNumber");
        exports.clone = function clone(x) {
            var type = _typeof(x);
            if (type === "number" || type === "string" || type === "boolean" || x === null || x === undefined) {
                return x;
            }
            if (typeof x.clone === "function") {
                return x.clone();
            }
            if (Array.isArray(x)) {
                return x.map(function(value) {
                    return clone(value);
                });
            }
            if (x instanceof Date) return new Date(x.valueOf());
            if (isBigNumber(x)) return x;
            if (x instanceof RegExp) throw new TypeError("Cannot clone " + x);
            return exports.map(x, clone);
        };
        exports.map = function(object, callback) {
            var clone = {};
            for (var key in object) {
                if (exports.hasOwnProperty(object, key)) {
                    clone[key] = callback(object[key]);
                }
            }
            return clone;
        };
        exports.extend = function(a, b) {
            for (var prop in b) {
                if (exports.hasOwnProperty(b, prop)) {
                    a[prop] = b[prop];
                }
            }
            return a;
        };
        exports.deepExtend = function deepExtend(a, b) {
            if (Array.isArray(b)) {
                throw new TypeError("Arrays are not supported by deepExtend");
            }
            for (var prop in b) {
                if (exports.hasOwnProperty(b, prop)) {
                    if (b[prop] && b[prop].constructor === Object) {
                        if (a[prop] === undefined) {
                            a[prop] = {};
                        }
                        if (a[prop].constructor === Object) {
                            deepExtend(a[prop], b[prop]);
                        } else {
                            a[prop] = b[prop];
                        }
                    } else if (Array.isArray(b[prop])) {
                        throw new TypeError("Arrays are not supported by deepExtend");
                    } else {
                        a[prop] = b[prop];
                    }
                }
            }
            return a;
        };
        exports.deepEqual = function deepEqual(a, b) {
            var prop, i, len;
            if (Array.isArray(a)) {
                if (!Array.isArray(b)) {
                    return false;
                }
                if (a.length !== b.length) {
                    return false;
                }
                for (i = 0, len = a.length; i < len; i++) {
                    if (!exports.deepEqual(a[i], b[i])) {
                        return false;
                    }
                }
                return true;
            } else if (a instanceof Object) {
                if (Array.isArray(b) || !(b instanceof Object)) {
                    return false;
                }
                for (prop in a) {
                    if (!exports.deepEqual(a[prop], b[prop])) {
                        return false;
                    }
                }
                for (prop in b) {
                    if (!exports.deepEqual(a[prop], b[prop])) {
                        return false;
                    }
                }
                return true;
            } else {
                return a === b;
            }
        };
        exports.canDefineProperty = function() {
            try {
                if (Object.defineProperty) {
                    Object.defineProperty({}, "x", {
                        get: function get() {}
                    });
                    return true;
                }
            } catch (e) {}
            return false;
        };
        exports.lazy = function(object, prop, fn) {
            if (exports.canDefineProperty()) {
                var _uninitialized = true;
                var _value;
                Object.defineProperty(object, prop, {
                    get: function get() {
                        if (_uninitialized) {
                            _value = fn();
                            _uninitialized = false;
                        }
                        return _value;
                    },
                    set: function set(value) {
                        _value = value;
                        _uninitialized = false;
                    },
                    configurable: true,
                    enumerable: true
                });
            } else {
                object[prop] = fn();
            }
        };
        exports.traverse = function(object, path) {
            var obj = object;
            if (path) {
                var names = path.split(".");
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];
                    if (!(name in obj)) {
                        obj[name] = {};
                    }
                    obj = obj[name];
                }
            }
            return obj;
        };
        exports.hasOwnProperty = function(object, property) {
            return object && Object.hasOwnProperty.call(object, property);
        };
        exports.isFactory = function(object) {
            return object && typeof object.factory === "function";
        };
    }, {
        "./bignumber/isBigNumber": 105
    } ],
    113: [ function(require, module, exports) {
        "use strict";
        Number.isFinite = Number.isFinite || function(value) {
            return typeof value === "number" && isFinite(value);
        };
        Number.isNaN = Number.isNaN || function(value) {
            return value !== value;
        };
    }, {} ],
    114: [ function(require, module, exports) {
        "use strict";
        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof(obj) {
                    return typeof obj;
                };
            } else {
                _typeof = function _typeof(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }
            return _typeof(obj);
        }
        var formatNumber = require("./number").format;
        var formatBigNumber = require("./bignumber/formatter").format;
        var isBigNumber = require("./bignumber/isBigNumber");
        exports.isString = function(value) {
            return typeof value === "string";
        };
        exports.endsWith = function(text, search) {
            var start = text.length - search.length;
            var end = text.length;
            return text.substring(start, end) === search;
        };
        exports.format = function(value, options) {
            if (typeof value === "number") {
                return formatNumber(value, options);
            }
            if (isBigNumber(value)) {
                return formatBigNumber(value, options);
            }
            if (looksLikeFraction(value)) {
                if (!options || options.fraction !== "decimal") {
                    return value.s * value.n + "/" + value.d;
                } else {
                    return value.toString();
                }
            }
            if (Array.isArray(value)) {
                return formatArray(value, options);
            }
            if (exports.isString(value)) {
                return '"' + value + '"';
            }
            if (typeof value === "function") {
                return value.syntax ? String(value.syntax) : "function";
            }
            if (value && _typeof(value) === "object") {
                if (typeof value.format === "function") {
                    return value.format(options);
                } else if (value && value.toString() !== {}.toString()) {
                    return value.toString();
                } else {
                    var entries = [];
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            entries.push('"' + key + '": ' + exports.format(value[key], options));
                        }
                    }
                    return "{" + entries.join(", ") + "}";
                }
            }
            return String(value);
        };
        exports.stringify = function(value) {
            var text = String(value);
            var escaped = "";
            var i = 0;
            while (i < text.length) {
                var c = text.charAt(i);
                if (c === "\\") {
                    escaped += c;
                    i++;
                    c = text.charAt(i);
                    if (c === "" || '"\\/bfnrtu'.indexOf(c) === -1) {
                        escaped += "\\";
                    }
                    escaped += c;
                } else if (c === '"') {
                    escaped += '\\"';
                } else {
                    escaped += c;
                }
                i++;
            }
            return '"' + escaped + '"';
        };
        exports.escape = function(value) {
            var text = String(value);
            text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            return text;
        };
        function formatArray(array, options) {
            if (Array.isArray(array)) {
                var str = "[";
                var len = array.length;
                for (var i = 0; i < len; i++) {
                    if (i !== 0) {
                        str += ", ";
                    }
                    str += formatArray(array[i], options);
                }
                str += "]";
                return str;
            } else {
                return exports.format(array, options);
            }
        }
        function looksLikeFraction(value) {
            return value && _typeof(value) === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
        }
    }, {
        "./bignumber/formatter": 104,
        "./bignumber/isBigNumber": 105,
        "./number": 111
    } ],
    115: [ function(require, module, exports) {
        (function() {
            var crypt = require("crypt"), utf8 = require("charenc").utf8, isBuffer = require("is-buffer"), bin = require("charenc").bin, md5 = function(message, options) {
                if (message.constructor == String) if (options && options.encoding === "binary") message = bin.stringToBytes(message); else message = utf8.stringToBytes(message); else if (isBuffer(message)) message = Array.prototype.slice.call(message, 0); else if (!Array.isArray(message) && message.constructor !== Uint8Array) message = message.toString();
                var m = crypt.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
                for (var i = 0; i < m.length; i++) {
                    m[i] = (m[i] << 8 | m[i] >>> 24) & 16711935 | (m[i] << 24 | m[i] >>> 8) & 4278255360;
                }
                m[l >>> 5] |= 128 << l % 32;
                m[(l + 64 >>> 9 << 4) + 14] = l;
                var FF = md5._ff, GG = md5._gg, HH = md5._hh, II = md5._ii;
                for (var i = 0; i < m.length; i += 16) {
                    var aa = a, bb = b, cc = c, dd = d;
                    a = FF(a, b, c, d, m[i + 0], 7, -680876936);
                    d = FF(d, a, b, c, m[i + 1], 12, -389564586);
                    c = FF(c, d, a, b, m[i + 2], 17, 606105819);
                    b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
                    a = FF(a, b, c, d, m[i + 4], 7, -176418897);
                    d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
                    c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
                    b = FF(b, c, d, a, m[i + 7], 22, -45705983);
                    a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
                    d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
                    c = FF(c, d, a, b, m[i + 10], 17, -42063);
                    b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
                    a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
                    d = FF(d, a, b, c, m[i + 13], 12, -40341101);
                    c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
                    b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
                    a = GG(a, b, c, d, m[i + 1], 5, -165796510);
                    d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
                    c = GG(c, d, a, b, m[i + 11], 14, 643717713);
                    b = GG(b, c, d, a, m[i + 0], 20, -373897302);
                    a = GG(a, b, c, d, m[i + 5], 5, -701558691);
                    d = GG(d, a, b, c, m[i + 10], 9, 38016083);
                    c = GG(c, d, a, b, m[i + 15], 14, -660478335);
                    b = GG(b, c, d, a, m[i + 4], 20, -405537848);
                    a = GG(a, b, c, d, m[i + 9], 5, 568446438);
                    d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
                    c = GG(c, d, a, b, m[i + 3], 14, -187363961);
                    b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
                    a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
                    d = GG(d, a, b, c, m[i + 2], 9, -51403784);
                    c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
                    b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
                    a = HH(a, b, c, d, m[i + 5], 4, -378558);
                    d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
                    c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
                    b = HH(b, c, d, a, m[i + 14], 23, -35309556);
                    a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
                    d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
                    c = HH(c, d, a, b, m[i + 7], 16, -155497632);
                    b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
                    a = HH(a, b, c, d, m[i + 13], 4, 681279174);
                    d = HH(d, a, b, c, m[i + 0], 11, -358537222);
                    c = HH(c, d, a, b, m[i + 3], 16, -722521979);
                    b = HH(b, c, d, a, m[i + 6], 23, 76029189);
                    a = HH(a, b, c, d, m[i + 9], 4, -640364487);
                    d = HH(d, a, b, c, m[i + 12], 11, -421815835);
                    c = HH(c, d, a, b, m[i + 15], 16, 530742520);
                    b = HH(b, c, d, a, m[i + 2], 23, -995338651);
                    a = II(a, b, c, d, m[i + 0], 6, -198630844);
                    d = II(d, a, b, c, m[i + 7], 10, 1126891415);
                    c = II(c, d, a, b, m[i + 14], 15, -1416354905);
                    b = II(b, c, d, a, m[i + 5], 21, -57434055);
                    a = II(a, b, c, d, m[i + 12], 6, 1700485571);
                    d = II(d, a, b, c, m[i + 3], 10, -1894986606);
                    c = II(c, d, a, b, m[i + 10], 15, -1051523);
                    b = II(b, c, d, a, m[i + 1], 21, -2054922799);
                    a = II(a, b, c, d, m[i + 8], 6, 1873313359);
                    d = II(d, a, b, c, m[i + 15], 10, -30611744);
                    c = II(c, d, a, b, m[i + 6], 15, -1560198380);
                    b = II(b, c, d, a, m[i + 13], 21, 1309151649);
                    a = II(a, b, c, d, m[i + 4], 6, -145523070);
                    d = II(d, a, b, c, m[i + 11], 10, -1120210379);
                    c = II(c, d, a, b, m[i + 2], 15, 718787259);
                    b = II(b, c, d, a, m[i + 9], 21, -343485551);
                    a = a + aa >>> 0;
                    b = b + bb >>> 0;
                    c = c + cc >>> 0;
                    d = d + dd >>> 0;
                }
                return crypt.endian([ a, b, c, d ]);
            };
            md5._ff = function(a, b, c, d, x, s, t) {
                var n = a + (b & c | ~b & d) + (x >>> 0) + t;
                return (n << s | n >>> 32 - s) + b;
            };
            md5._gg = function(a, b, c, d, x, s, t) {
                var n = a + (b & d | c & ~d) + (x >>> 0) + t;
                return (n << s | n >>> 32 - s) + b;
            };
            md5._hh = function(a, b, c, d, x, s, t) {
                var n = a + (b ^ c ^ d) + (x >>> 0) + t;
                return (n << s | n >>> 32 - s) + b;
            };
            md5._ii = function(a, b, c, d, x, s, t) {
                var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
                return (n << s | n >>> 32 - s) + b;
            };
            md5._blocksize = 16;
            md5._digestsize = 16;
            module.exports = function(message, options) {
                if (message === undefined || message === null) throw new Error("Illegal argument " + message);
                var digestbytes = crypt.wordsToBytes(md5(message, options));
                return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
            };
        })();
    }, {
        charenc: 46,
        crypt: 47,
        "is-buffer": 58
    } ],
    116: [ function(require, module, exports) {
        module.exports = function(modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) {
                    return installedModules[moduleId].exports;
                }
                var module = installedModules[moduleId] = {
                    i: moduleId,
                    l: false,
                    exports: {}
                };
                modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                module.l = true;
                return module.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function(exports, name, getter) {
                if (!__webpack_require__.o(exports, name)) {
                    Object.defineProperty(exports, name, {
                        configurable: false,
                        enumerable: true,
                        get: getter
                    });
                }
            };
            __webpack_require__.n = function(module) {
                var getter = module && module.__esModule ? function getDefault() {
                    return module["default"];
                } : function getModuleExports() {
                    return module;
                };
                __webpack_require__.d(getter, "a", getter);
                return getter;
            };
            __webpack_require__.o = function(object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
            };
            __webpack_require__.p = "";
            return __webpack_require__(__webpack_require__.s = 0);
        }([ function(module, exports, __webpack_require__) {
            "use strict";
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }
                return target;
            };
            var UAParser = __webpack_require__(1);
            var _require = __webpack_require__(3), BROWSER_TYPES = _require.BROWSER_TYPES, OS_TYPES = _require.OS_TYPES, DEVICE_TYPES = _require.DEVICE_TYPES, defaultData = _require.defaultData;
            var UA = new UAParser();
            var browser = UA.getBrowser();
            var device = UA.getDevice();
            var engine = UA.getEngine();
            var os = UA.getOS();
            var ua = UA.getUA();
            var CHROME = BROWSER_TYPES.CHROME, CHROMIUM = BROWSER_TYPES.CHROMIUM, IE = BROWSER_TYPES.IE, INTERNET_EXPLORER = BROWSER_TYPES.INTERNET_EXPLORER, OPERA = BROWSER_TYPES.OPERA, FIREFOX = BROWSER_TYPES.FIREFOX, SAFARI = BROWSER_TYPES.SAFARI, EDGE = BROWSER_TYPES.EDGE, YANDEX = BROWSER_TYPES.YANDEX, MOBILE_SAFARI = BROWSER_TYPES.MOBILE_SAFARI;
            var MOBILE = DEVICE_TYPES.MOBILE, TABLET = DEVICE_TYPES.TABLET, SMART_TV = DEVICE_TYPES.SMART_TV, BROWSER = DEVICE_TYPES.BROWSER, WEARABLE = DEVICE_TYPES.WEARABLE, CONSOLE = DEVICE_TYPES.CONSOLE;
            var ANDROID = OS_TYPES.ANDROID, WINDOWS_PHONE = OS_TYPES.WINDOWS_PHONE, IOS = OS_TYPES.IOS;
            var checkType = function checkType(type) {
                switch (type) {
                  case MOBILE:
                    return {
                        isMobile: true
                    };

                  case TABLET:
                    return {
                        isTablet: true
                    };

                  case SMART_TV:
                    return {
                        isSmartTV: true
                    };

                  case CONSOLE:
                    return {
                        isConsole: true
                    };

                  case WEARABLE:
                    return {
                        isWearable: true
                    };

                  case BROWSER:
                    return {
                        isBrowser: true
                    };

                  default:
                    return defaultData;
                }
            };
            var broPayload = function broPayload(isBrowser, browser, engine, os, ua) {
                return {
                    isBrowser: isBrowser,
                    browserMajorVersion: browser.major,
                    browserFullVersion: browser.version,
                    browserName: browser.name,
                    engineName: engine.name || false,
                    engineVersion: engine.version,
                    osName: os.name,
                    osVersion: os.version,
                    userAgent: ua
                };
            };
            var mobilePayload = function mobilePayload(type, device, os, ua) {
                return _extends({}, type, {
                    vendor: device.vendor,
                    model: device.model,
                    os: os.name,
                    osVersion: os.version,
                    ua: ua
                });
            };
            var stvPayload = function stvPayload(isSmartTV, engine, os, ua) {
                return {
                    isSmartTV: isSmartTV,
                    engineName: engine.name,
                    engineVersion: engine.version,
                    osName: os.name,
                    osVersion: os.version,
                    userAgent: ua
                };
            };
            var consolePayload = function consolePayload(isConsole, engine, os, ua) {
                return {
                    isConsole: isConsole,
                    engineName: engine.name,
                    engineVersion: engine.version,
                    osName: os.name,
                    osVersion: os.version,
                    userAgent: ua
                };
            };
            var wearPayload = function wearPayload(isWearable, engine, os, ua) {
                return {
                    isWearable: isWearable,
                    engineName: engine.name,
                    engineVersion: engine.version,
                    osName: os.name,
                    osVersion: os.version,
                    userAgent: ua
                };
            };
            var isMobileType = function isMobileType() {
                return device.type === MOBILE;
            };
            var isTabletType = function isTabletType() {
                return device.type === TABLET;
            };
            var isMobileAndTabletType = function isMobileAndTabletType() {
                switch (device.type) {
                  case MOBILE:
                  case TABLET:
                    return true;

                  default:
                    return false;
                }
            };
            var isSmartTVType = function isSmartTVType() {
                return device.type === SMART_TV;
            };
            var isBrowserType = function isBrowserType() {
                return device.type === BROWSER;
            };
            var isWearableType = function isWearableType() {
                return device.type === WEARABLE;
            };
            var isConsoleType = function isConsoleType() {
                return device.type === CONSOLE;
            };
            var isAndroidType = function isAndroidType() {
                return os.name === ANDROID;
            };
            var isWinPhoneType = function isWinPhoneType() {
                return os.name === WINDOWS_PHONE;
            };
            var isIOSType = function isIOSType() {
                return os.name === IOS;
            };
            var isChromeType = function isChromeType() {
                return browser.name === CHROME;
            };
            var isFirefoxType = function isFirefoxType() {
                return browser.name === FIREFOX;
            };
            var isChromiumType = function isChromiumType() {
                return browser.name === CHROMIUM;
            };
            var isEdgeType = function isEdgeType() {
                return browser.name === EDGE;
            };
            var isYandexType = function isYandexType() {
                return browser.name === YANDEX;
            };
            var isSafariType = function isSafariType() {
                return browser.name === SAFARI || browser.name === MOBILE_SAFARI;
            };
            var isMobileSafariType = function isMobileSafariType() {
                return browser.name === MOBILE_SAFARI;
            };
            var isOperaType = function isOperaType() {
                return browser.name === OPERA;
            };
            var isIEType = function isIEType() {
                return browser.name === INTERNET_EXPLORER || browser.name === IE;
            };
            var getBrowserFullVersion = function getBrowserFullVersion() {
                return browser.major;
            };
            var getBrowserVersion = function getBrowserVersion() {
                return browser.version;
            };
            var getOsVersion = function getOsVersion() {
                return os.version ? os.version : "none";
            };
            var getOsName = function getOsName() {
                return os.name ? os.name : "none";
            };
            var getBrowserName = function getBrowserName() {
                return browser.name;
            };
            var getMobileVendor = function getMobileVendor() {
                return device.vendor ? device.vendor : "none";
            };
            var getMobileModel = function getMobileModel() {
                return device.model ? device.model : "none";
            };
            var getEngineName = function getEngineName() {
                return engine.name;
            };
            var getEngineVersion = function getEngineVersion() {
                return engine.version;
            };
            var getUseragent = function getUseragent() {
                return ua;
            };
            var getDeviceType = function getDeviceType() {
                return device.type;
            };
            var isSmartTV = isSmartTVType();
            var isConsole = isConsoleType();
            var isWearable = isWearableType();
            var isMobileSafari = isMobileSafariType();
            var isChromium = isChromiumType();
            var isMobile = isMobileAndTabletType();
            var isMobileOnly = isMobileType();
            var isTablet = isTabletType();
            var isBrowser = isBrowserType();
            var isAndroid = isAndroidType();
            var isWinPhone = isWinPhoneType();
            var isIOS = isIOSType();
            var isChrome = isChromeType();
            var isFirefox = isFirefoxType();
            var isSafari = isSafariType();
            var isOpera = isOperaType();
            var isIE = isIEType();
            var osVersion = getOsVersion();
            var osName = getOsName();
            var fullBrowserVersion = getBrowserFullVersion();
            var browserVersion = getBrowserVersion();
            var browserName = getBrowserName();
            var mobileVendor = getMobileVendor();
            var mobileModel = getMobileModel();
            var engineName = getEngineName();
            var engineVersion = getEngineVersion();
            var getUA = getUseragent();
            var isEdge = isEdgeType();
            var isYandex = isYandexType();
            var deviceType = getDeviceType();
            var type = checkType(device.type);
            function deviceDetect() {
                var isBrowser = type.isBrowser, isMobile = type.isMobile, isTablet = type.isTablet, isSmartTV = type.isSmartTV, isConsole = type.isConsole, isWearable = type.isWearable;
                if (isBrowser) {
                    return broPayload(isBrowser, browser, engine, os, ua);
                }
                if (isSmartTV) {
                    return stvPayload(isSmartTV, engine, os, ua);
                }
                if (isConsole) {
                    return consolePayload(isConsole, engine, os, ua);
                }
                if (isMobile) {
                    return mobilePayload(type, device, os, ua);
                }
                if (isTablet) {
                    return mobilePayload(type, device, os, ua);
                }
                if (isWearable) {
                    return wearPayload(isWearable, engine, os, ua);
                }
            }
            module.exports = {
                deviceDetect: deviceDetect,
                isSmartTV: isSmartTV,
                isConsole: isConsole,
                isWearable: isWearable,
                isMobileSafari: isMobileSafari,
                isChromium: isChromium,
                isMobile: isMobile,
                isMobileOnly: isMobileOnly,
                isTablet: isTablet,
                isBrowser: isBrowser,
                isAndroid: isAndroid,
                isWinPhone: isWinPhone,
                isIOS: isIOS,
                isChrome: isChrome,
                isFirefox: isFirefox,
                isSafari: isSafari,
                isOpera: isOpera,
                isIE: isIE,
                osVersion: osVersion,
                osName: osName,
                fullBrowserVersion: fullBrowserVersion,
                browserVersion: browserVersion,
                browserName: browserName,
                mobileVendor: mobileVendor,
                mobileModel: mobileModel,
                engineName: engineName,
                engineVersion: engineVersion,
                getUA: getUA,
                isEdge: isEdge,
                isYandex: isYandex,
                deviceType: deviceType
            };
        }, function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            (function(window, undefined) {
                "use strict";
                var LIBVERSION = "0.7.18", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded";
                var util = {
                    extend: function(regexes, extensions) {
                        var margedRegexes = {};
                        for (var i in regexes) {
                            if (extensions[i] && extensions[i].length % 2 === 0) {
                                margedRegexes[i] = extensions[i].concat(regexes[i]);
                            } else {
                                margedRegexes[i] = regexes[i];
                            }
                        }
                        return margedRegexes;
                    },
                    has: function(str1, str2) {
                        if (typeof str1 === "string") {
                            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
                        } else {
                            return false;
                        }
                    },
                    lowerize: function(str) {
                        return str.toLowerCase();
                    },
                    major: function(version) {
                        return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, "").split(".")[0] : undefined;
                    },
                    trim: function(str) {
                        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
                    }
                };
                var mapper = {
                    rgx: function(ua, arrays) {
                        var i = 0, j, k, p, q, matches, match;
                        while (i < arrays.length && !matches) {
                            var regex = arrays[i], props = arrays[i + 1];
                            j = k = 0;
                            while (j < regex.length && !matches) {
                                matches = regex[j++].exec(ua);
                                if (!!matches) {
                                    for (p = 0; p < props.length; p++) {
                                        match = matches[++k];
                                        q = props[p];
                                        if (typeof q === OBJ_TYPE && q.length > 0) {
                                            if (q.length == 2) {
                                                if (typeof q[1] == FUNC_TYPE) {
                                                    this[q[0]] = q[1].call(this, match);
                                                } else {
                                                    this[q[0]] = q[1];
                                                }
                                            } else if (q.length == 3) {
                                                if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                                    this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                                } else {
                                                    this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                                }
                                            } else if (q.length == 4) {
                                                this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                            }
                                        } else {
                                            this[q] = match ? match : undefined;
                                        }
                                    }
                                }
                            }
                            i += 2;
                        }
                    },
                    str: function(str, map) {
                        for (var i in map) {
                            if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                                for (var j = 0; j < map[i].length; j++) {
                                    if (util.has(map[i][j], str)) {
                                        return i === UNKNOWN ? undefined : i;
                                    }
                                }
                            } else if (util.has(map[i], str)) {
                                return i === UNKNOWN ? undefined : i;
                            }
                        }
                        return str;
                    }
                };
                var maps = {
                    browser: {
                        oldsafari: {
                            version: {
                                "1.0": "/8",
                                1.2: "/1",
                                1.3: "/3",
                                "2.0": "/412",
                                "2.0.2": "/416",
                                "2.0.3": "/417",
                                "2.0.4": "/419",
                                "?": "/"
                            }
                        }
                    },
                    device: {
                        amazon: {
                            model: {
                                "Fire Phone": [ "SD", "KF" ]
                            }
                        },
                        sprint: {
                            model: {
                                "Evo Shift 4G": "7373KT"
                            },
                            vendor: {
                                HTC: "APA",
                                Sprint: "Sprint"
                            }
                        }
                    },
                    os: {
                        windows: {
                            version: {
                                ME: "4.90",
                                "NT 3.11": "NT3.51",
                                "NT 4.0": "NT4.0",
                                2000: "NT 5.0",
                                XP: [ "NT 5.1", "NT 5.2" ],
                                Vista: "NT 6.0",
                                7: "NT 6.1",
                                8: "NT 6.2",
                                8.1: "NT 6.3",
                                10: [ "NT 6.4", "NT 10.0" ],
                                RT: "ARM"
                            }
                        }
                    }
                };
                var regexes = {
                    browser: [ [ /(opera\smini)\/([\w\.-]+)/i, /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i, /(opera).+version\/([\w\.]+)/i, /(opera)[\/\s]+([\w\.]+)/i ], [ NAME, VERSION ], [ /(opios)[\/\s]+([\w\.]+)/i ], [ [ NAME, "Opera Mini" ], VERSION ], [ /\s(opr)\/([\w\.]+)/i ], [ [ NAME, "Opera" ], VERSION ], [ /(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i, /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i, /(?:ms|\()(ie)\s([\w\.]+)/i, /(rekonq)\/([\w\.]*)/i, /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark)\/([\w\.-]+)/i ], [ NAME, VERSION ], [ /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i ], [ [ NAME, "IE" ], VERSION ], [ /(edge|edgios|edgea)\/((\d+)?[\w\.]+)/i ], [ [ NAME, "Edge" ], VERSION ], [ /(yabrowser)\/([\w\.]+)/i ], [ [ NAME, "Yandex" ], VERSION ], [ /(puffin)\/([\w\.]+)/i ], [ [ NAME, "Puffin" ], VERSION ], [ /((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i ], [ [ NAME, "UCBrowser" ], VERSION ], [ /(comodo_dragon)\/([\w\.]+)/i ], [ [ NAME, /_/g, " " ], VERSION ], [ /(micromessenger)\/([\w\.]+)/i ], [ [ NAME, "WeChat" ], VERSION ], [ /(qqbrowserlite)\/([\w\.]+)/i ], [ NAME, VERSION ], [ /(QQ)\/([\d\.]+)/i ], [ NAME, VERSION ], [ /m?(qqbrowser)[\/\s]?([\w\.]+)/i ], [ NAME, VERSION ], [ /(BIDUBrowser)[\/\s]?([\w\.]+)/i ], [ NAME, VERSION ], [ /(2345Explorer)[\/\s]?([\w\.]+)/i ], [ NAME, VERSION ], [ /(MetaSr)[\/\s]?([\w\.]+)/i ], [ NAME ], [ /(LBBROWSER)/i ], [ NAME ], [ /xiaomi\/miuibrowser\/([\w\.]+)/i ], [ VERSION, [ NAME, "MIUI Browser" ] ], [ /;fbav\/([\w\.]+);/i ], [ VERSION, [ NAME, "Facebook" ] ], [ /headlesschrome(?:\/([\w\.]+)|\s)/i ], [ VERSION, [ NAME, "Chrome Headless" ] ], [ /\swv\).+(chrome)\/([\w\.]+)/i ], [ [ NAME, /(.+)/, "$1 WebView" ], VERSION ], [ /((?:oculus|samsung)browser)\/([\w\.]+)/i ], [ [ NAME, /(.+(?:g|us))(.+)/, "$1 $2" ], VERSION ], [ /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i ], [ VERSION, [ NAME, "Android Browser" ] ], [ /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i ], [ NAME, VERSION ], [ /(dolfin)\/([\w\.]+)/i ], [ [ NAME, "Dolphin" ], VERSION ], [ /((?:android.+)crmo|crios)\/([\w\.]+)/i ], [ [ NAME, "Chrome" ], VERSION ], [ /(coast)\/([\w\.]+)/i ], [ [ NAME, "Opera Coast" ], VERSION ], [ /fxios\/([\w\.-]+)/i ], [ VERSION, [ NAME, "Firefox" ] ], [ /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i ], [ VERSION, [ NAME, "Mobile Safari" ] ], [ /version\/([\w\.]+).+?(mobile\s?safari|safari)/i ], [ VERSION, NAME ], [ /webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i ], [ [ NAME, "GSA" ], VERSION ], [ /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i ], [ NAME, [ VERSION, mapper.str, maps.browser.oldsafari.version ] ], [ /(konqueror)\/([\w\.]+)/i, /(webkit|khtml)\/([\w\.]+)/i ], [ NAME, VERSION ], [ /(navigator|netscape)\/([\w\.-]+)/i ], [ [ NAME, "Netscape" ], VERSION ], [ /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i, /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i, /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i, /(links)\s\(([\w\.]+)/i, /(gobrowser)\/?([\w\.]*)/i, /(ice\s?browser)\/v?([\w\._]+)/i, /(mosaic)[\/\s]([\w\.]+)/i ], [ NAME, VERSION ] ],
                    cpu: [ [ /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i ], [ [ ARCHITECTURE, "amd64" ] ], [ /(ia32(?=;))/i ], [ [ ARCHITECTURE, util.lowerize ] ], [ /((?:i[346]|x)86)[;\)]/i ], [ [ ARCHITECTURE, "ia32" ] ], [ /windows\s(ce|mobile);\sppc;/i ], [ [ ARCHITECTURE, "arm" ] ], [ /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i ], [ [ ARCHITECTURE, /ower/, "", util.lowerize ] ], [ /(sun4\w)[;\)]/i ], [ [ ARCHITECTURE, "sparc" ] ], [ /((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i ], [ [ ARCHITECTURE, util.lowerize ] ] ],
                    device: [ [ /\((ipad|playbook);[\w\s\);-]+(rim|apple)/i ], [ MODEL, VENDOR, [ TYPE, TABLET ] ], [ /applecoremedia\/[\w\.]+ \((ipad)/ ], [ MODEL, [ VENDOR, "Apple" ], [ TYPE, TABLET ] ], [ /(apple\s{0,1}tv)/i ], [ [ MODEL, "Apple TV" ], [ VENDOR, "Apple" ] ], [ /(archos)\s(gamepad2?)/i, /(hp).+(touchpad)/i, /(hp).+(tablet)/i, /(kindle)\/([\w\.]+)/i, /\s(nook)[\w\s]+build\/(\w+)/i, /(dell)\s(strea[kpr\s\d]*[\dko])/i ], [ VENDOR, MODEL, [ TYPE, TABLET ] ], [ /(kf[A-z]+)\sbuild\/.+silk\//i ], [ MODEL, [ VENDOR, "Amazon" ], [ TYPE, TABLET ] ], [ /(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i ], [ [ MODEL, mapper.str, maps.device.amazon.model ], [ VENDOR, "Amazon" ], [ TYPE, MOBILE ] ], [ /\((ip[honed|\s\w*]+);.+(apple)/i ], [ MODEL, VENDOR, [ TYPE, MOBILE ] ], [ /\((ip[honed|\s\w*]+);/i ], [ MODEL, [ VENDOR, "Apple" ], [ TYPE, MOBILE ] ], [ /(blackberry)[\s-]?(\w+)/i, /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i, /(hp)\s([\w\s]+\w)/i, /(asus)-?(\w+)/i ], [ VENDOR, MODEL, [ TYPE, MOBILE ] ], [ /\(bb10;\s(\w+)/i ], [ MODEL, [ VENDOR, "BlackBerry" ], [ TYPE, MOBILE ] ], [ /android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i ], [ MODEL, [ VENDOR, "Asus" ], [ TYPE, TABLET ] ], [ /(sony)\s(tablet\s[ps])\sbuild\//i, /(sony)?(?:sgp.+)\sbuild\//i ], [ [ VENDOR, "Sony" ], [ MODEL, "Xperia Tablet" ], [ TYPE, TABLET ] ], [ /android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i ], [ MODEL, [ VENDOR, "Sony" ], [ TYPE, MOBILE ] ], [ /\s(ouya)\s/i, /(nintendo)\s([wids3u]+)/i ], [ VENDOR, MODEL, [ TYPE, CONSOLE ] ], [ /android.+;\s(shield)\sbuild/i ], [ MODEL, [ VENDOR, "Nvidia" ], [ TYPE, CONSOLE ] ], [ /(playstation\s[34portablevi]+)/i ], [ MODEL, [ VENDOR, "Sony" ], [ TYPE, CONSOLE ] ], [ /(sprint\s(\w+))/i ], [ [ VENDOR, mapper.str, maps.device.sprint.vendor ], [ MODEL, mapper.str, maps.device.sprint.model ], [ TYPE, MOBILE ] ], [ /(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i ], [ VENDOR, MODEL, [ TYPE, TABLET ] ], [ /(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i, /(zte)-(\w*)/i, /(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i ], [ VENDOR, [ MODEL, /_/g, " " ], [ TYPE, MOBILE ] ], [ /(nexus\s9)/i ], [ MODEL, [ VENDOR, "HTC" ], [ TYPE, TABLET ] ], [ /d\/huawei([\w\s-]+)[;\)]/i, /(nexus\s6p)/i ], [ MODEL, [ VENDOR, "Huawei" ], [ TYPE, MOBILE ] ], [ /(microsoft);\s(lumia[\s\w]+)/i ], [ VENDOR, MODEL, [ TYPE, MOBILE ] ], [ /[\s\(;](xbox(?:\sone)?)[\s\);]/i ], [ MODEL, [ VENDOR, "Microsoft" ], [ TYPE, CONSOLE ] ], [ /(kin\.[onetw]{3})/i ], [ [ MODEL, /\./g, " " ], [ VENDOR, "Microsoft" ], [ TYPE, MOBILE ] ], [ /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i, /mot[\s-]?(\w*)/i, /(XT\d{3,4}) build\//i, /(nexus\s6)/i ], [ MODEL, [ VENDOR, "Motorola" ], [ TYPE, MOBILE ] ], [ /android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i ], [ MODEL, [ VENDOR, "Motorola" ], [ TYPE, TABLET ] ], [ /hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i ], [ [ VENDOR, util.trim ], [ MODEL, util.trim ], [ TYPE, SMARTTV ] ], [ /hbbtv.+maple;(\d+)/i ], [ [ MODEL, /^/, "SmartTV" ], [ VENDOR, "Samsung" ], [ TYPE, SMARTTV ] ], [ /\(dtv[\);].+(aquos)/i ], [ MODEL, [ VENDOR, "Sharp" ], [ TYPE, SMARTTV ] ], [ /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i, /((SM-T\w+))/i ], [ [ VENDOR, "Samsung" ], MODEL, [ TYPE, TABLET ] ], [ /smart-tv.+(samsung)/i ], [ VENDOR, [ TYPE, SMARTTV ], MODEL ], [ /((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i, /(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i, /sec-((sgh\w+))/i ], [ [ VENDOR, "Samsung" ], MODEL, [ TYPE, MOBILE ] ], [ /sie-(\w*)/i ], [ MODEL, [ VENDOR, "Siemens" ], [ TYPE, MOBILE ] ], [ /(maemo|nokia).*(n900|lumia\s\d+)/i, /(nokia)[\s_-]?([\w-]*)/i ], [ [ VENDOR, "Nokia" ], MODEL, [ TYPE, MOBILE ] ], [ /android\s3\.[\s\w;-]{10}(a\d{3})/i ], [ MODEL, [ VENDOR, "Acer" ], [ TYPE, TABLET ] ], [ /android.+([vl]k\-?\d{3})\s+build/i ], [ MODEL, [ VENDOR, "LG" ], [ TYPE, TABLET ] ], [ /android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i ], [ [ VENDOR, "LG" ], MODEL, [ TYPE, TABLET ] ], [ /(lg) netcast\.tv/i ], [ VENDOR, MODEL, [ TYPE, SMARTTV ] ], [ /(nexus\s[45])/i, /lg[e;\s\/-]+(\w*)/i, /android.+lg(\-?[\d\w]+)\s+build/i ], [ MODEL, [ VENDOR, "LG" ], [ TYPE, MOBILE ] ], [ /android.+(ideatab[a-z0-9\-\s]+)/i ], [ MODEL, [ VENDOR, "Lenovo" ], [ TYPE, TABLET ] ], [ /linux;.+((jolla));/i ], [ VENDOR, MODEL, [ TYPE, MOBILE ] ], [ /((pebble))app\/[\d\.]+\s/i ], [ VENDOR, MODEL, [ TYPE, WEARABLE ] ], [ /android.+;\s(oppo)\s?([\w\s]+)\sbuild/i ], [ VENDOR, MODEL, [ TYPE, MOBILE ] ], [ /crkey/i ], [ [ MODEL, "Chromecast" ], [ VENDOR, "Google" ] ], [ /android.+;\s(glass)\s\d/i ], [ MODEL, [ VENDOR, "Google" ], [ TYPE, WEARABLE ] ], [ /android.+;\s(pixel c)\s/i ], [ MODEL, [ VENDOR, "Google" ], [ TYPE, TABLET ] ], [ /android.+;\s(pixel xl|pixel)\s/i ], [ MODEL, [ VENDOR, "Google" ], [ TYPE, MOBILE ] ], [ /android.+;\s(\w+)\s+build\/hm\1/i, /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i, /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i, /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i ], [ [ MODEL, /_/g, " " ], [ VENDOR, "Xiaomi" ], [ TYPE, MOBILE ] ], [ /android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i ], [ [ MODEL, /_/g, " " ], [ VENDOR, "Xiaomi" ], [ TYPE, TABLET ] ], [ /android.+;\s(m[1-5]\snote)\sbuild/i ], [ MODEL, [ VENDOR, "Meizu" ], [ TYPE, TABLET ] ], [ /android.+a000(1)\s+build/i, /android.+oneplus\s(a\d{4})\s+build/i ], [ MODEL, [ VENDOR, "OnePlus" ], [ TYPE, MOBILE ] ], [ /android.+[;\/]\s*(RCT[\d\w]+)\s+build/i ], [ MODEL, [ VENDOR, "RCA" ], [ TYPE, TABLET ] ], [ /android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i ], [ MODEL, [ VENDOR, "Dell" ], [ TYPE, TABLET ] ], [ /android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i ], [ MODEL, [ VENDOR, "Verizon" ], [ TYPE, TABLET ] ], [ /android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i ], [ [ VENDOR, "Barnes & Noble" ], MODEL, [ TYPE, TABLET ] ], [ /android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i ], [ MODEL, [ VENDOR, "NuVision" ], [ TYPE, TABLET ] ], [ /android.+;\s(k88)\sbuild/i ], [ MODEL, [ VENDOR, "ZTE" ], [ TYPE, TABLET ] ], [ /android.+[;\/]\s*(gen\d{3})\s+build.*49h/i ], [ MODEL, [ VENDOR, "Swiss" ], [ TYPE, MOBILE ] ], [ /android.+[;\/]\s*(zur\d{3})\s+build/i ], [ MODEL, [ VENDOR, "Swiss" ], [ TYPE, TABLET ] ], [ /android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i ], [ MODEL, [ VENDOR, "Zeki" ], [ TYPE, TABLET ] ], [ /(android).+[;\/]\s+([YR]\d{2})\s+build/i, /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i ], [ [ VENDOR, "Dragon Touch" ], MODEL, [ TYPE, TABLET ] ], [ /android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i ], [ MODEL, [ VENDOR, "Insignia" ], [ TYPE, TABLET ] ], [ /android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i ], [ MODEL, [ VENDOR, "NextBook" ], [ TYPE, TABLET ] ], [ /android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i ], [ [ VENDOR, "Voice" ], MODEL, [ TYPE, MOBILE ] ], [ /android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i ], [ [ VENDOR, "LvTel" ], MODEL, [ TYPE, MOBILE ] ], [ /android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i ], [ MODEL, [ VENDOR, "Envizen" ], [ TYPE, TABLET ] ], [ /android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i ], [ VENDOR, MODEL, [ TYPE, TABLET ] ], [ /android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i ], [ MODEL, [ VENDOR, "MachSpeed" ], [ TYPE, TABLET ] ], [ /android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i ], [ VENDOR, MODEL, [ TYPE, TABLET ] ], [ /android.+[;\/]\s*TU_(1491)\s+build/i ], [ MODEL, [ VENDOR, "Rotor" ], [ TYPE, TABLET ] ], [ /android.+(KS(.+))\s+build/i ], [ MODEL, [ VENDOR, "Amazon" ], [ TYPE, TABLET ] ], [ /android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i ], [ VENDOR, MODEL, [ TYPE, TABLET ] ], [ /\s(tablet|tab)[;\/]/i, /\s(mobile)(?:[;\/]|\ssafari)/i ], [ [ TYPE, util.lowerize ], VENDOR, MODEL ], [ /(android[\w\.\s\-]{0,9});.+build/i ], [ MODEL, [ VENDOR, "Generic" ] ] ],
                    engine: [ [ /windows.+\sedge\/([\w\.]+)/i ], [ VERSION, [ NAME, "EdgeHTML" ] ], [ /(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i, /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i, /(icab)[\/\s]([23]\.[\d\.]+)/i ], [ NAME, VERSION ], [ /rv\:([\w\.]{1,9}).+(gecko)/i ], [ VERSION, NAME ] ],
                    os: [ [ /microsoft\s(windows)\s(vista|xp)/i ], [ NAME, VERSION ], [ /(windows)\snt\s6\.2;\s(arm)/i, /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i, /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i ], [ NAME, [ VERSION, mapper.str, maps.os.windows.version ] ], [ /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i ], [ [ NAME, "Windows" ], [ VERSION, mapper.str, maps.os.windows.version ] ], [ /\((bb)(10);/i ], [ [ NAME, "BlackBerry" ], VERSION ], [ /(blackberry)\w*\/?([\w\.]*)/i, /(tizen)[\/\s]([\w\.]+)/i, /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]*)/i, /linux;.+(sailfish);/i ], [ NAME, VERSION ], [ /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i ], [ [ NAME, "Symbian" ], VERSION ], [ /\((series40);/i ], [ NAME ], [ /mozilla.+\(mobile;.+gecko.+firefox/i ], [ [ NAME, "Firefox OS" ], VERSION ], [ /(nintendo|playstation)\s([wids34portablevu]+)/i, /(mint)[\/\s\(]?(\w*)/i, /(mageia|vectorlinux)[;\s]/i, /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i, /(hurd|linux)\s?([\w\.]*)/i, /(gnu)\s?([\w\.]*)/i ], [ NAME, VERSION ], [ /(cros)\s[\w]+\s([\w\.]+\w)/i ], [ [ NAME, "Chromium OS" ], VERSION ], [ /(sunos)\s?([\w\.\d]*)/i ], [ [ NAME, "Solaris" ], VERSION ], [ /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i ], [ NAME, VERSION ], [ /(haiku)\s(\w+)/i ], [ NAME, VERSION ], [ /cfnetwork\/.+darwin/i, /ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i ], [ [ VERSION, /_/g, "." ], [ NAME, "iOS" ] ], [ /(mac\sos\sx)\s?([\w\s\.]*)/i, /(macintosh|mac(?=_powerpc)\s)/i ], [ [ NAME, "Mac OS" ], [ VERSION, /_/g, "." ] ], [ /((?:open)?solaris)[\/\s-]?([\w\.]*)/i, /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i, /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i, /(unix)\s?([\w\.]*)/i ], [ NAME, VERSION ] ]
                };
                var UAParser = function(uastring, extensions) {
                    if (typeof uastring === "object") {
                        extensions = uastring;
                        uastring = undefined;
                    }
                    if (!(this instanceof UAParser)) {
                        return new UAParser(uastring, extensions).getResult();
                    }
                    var ua = uastring || (window && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : EMPTY);
                    var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;
                    this.getBrowser = function() {
                        var browser = {
                            name: undefined,
                            version: undefined
                        };
                        mapper.rgx.call(browser, ua, rgxmap.browser);
                        browser.major = util.major(browser.version);
                        return browser;
                    };
                    this.getCPU = function() {
                        var cpu = {
                            architecture: undefined
                        };
                        mapper.rgx.call(cpu, ua, rgxmap.cpu);
                        return cpu;
                    };
                    this.getDevice = function() {
                        var device = {
                            vendor: undefined,
                            model: undefined,
                            type: undefined
                        };
                        mapper.rgx.call(device, ua, rgxmap.device);
                        return device;
                    };
                    this.getEngine = function() {
                        var engine = {
                            name: undefined,
                            version: undefined
                        };
                        mapper.rgx.call(engine, ua, rgxmap.engine);
                        return engine;
                    };
                    this.getOS = function() {
                        var os = {
                            name: undefined,
                            version: undefined
                        };
                        mapper.rgx.call(os, ua, rgxmap.os);
                        return os;
                    };
                    this.getResult = function() {
                        return {
                            ua: this.getUA(),
                            browser: this.getBrowser(),
                            engine: this.getEngine(),
                            os: this.getOS(),
                            device: this.getDevice(),
                            cpu: this.getCPU()
                        };
                    };
                    this.getUA = function() {
                        return ua;
                    };
                    this.setUA = function(uastring) {
                        ua = uastring;
                        return this;
                    };
                    return this;
                };
                UAParser.VERSION = LIBVERSION;
                UAParser.BROWSER = {
                    NAME: NAME,
                    MAJOR: MAJOR,
                    VERSION: VERSION
                };
                UAParser.CPU = {
                    ARCHITECTURE: ARCHITECTURE
                };
                UAParser.DEVICE = {
                    MODEL: MODEL,
                    VENDOR: VENDOR,
                    TYPE: TYPE,
                    CONSOLE: CONSOLE,
                    MOBILE: MOBILE,
                    SMARTTV: SMARTTV,
                    TABLET: TABLET,
                    WEARABLE: WEARABLE,
                    EMBEDDED: EMBEDDED
                };
                UAParser.ENGINE = {
                    NAME: NAME,
                    VERSION: VERSION
                };
                UAParser.OS = {
                    NAME: NAME,
                    VERSION: VERSION
                };
                if (typeof exports !== UNDEF_TYPE) {
                    if (typeof module !== UNDEF_TYPE && module.exports) {
                        exports = module.exports = UAParser;
                    }
                    exports.UAParser = UAParser;
                } else {
                    if ("function" === FUNC_TYPE && __webpack_require__(2)) {
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                            return UAParser;
                        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    } else if (window) {
                        window.UAParser = UAParser;
                    }
                }
                var $ = window && (window.jQuery || window.Zepto);
                if (typeof $ !== UNDEF_TYPE) {
                    var parser = new UAParser();
                    $.ua = parser.getResult();
                    $.ua.get = function() {
                        return parser.getUA();
                    };
                    $.ua.set = function(uastring) {
                        parser.setUA(uastring);
                        var result = parser.getResult();
                        for (var prop in result) {
                            $.ua[prop] = result[prop];
                        }
                    };
                }
            })(typeof window === "object" ? window : this);
        }, function(module, exports) {
            (function(__webpack_amd_options__) {
                module.exports = __webpack_amd_options__;
            }).call(exports, {});
        }, function(module, exports, __webpack_require__) {
            "use strict";
            var DEVICE_TYPES = {
                MOBILE: "mobile",
                TABLET: "tablet",
                SMART_TV: "smarttv",
                CONSOLE: "console",
                WEARABLE: "wearable",
                BROWSER: undefined
            };
            var BROWSER_TYPES = {
                CHROME: "Chrome",
                FIREFOX: "Firefox",
                OPERA: "Opera",
                YANDEX: "Yandex",
                SAFARI: "Safari",
                INTERNET_EXPLORER: "Internet Explorer",
                EDGE: "Edge",
                CHROMIUM: "Chromium",
                IE: "IE",
                MOBILE_SAFARI: "Mobile Safari"
            };
            var OS_TYPES = {
                IOS: "iOS",
                ANDROID: "Android",
                WINDOWS_PHONE: "Windows Phone"
            };
            var defaultData = {
                isMobile: false,
                isTablet: false,
                isBrowser: false,
                isSmartTV: false,
                isConsole: false,
                isWearable: false
            };
            module.exports = {
                BROWSER_TYPES: BROWSER_TYPES,
                DEVICE_TYPES: DEVICE_TYPES,
                OS_TYPES: OS_TYPES,
                defaultData: defaultData
            };
        } ]);
    }, {} ],
    117: [ function(require, module, exports) {
        "use strict";
        var assign = require("./lib/utils/common").assign;
        var deflate = require("./lib/deflate");
        var inflate = require("./lib/inflate");
        var constants = require("./lib/zlib/constants");
        var pako = {};
        assign(pako, deflate, inflate, constants);
        module.exports = pako;
    }, {
        "./lib/deflate": 118,
        "./lib/inflate": 119,
        "./lib/utils/common": 120,
        "./lib/zlib/constants": 123
    } ],
    118: [ function(require, module, exports) {
        "use strict";
        var zlib_deflate = require("./zlib/deflate");
        var utils = require("./utils/common");
        var strings = require("./utils/strings");
        var msg = require("./zlib/messages");
        var ZStream = require("./zlib/zstream");
        var toString = Object.prototype.toString;
        var Z_NO_FLUSH = 0;
        var Z_FINISH = 4;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_SYNC_FLUSH = 2;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_DEFLATED = 8;
        function Deflate(options) {
            if (!(this instanceof Deflate)) return new Deflate(options);
            this.options = utils.assign({
                level: Z_DEFAULT_COMPRESSION,
                method: Z_DEFLATED,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: Z_DEFAULT_STRATEGY,
                to: ""
            }, options || {});
            var opt = this.options;
            if (opt.raw && opt.windowBits > 0) {
                opt.windowBits = -opt.windowBits;
            } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
                opt.windowBits += 16;
            }
            this.err = 0;
            this.msg = "";
            this.ended = false;
            this.chunks = [];
            this.strm = new ZStream();
            this.strm.avail_out = 0;
            var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
            if (status !== Z_OK) {
                throw new Error(msg[status]);
            }
            if (opt.header) {
                zlib_deflate.deflateSetHeader(this.strm, opt.header);
            }
            if (opt.dictionary) {
                var dict;
                if (typeof opt.dictionary === "string") {
                    dict = strings.string2buf(opt.dictionary);
                } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
                    dict = new Uint8Array(opt.dictionary);
                } else {
                    dict = opt.dictionary;
                }
                status = zlib_deflate.deflateSetDictionary(this.strm, dict);
                if (status !== Z_OK) {
                    throw new Error(msg[status]);
                }
                this._dict_set = true;
            }
        }
        Deflate.prototype.push = function(data, mode) {
            var strm = this.strm;
            var chunkSize = this.options.chunkSize;
            var status, _mode;
            if (this.ended) {
                return false;
            }
            _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
            if (typeof data === "string") {
                strm.input = strings.string2buf(data);
            } else if (toString.call(data) === "[object ArrayBuffer]") {
                strm.input = new Uint8Array(data);
            } else {
                strm.input = data;
            }
            strm.next_in = 0;
            strm.avail_in = strm.input.length;
            do {
                if (strm.avail_out === 0) {
                    strm.output = new utils.Buf8(chunkSize);
                    strm.next_out = 0;
                    strm.avail_out = chunkSize;
                }
                status = zlib_deflate.deflate(strm, _mode);
                if (status !== Z_STREAM_END && status !== Z_OK) {
                    this.onEnd(status);
                    this.ended = true;
                    return false;
                }
                if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
                    if (this.options.to === "string") {
                        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
                    } else {
                        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                    }
                }
            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
            if (_mode === Z_FINISH) {
                status = zlib_deflate.deflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return status === Z_OK;
            }
            if (_mode === Z_SYNC_FLUSH) {
                this.onEnd(Z_OK);
                strm.avail_out = 0;
                return true;
            }
            return true;
        };
        Deflate.prototype.onData = function(chunk) {
            this.chunks.push(chunk);
        };
        Deflate.prototype.onEnd = function(status) {
            if (status === Z_OK) {
                if (this.options.to === "string") {
                    this.result = this.chunks.join("");
                } else {
                    this.result = utils.flattenChunks(this.chunks);
                }
            }
            this.chunks = [];
            this.err = status;
            this.msg = this.strm.msg;
        };
        function deflate(input, options) {
            var deflator = new Deflate(options);
            deflator.push(input, true);
            if (deflator.err) {
                throw deflator.msg || msg[deflator.err];
            }
            return deflator.result;
        }
        function deflateRaw(input, options) {
            options = options || {};
            options.raw = true;
            return deflate(input, options);
        }
        function gzip(input, options) {
            options = options || {};
            options.gzip = true;
            return deflate(input, options);
        }
        exports.Deflate = Deflate;
        exports.deflate = deflate;
        exports.deflateRaw = deflateRaw;
        exports.gzip = gzip;
    }, {
        "./utils/common": 120,
        "./utils/strings": 121,
        "./zlib/deflate": 125,
        "./zlib/messages": 130,
        "./zlib/zstream": 132
    } ],
    119: [ function(require, module, exports) {
        "use strict";
        var zlib_inflate = require("./zlib/inflate");
        var utils = require("./utils/common");
        var strings = require("./utils/strings");
        var c = require("./zlib/constants");
        var msg = require("./zlib/messages");
        var ZStream = require("./zlib/zstream");
        var GZheader = require("./zlib/gzheader");
        var toString = Object.prototype.toString;
        function Inflate(options) {
            if (!(this instanceof Inflate)) return new Inflate(options);
            this.options = utils.assign({
                chunkSize: 16384,
                windowBits: 0,
                to: ""
            }, options || {});
            var opt = this.options;
            if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
                opt.windowBits = -opt.windowBits;
                if (opt.windowBits === 0) {
                    opt.windowBits = -15;
                }
            }
            if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
                opt.windowBits += 32;
            }
            if (opt.windowBits > 15 && opt.windowBits < 48) {
                if ((opt.windowBits & 15) === 0) {
                    opt.windowBits |= 15;
                }
            }
            this.err = 0;
            this.msg = "";
            this.ended = false;
            this.chunks = [];
            this.strm = new ZStream();
            this.strm.avail_out = 0;
            var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
            if (status !== c.Z_OK) {
                throw new Error(msg[status]);
            }
            this.header = new GZheader();
            zlib_inflate.inflateGetHeader(this.strm, this.header);
        }
        Inflate.prototype.push = function(data, mode) {
            var strm = this.strm;
            var chunkSize = this.options.chunkSize;
            var dictionary = this.options.dictionary;
            var status, _mode;
            var next_out_utf8, tail, utf8str;
            var dict;
            var allowBufError = false;
            if (this.ended) {
                return false;
            }
            _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
            if (typeof data === "string") {
                strm.input = strings.binstring2buf(data);
            } else if (toString.call(data) === "[object ArrayBuffer]") {
                strm.input = new Uint8Array(data);
            } else {
                strm.input = data;
            }
            strm.next_in = 0;
            strm.avail_in = strm.input.length;
            do {
                if (strm.avail_out === 0) {
                    strm.output = new utils.Buf8(chunkSize);
                    strm.next_out = 0;
                    strm.avail_out = chunkSize;
                }
                status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
                if (status === c.Z_NEED_DICT && dictionary) {
                    if (typeof dictionary === "string") {
                        dict = strings.string2buf(dictionary);
                    } else if (toString.call(dictionary) === "[object ArrayBuffer]") {
                        dict = new Uint8Array(dictionary);
                    } else {
                        dict = dictionary;
                    }
                    status = zlib_inflate.inflateSetDictionary(this.strm, dict);
                }
                if (status === c.Z_BUF_ERROR && allowBufError === true) {
                    status = c.Z_OK;
                    allowBufError = false;
                }
                if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                    this.onEnd(status);
                    this.ended = true;
                    return false;
                }
                if (strm.next_out) {
                    if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
                        if (this.options.to === "string") {
                            next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                            tail = strm.next_out - next_out_utf8;
                            utf8str = strings.buf2string(strm.output, next_out_utf8);
                            strm.next_out = tail;
                            strm.avail_out = chunkSize - tail;
                            if (tail) {
                                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                            }
                            this.onData(utf8str);
                        } else {
                            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                        }
                    }
                }
                if (strm.avail_in === 0 && strm.avail_out === 0) {
                    allowBufError = true;
                }
            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
            if (status === c.Z_STREAM_END) {
                _mode = c.Z_FINISH;
            }
            if (_mode === c.Z_FINISH) {
                status = zlib_inflate.inflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return status === c.Z_OK;
            }
            if (_mode === c.Z_SYNC_FLUSH) {
                this.onEnd(c.Z_OK);
                strm.avail_out = 0;
                return true;
            }
            return true;
        };
        Inflate.prototype.onData = function(chunk) {
            this.chunks.push(chunk);
        };
        Inflate.prototype.onEnd = function(status) {
            if (status === c.Z_OK) {
                if (this.options.to === "string") {
                    this.result = this.chunks.join("");
                } else {
                    this.result = utils.flattenChunks(this.chunks);
                }
            }
            this.chunks = [];
            this.err = status;
            this.msg = this.strm.msg;
        };
        function inflate(input, options) {
            var inflator = new Inflate(options);
            inflator.push(input, true);
            if (inflator.err) {
                throw inflator.msg || msg[inflator.err];
            }
            return inflator.result;
        }
        function inflateRaw(input, options) {
            options = options || {};
            options.raw = true;
            return inflate(input, options);
        }
        exports.Inflate = Inflate;
        exports.inflate = inflate;
        exports.inflateRaw = inflateRaw;
        exports.ungzip = inflate;
    }, {
        "./utils/common": 120,
        "./utils/strings": 121,
        "./zlib/constants": 123,
        "./zlib/gzheader": 126,
        "./zlib/inflate": 128,
        "./zlib/messages": 130,
        "./zlib/zstream": 132
    } ],
    120: [ function(require, module, exports) {
        "use strict";
        var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
        function _has(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key);
        }
        exports.assign = function(obj) {
            var sources = Array.prototype.slice.call(arguments, 1);
            while (sources.length) {
                var source = sources.shift();
                if (!source) {
                    continue;
                }
                if (typeof source !== "object") {
                    throw new TypeError(source + "must be non-object");
                }
                for (var p in source) {
                    if (_has(source, p)) {
                        obj[p] = source[p];
                    }
                }
            }
            return obj;
        };
        exports.shrinkBuf = function(buf, size) {
            if (buf.length === size) {
                return buf;
            }
            if (buf.subarray) {
                return buf.subarray(0, size);
            }
            buf.length = size;
            return buf;
        };
        var fnTyped = {
            arraySet: function(dest, src, src_offs, len, dest_offs) {
                if (src.subarray && dest.subarray) {
                    dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                    return;
                }
                for (var i = 0; i < len; i++) {
                    dest[dest_offs + i] = src[src_offs + i];
                }
            },
            flattenChunks: function(chunks) {
                var i, l, len, pos, chunk, result;
                len = 0;
                for (i = 0, l = chunks.length; i < l; i++) {
                    len += chunks[i].length;
                }
                result = new Uint8Array(len);
                pos = 0;
                for (i = 0, l = chunks.length; i < l; i++) {
                    chunk = chunks[i];
                    result.set(chunk, pos);
                    pos += chunk.length;
                }
                return result;
            }
        };
        var fnUntyped = {
            arraySet: function(dest, src, src_offs, len, dest_offs) {
                for (var i = 0; i < len; i++) {
                    dest[dest_offs + i] = src[src_offs + i];
                }
            },
            flattenChunks: function(chunks) {
                return [].concat.apply([], chunks);
            }
        };
        exports.setTyped = function(on) {
            if (on) {
                exports.Buf8 = Uint8Array;
                exports.Buf16 = Uint16Array;
                exports.Buf32 = Int32Array;
                exports.assign(exports, fnTyped);
            } else {
                exports.Buf8 = Array;
                exports.Buf16 = Array;
                exports.Buf32 = Array;
                exports.assign(exports, fnUntyped);
            }
        };
        exports.setTyped(TYPED_OK);
    }, {} ],
    121: [ function(require, module, exports) {
        "use strict";
        var utils = require("./common");
        var STR_APPLY_OK = true;
        var STR_APPLY_UIA_OK = true;
        try {
            String.fromCharCode.apply(null, [ 0 ]);
        } catch (__) {
            STR_APPLY_OK = false;
        }
        try {
            String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (__) {
            STR_APPLY_UIA_OK = false;
        }
        var _utf8len = new utils.Buf8(256);
        for (var q = 0; q < 256; q++) {
            _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
        }
        _utf8len[254] = _utf8len[254] = 1;
        exports.string2buf = function(str) {
            var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
            for (m_pos = 0; m_pos < str_len; m_pos++) {
                c = str.charCodeAt(m_pos);
                if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                    c2 = str.charCodeAt(m_pos + 1);
                    if ((c2 & 64512) === 56320) {
                        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                        m_pos++;
                    }
                }
                buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
            }
            buf = new utils.Buf8(buf_len);
            for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
                c = str.charCodeAt(m_pos);
                if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                    c2 = str.charCodeAt(m_pos + 1);
                    if ((c2 & 64512) === 56320) {
                        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                        m_pos++;
                    }
                }
                if (c < 128) {
                    buf[i++] = c;
                } else if (c < 2048) {
                    buf[i++] = 192 | c >>> 6;
                    buf[i++] = 128 | c & 63;
                } else if (c < 65536) {
                    buf[i++] = 224 | c >>> 12;
                    buf[i++] = 128 | c >>> 6 & 63;
                    buf[i++] = 128 | c & 63;
                } else {
                    buf[i++] = 240 | c >>> 18;
                    buf[i++] = 128 | c >>> 12 & 63;
                    buf[i++] = 128 | c >>> 6 & 63;
                    buf[i++] = 128 | c & 63;
                }
            }
            return buf;
        };
        function buf2binstring(buf, len) {
            if (len < 65534) {
                if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
                    return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
                }
            }
            var result = "";
            for (var i = 0; i < len; i++) {
                result += String.fromCharCode(buf[i]);
            }
            return result;
        }
        exports.buf2binstring = function(buf) {
            return buf2binstring(buf, buf.length);
        };
        exports.binstring2buf = function(str) {
            var buf = new utils.Buf8(str.length);
            for (var i = 0, len = buf.length; i < len; i++) {
                buf[i] = str.charCodeAt(i);
            }
            return buf;
        };
        exports.buf2string = function(buf, max) {
            var i, out, c, c_len;
            var len = max || buf.length;
            var utf16buf = new Array(len * 2);
            for (out = 0, i = 0; i < len; ) {
                c = buf[i++];
                if (c < 128) {
                    utf16buf[out++] = c;
                    continue;
                }
                c_len = _utf8len[c];
                if (c_len > 4) {
                    utf16buf[out++] = 65533;
                    i += c_len - 1;
                    continue;
                }
                c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
                while (c_len > 1 && i < len) {
                    c = c << 6 | buf[i++] & 63;
                    c_len--;
                }
                if (c_len > 1) {
                    utf16buf[out++] = 65533;
                    continue;
                }
                if (c < 65536) {
                    utf16buf[out++] = c;
                } else {
                    c -= 65536;
                    utf16buf[out++] = 55296 | c >> 10 & 1023;
                    utf16buf[out++] = 56320 | c & 1023;
                }
            }
            return buf2binstring(utf16buf, out);
        };
        exports.utf8border = function(buf, max) {
            var pos;
            max = max || buf.length;
            if (max > buf.length) {
                max = buf.length;
            }
            pos = max - 1;
            while (pos >= 0 && (buf[pos] & 192) === 128) {
                pos--;
            }
            if (pos < 0) {
                return max;
            }
            if (pos === 0) {
                return max;
            }
            return pos + _utf8len[buf[pos]] > max ? pos : max;
        };
    }, {
        "./common": 120
    } ],
    122: [ function(require, module, exports) {
        "use strict";
        function adler32(adler, buf, len, pos) {
            var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
            while (len !== 0) {
                n = len > 2e3 ? 2e3 : len;
                len -= n;
                do {
                    s1 = s1 + buf[pos++] | 0;
                    s2 = s2 + s1 | 0;
                } while (--n);
                s1 %= 65521;
                s2 %= 65521;
            }
            return s1 | s2 << 16 | 0;
        }
        module.exports = adler32;
    }, {} ],
    123: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_BUF_ERROR: -5,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            Z_BINARY: 0,
            Z_TEXT: 1,
            Z_UNKNOWN: 2,
            Z_DEFLATED: 8
        };
    }, {} ],
    124: [ function(require, module, exports) {
        "use strict";
        function makeTable() {
            var c, table = [];
            for (var n = 0; n < 256; n++) {
                c = n;
                for (var k = 0; k < 8; k++) {
                    c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
                }
                table[n] = c;
            }
            return table;
        }
        var crcTable = makeTable();
        function crc32(crc, buf, len, pos) {
            var t = crcTable, end = pos + len;
            crc ^= -1;
            for (var i = pos; i < end; i++) {
                crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
            }
            return crc ^ -1;
        }
        module.exports = crc32;
    }, {} ],
    125: [ function(require, module, exports) {
        "use strict";
        var utils = require("../utils/common");
        var trees = require("./trees");
        var adler32 = require("./adler32");
        var crc32 = require("./crc32");
        var msg = require("./messages");
        var Z_NO_FLUSH = 0;
        var Z_PARTIAL_FLUSH = 1;
        var Z_FULL_FLUSH = 3;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_BUF_ERROR = -5;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_FILTERED = 1;
        var Z_HUFFMAN_ONLY = 2;
        var Z_RLE = 3;
        var Z_FIXED = 4;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_UNKNOWN = 2;
        var Z_DEFLATED = 8;
        var MAX_MEM_LEVEL = 9;
        var MAX_WBITS = 15;
        var DEF_MEM_LEVEL = 8;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
        var PRESET_DICT = 32;
        var INIT_STATE = 42;
        var EXTRA_STATE = 69;
        var NAME_STATE = 73;
        var COMMENT_STATE = 91;
        var HCRC_STATE = 103;
        var BUSY_STATE = 113;
        var FINISH_STATE = 666;
        var BS_NEED_MORE = 1;
        var BS_BLOCK_DONE = 2;
        var BS_FINISH_STARTED = 3;
        var BS_FINISH_DONE = 4;
        var OS_CODE = 3;
        function err(strm, errorCode) {
            strm.msg = msg[errorCode];
            return errorCode;
        }
        function rank(f) {
            return (f << 1) - (f > 4 ? 9 : 0);
        }
        function zero(buf) {
            var len = buf.length;
            while (--len >= 0) {
                buf[len] = 0;
            }
        }
        function flush_pending(strm) {
            var s = strm.state;
            var len = s.pending;
            if (len > strm.avail_out) {
                len = strm.avail_out;
            }
            if (len === 0) {
                return;
            }
            utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
            strm.next_out += len;
            s.pending_out += len;
            strm.total_out += len;
            strm.avail_out -= len;
            s.pending -= len;
            if (s.pending === 0) {
                s.pending_out = 0;
            }
        }
        function flush_block_only(s, last) {
            trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
            s.block_start = s.strstart;
            flush_pending(s.strm);
        }
        function put_byte(s, b) {
            s.pending_buf[s.pending++] = b;
        }
        function putShortMSB(s, b) {
            s.pending_buf[s.pending++] = b >>> 8 & 255;
            s.pending_buf[s.pending++] = b & 255;
        }
        function read_buf(strm, buf, start, size) {
            var len = strm.avail_in;
            if (len > size) {
                len = size;
            }
            if (len === 0) {
                return 0;
            }
            strm.avail_in -= len;
            utils.arraySet(buf, strm.input, strm.next_in, len, start);
            if (strm.state.wrap === 1) {
                strm.adler = adler32(strm.adler, buf, len, start);
            } else if (strm.state.wrap === 2) {
                strm.adler = crc32(strm.adler, buf, len, start);
            }
            strm.next_in += len;
            strm.total_in += len;
            return len;
        }
        function longest_match(s, cur_match) {
            var chain_length = s.max_chain_length;
            var scan = s.strstart;
            var match;
            var len;
            var best_len = s.prev_length;
            var nice_match = s.nice_match;
            var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
            var _win = s.window;
            var wmask = s.w_mask;
            var prev = s.prev;
            var strend = s.strstart + MAX_MATCH;
            var scan_end1 = _win[scan + best_len - 1];
            var scan_end = _win[scan + best_len];
            if (s.prev_length >= s.good_match) {
                chain_length >>= 2;
            }
            if (nice_match > s.lookahead) {
                nice_match = s.lookahead;
            }
            do {
                match = cur_match;
                if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                    continue;
                }
                scan += 2;
                match++;
                do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                len = MAX_MATCH - (strend - scan);
                scan = strend - MAX_MATCH;
                if (len > best_len) {
                    s.match_start = cur_match;
                    best_len = len;
                    if (len >= nice_match) {
                        break;
                    }
                    scan_end1 = _win[scan + best_len - 1];
                    scan_end = _win[scan + best_len];
                }
            } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
            if (best_len <= s.lookahead) {
                return best_len;
            }
            return s.lookahead;
        }
        function fill_window(s) {
            var _w_size = s.w_size;
            var p, n, m, more, str;
            do {
                more = s.window_size - s.lookahead - s.strstart;
                if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                    utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                    s.match_start -= _w_size;
                    s.strstart -= _w_size;
                    s.block_start -= _w_size;
                    n = s.hash_size;
                    p = n;
                    do {
                        m = s.head[--p];
                        s.head[p] = m >= _w_size ? m - _w_size : 0;
                    } while (--n);
                    n = _w_size;
                    p = n;
                    do {
                        m = s.prev[--p];
                        s.prev[p] = m >= _w_size ? m - _w_size : 0;
                    } while (--n);
                    more += _w_size;
                }
                if (s.strm.avail_in === 0) {
                    break;
                }
                n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
                s.lookahead += n;
                if (s.lookahead + s.insert >= MIN_MATCH) {
                    str = s.strstart - s.insert;
                    s.ins_h = s.window[str];
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
                    while (s.insert) {
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                        s.prev[str & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = str;
                        str++;
                        s.insert--;
                        if (s.lookahead + s.insert < MIN_MATCH) {
                            break;
                        }
                    }
                }
            } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
        }
        function deflate_stored(s, flush) {
            var max_block_size = 65535;
            if (max_block_size > s.pending_buf_size - 5) {
                max_block_size = s.pending_buf_size - 5;
            }
            for (;;) {
                if (s.lookahead <= 1) {
                    fill_window(s);
                    if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                        break;
                    }
                }
                s.strstart += s.lookahead;
                s.lookahead = 0;
                var max_start = s.block_start + max_block_size;
                if (s.strstart === 0 || s.strstart >= max_start) {
                    s.lookahead = s.strstart - max_start;
                    s.strstart = max_start;
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
                if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
            }
            s.insert = 0;
            if (flush === Z_FINISH) {
                flush_block_only(s, true);
                if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                }
                return BS_FINISH_DONE;
            }
            if (s.strstart > s.block_start) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
            return BS_NEED_MORE;
        }
        function deflate_fast(s, flush) {
            var hash_head;
            var bflush;
            for (;;) {
                if (s.lookahead < MIN_LOOKAHEAD) {
                    fill_window(s);
                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                        break;
                    }
                }
                hash_head = 0;
                if (s.lookahead >= MIN_MATCH) {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                }
                if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                    s.match_length = longest_match(s, hash_head);
                }
                if (s.match_length >= MIN_MATCH) {
                    bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                    s.lookahead -= s.match_length;
                    if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                        s.match_length--;
                        do {
                            s.strstart++;
                            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                            s.head[s.ins_h] = s.strstart;
                        } while (--s.match_length !== 0);
                        s.strstart++;
                    } else {
                        s.strstart += s.match_length;
                        s.match_length = 0;
                        s.ins_h = s.window[s.strstart];
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
                    }
                } else {
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                    s.lookahead--;
                    s.strstart++;
                }
                if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
            }
            s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
            if (flush === Z_FINISH) {
                flush_block_only(s, true);
                if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                }
                return BS_FINISH_DONE;
            }
            if (s.last_lit) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
            return BS_BLOCK_DONE;
        }
        function deflate_slow(s, flush) {
            var hash_head;
            var bflush;
            var max_insert;
            for (;;) {
                if (s.lookahead < MIN_LOOKAHEAD) {
                    fill_window(s);
                    if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                        break;
                    }
                }
                hash_head = 0;
                if (s.lookahead >= MIN_MATCH) {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                }
                s.prev_length = s.match_length;
                s.prev_match = s.match_start;
                s.match_length = MIN_MATCH - 1;
                if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                    s.match_length = longest_match(s, hash_head);
                    if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                        s.match_length = MIN_MATCH - 1;
                    }
                }
                if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                    max_insert = s.strstart + s.lookahead - MIN_MATCH;
                    bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                    s.lookahead -= s.prev_length - 1;
                    s.prev_length -= 2;
                    do {
                        if (++s.strstart <= max_insert) {
                            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                            s.head[s.ins_h] = s.strstart;
                        }
                    } while (--s.prev_length !== 0);
                    s.match_available = 0;
                    s.match_length = MIN_MATCH - 1;
                    s.strstart++;
                    if (bflush) {
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    }
                } else if (s.match_available) {
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                    if (bflush) {
                        flush_block_only(s, false);
                    }
                    s.strstart++;
                    s.lookahead--;
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                } else {
                    s.match_available = 1;
                    s.strstart++;
                    s.lookahead--;
                }
            }
            if (s.match_available) {
                bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                s.match_available = 0;
            }
            s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
            if (flush === Z_FINISH) {
                flush_block_only(s, true);
                if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                }
                return BS_FINISH_DONE;
            }
            if (s.last_lit) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
            return BS_BLOCK_DONE;
        }
        function deflate_rle(s, flush) {
            var bflush;
            var prev;
            var scan, strend;
            var _win = s.window;
            for (;;) {
                if (s.lookahead <= MAX_MATCH) {
                    fill_window(s);
                    if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                    }
                    if (s.lookahead === 0) {
                        break;
                    }
                }
                s.match_length = 0;
                if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                    scan = s.strstart - 1;
                    prev = _win[scan];
                    if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                        strend = s.strstart + MAX_MATCH;
                        do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                        s.match_length = MAX_MATCH - (strend - scan);
                        if (s.match_length > s.lookahead) {
                            s.match_length = s.lookahead;
                        }
                    }
                }
                if (s.match_length >= MIN_MATCH) {
                    bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
                    s.lookahead -= s.match_length;
                    s.strstart += s.match_length;
                    s.match_length = 0;
                } else {
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                    s.lookahead--;
                    s.strstart++;
                }
                if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
            }
            s.insert = 0;
            if (flush === Z_FINISH) {
                flush_block_only(s, true);
                if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                }
                return BS_FINISH_DONE;
            }
            if (s.last_lit) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
            return BS_BLOCK_DONE;
        }
        function deflate_huff(s, flush) {
            var bflush;
            for (;;) {
                if (s.lookahead === 0) {
                    fill_window(s);
                    if (s.lookahead === 0) {
                        if (flush === Z_NO_FLUSH) {
                            return BS_NEED_MORE;
                        }
                        break;
                    }
                }
                s.match_length = 0;
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
                if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
            }
            s.insert = 0;
            if (flush === Z_FINISH) {
                flush_block_only(s, true);
                if (s.strm.avail_out === 0) {
                    return BS_FINISH_STARTED;
                }
                return BS_FINISH_DONE;
            }
            if (s.last_lit) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
            return BS_BLOCK_DONE;
        }
        function Config(good_length, max_lazy, nice_length, max_chain, func) {
            this.good_length = good_length;
            this.max_lazy = max_lazy;
            this.nice_length = nice_length;
            this.max_chain = max_chain;
            this.func = func;
        }
        var configuration_table;
        configuration_table = [ new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow) ];
        function lm_init(s) {
            s.window_size = 2 * s.w_size;
            zero(s.head);
            s.max_lazy_match = configuration_table[s.level].max_lazy;
            s.good_match = configuration_table[s.level].good_length;
            s.nice_match = configuration_table[s.level].nice_length;
            s.max_chain_length = configuration_table[s.level].max_chain;
            s.strstart = 0;
            s.block_start = 0;
            s.lookahead = 0;
            s.insert = 0;
            s.match_length = s.prev_length = MIN_MATCH - 1;
            s.match_available = 0;
            s.ins_h = 0;
        }
        function DeflateState() {
            this.strm = null;
            this.status = 0;
            this.pending_buf = null;
            this.pending_buf_size = 0;
            this.pending_out = 0;
            this.pending = 0;
            this.wrap = 0;
            this.gzhead = null;
            this.gzindex = 0;
            this.method = Z_DEFLATED;
            this.last_flush = -1;
            this.w_size = 0;
            this.w_bits = 0;
            this.w_mask = 0;
            this.window = null;
            this.window_size = 0;
            this.prev = null;
            this.head = null;
            this.ins_h = 0;
            this.hash_size = 0;
            this.hash_bits = 0;
            this.hash_mask = 0;
            this.hash_shift = 0;
            this.block_start = 0;
            this.match_length = 0;
            this.prev_match = 0;
            this.match_available = 0;
            this.strstart = 0;
            this.match_start = 0;
            this.lookahead = 0;
            this.prev_length = 0;
            this.max_chain_length = 0;
            this.max_lazy_match = 0;
            this.level = 0;
            this.strategy = 0;
            this.good_match = 0;
            this.nice_match = 0;
            this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
            this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
            this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
            zero(this.dyn_ltree);
            zero(this.dyn_dtree);
            zero(this.bl_tree);
            this.l_desc = null;
            this.d_desc = null;
            this.bl_desc = null;
            this.bl_count = new utils.Buf16(MAX_BITS + 1);
            this.heap = new utils.Buf16(2 * L_CODES + 1);
            zero(this.heap);
            this.heap_len = 0;
            this.heap_max = 0;
            this.depth = new utils.Buf16(2 * L_CODES + 1);
            zero(this.depth);
            this.l_buf = 0;
            this.lit_bufsize = 0;
            this.last_lit = 0;
            this.d_buf = 0;
            this.opt_len = 0;
            this.static_len = 0;
            this.matches = 0;
            this.insert = 0;
            this.bi_buf = 0;
            this.bi_valid = 0;
        }
        function deflateResetKeep(strm) {
            var s;
            if (!strm || !strm.state) {
                return err(strm, Z_STREAM_ERROR);
            }
            strm.total_in = strm.total_out = 0;
            strm.data_type = Z_UNKNOWN;
            s = strm.state;
            s.pending = 0;
            s.pending_out = 0;
            if (s.wrap < 0) {
                s.wrap = -s.wrap;
            }
            s.status = s.wrap ? INIT_STATE : BUSY_STATE;
            strm.adler = s.wrap === 2 ? 0 : 1;
            s.last_flush = Z_NO_FLUSH;
            trees._tr_init(s);
            return Z_OK;
        }
        function deflateReset(strm) {
            var ret = deflateResetKeep(strm);
            if (ret === Z_OK) {
                lm_init(strm.state);
            }
            return ret;
        }
        function deflateSetHeader(strm, head) {
            if (!strm || !strm.state) {
                return Z_STREAM_ERROR;
            }
            if (strm.state.wrap !== 2) {
                return Z_STREAM_ERROR;
            }
            strm.state.gzhead = head;
            return Z_OK;
        }
        function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
            if (!strm) {
                return Z_STREAM_ERROR;
            }
            var wrap = 1;
            if (level === Z_DEFAULT_COMPRESSION) {
                level = 6;
            }
            if (windowBits < 0) {
                wrap = 0;
                windowBits = -windowBits;
            } else if (windowBits > 15) {
                wrap = 2;
                windowBits -= 16;
            }
            if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
                return err(strm, Z_STREAM_ERROR);
            }
            if (windowBits === 8) {
                windowBits = 9;
            }
            var s = new DeflateState();
            strm.state = s;
            s.strm = strm;
            s.wrap = wrap;
            s.gzhead = null;
            s.w_bits = windowBits;
            s.w_size = 1 << s.w_bits;
            s.w_mask = s.w_size - 1;
            s.hash_bits = memLevel + 7;
            s.hash_size = 1 << s.hash_bits;
            s.hash_mask = s.hash_size - 1;
            s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
            s.window = new utils.Buf8(s.w_size * 2);
            s.head = new utils.Buf16(s.hash_size);
            s.prev = new utils.Buf16(s.w_size);
            s.lit_bufsize = 1 << memLevel + 6;
            s.pending_buf_size = s.lit_bufsize * 4;
            s.pending_buf = new utils.Buf8(s.pending_buf_size);
            s.d_buf = 1 * s.lit_bufsize;
            s.l_buf = (1 + 2) * s.lit_bufsize;
            s.level = level;
            s.strategy = strategy;
            s.method = method;
            return deflateReset(strm);
        }
        function deflateInit(strm, level) {
            return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
        }
        function deflate(strm, flush) {
            var old_flush, s;
            var beg, val;
            if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
                return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
            }
            s = strm.state;
            if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
                return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
            }
            s.strm = strm;
            old_flush = s.last_flush;
            s.last_flush = flush;
            if (s.status === INIT_STATE) {
                if (s.wrap === 2) {
                    strm.adler = 0;
                    put_byte(s, 31);
                    put_byte(s, 139);
                    put_byte(s, 8);
                    if (!s.gzhead) {
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                        put_byte(s, OS_CODE);
                        s.status = BUSY_STATE;
                    } else {
                        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
                        put_byte(s, s.gzhead.time & 255);
                        put_byte(s, s.gzhead.time >> 8 & 255);
                        put_byte(s, s.gzhead.time >> 16 & 255);
                        put_byte(s, s.gzhead.time >> 24 & 255);
                        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                        put_byte(s, s.gzhead.os & 255);
                        if (s.gzhead.extra && s.gzhead.extra.length) {
                            put_byte(s, s.gzhead.extra.length & 255);
                            put_byte(s, s.gzhead.extra.length >> 8 & 255);
                        }
                        if (s.gzhead.hcrc) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                        }
                        s.gzindex = 0;
                        s.status = EXTRA_STATE;
                    }
                } else {
                    var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
                    var level_flags = -1;
                    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                        level_flags = 0;
                    } else if (s.level < 6) {
                        level_flags = 1;
                    } else if (s.level === 6) {
                        level_flags = 2;
                    } else {
                        level_flags = 3;
                    }
                    header |= level_flags << 6;
                    if (s.strstart !== 0) {
                        header |= PRESET_DICT;
                    }
                    header += 31 - header % 31;
                    s.status = BUSY_STATE;
                    putShortMSB(s, header);
                    if (s.strstart !== 0) {
                        putShortMSB(s, strm.adler >>> 16);
                        putShortMSB(s, strm.adler & 65535);
                    }
                    strm.adler = 1;
                }
            }
            if (s.status === EXTRA_STATE) {
                if (s.gzhead.extra) {
                    beg = s.pending;
                    while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                        if (s.pending === s.pending_buf_size) {
                            if (s.gzhead.hcrc && s.pending > beg) {
                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                            }
                            flush_pending(strm);
                            beg = s.pending;
                            if (s.pending === s.pending_buf_size) {
                                break;
                            }
                        }
                        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                        s.gzindex++;
                    }
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (s.gzindex === s.gzhead.extra.length) {
                        s.gzindex = 0;
                        s.status = NAME_STATE;
                    }
                } else {
                    s.status = NAME_STATE;
                }
            }
            if (s.status === NAME_STATE) {
                if (s.gzhead.name) {
                    beg = s.pending;
                    do {
                        if (s.pending === s.pending_buf_size) {
                            if (s.gzhead.hcrc && s.pending > beg) {
                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                            }
                            flush_pending(strm);
                            beg = s.pending;
                            if (s.pending === s.pending_buf_size) {
                                val = 1;
                                break;
                            }
                        }
                        if (s.gzindex < s.gzhead.name.length) {
                            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                        } else {
                            val = 0;
                        }
                        put_byte(s, val);
                    } while (val !== 0);
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (val === 0) {
                        s.gzindex = 0;
                        s.status = COMMENT_STATE;
                    }
                } else {
                    s.status = COMMENT_STATE;
                }
            }
            if (s.status === COMMENT_STATE) {
                if (s.gzhead.comment) {
                    beg = s.pending;
                    do {
                        if (s.pending === s.pending_buf_size) {
                            if (s.gzhead.hcrc && s.pending > beg) {
                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                            }
                            flush_pending(strm);
                            beg = s.pending;
                            if (s.pending === s.pending_buf_size) {
                                val = 1;
                                break;
                            }
                        }
                        if (s.gzindex < s.gzhead.comment.length) {
                            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                        } else {
                            val = 0;
                        }
                        put_byte(s, val);
                    } while (val !== 0);
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    if (val === 0) {
                        s.status = HCRC_STATE;
                    }
                } else {
                    s.status = HCRC_STATE;
                }
            }
            if (s.status === HCRC_STATE) {
                if (s.gzhead.hcrc) {
                    if (s.pending + 2 > s.pending_buf_size) {
                        flush_pending(strm);
                    }
                    if (s.pending + 2 <= s.pending_buf_size) {
                        put_byte(s, strm.adler & 255);
                        put_byte(s, strm.adler >> 8 & 255);
                        strm.adler = 0;
                        s.status = BUSY_STATE;
                    }
                } else {
                    s.status = BUSY_STATE;
                }
            }
            if (s.pending !== 0) {
                flush_pending(strm);
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                    return Z_OK;
                }
            } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
                return err(strm, Z_BUF_ERROR);
            }
            if (s.status === FINISH_STATE && strm.avail_in !== 0) {
                return err(strm, Z_BUF_ERROR);
            }
            if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
                var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
                if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                    s.status = FINISH_STATE;
                }
                if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                    if (strm.avail_out === 0) {
                        s.last_flush = -1;
                    }
                    return Z_OK;
                }
                if (bstate === BS_BLOCK_DONE) {
                    if (flush === Z_PARTIAL_FLUSH) {
                        trees._tr_align(s);
                    } else if (flush !== Z_BLOCK) {
                        trees._tr_stored_block(s, 0, 0, false);
                        if (flush === Z_FULL_FLUSH) {
                            zero(s.head);
                            if (s.lookahead === 0) {
                                s.strstart = 0;
                                s.block_start = 0;
                                s.insert = 0;
                            }
                        }
                    }
                    flush_pending(strm);
                    if (strm.avail_out === 0) {
                        s.last_flush = -1;
                        return Z_OK;
                    }
                }
            }
            if (flush !== Z_FINISH) {
                return Z_OK;
            }
            if (s.wrap <= 0) {
                return Z_STREAM_END;
            }
            if (s.wrap === 2) {
                put_byte(s, strm.adler & 255);
                put_byte(s, strm.adler >> 8 & 255);
                put_byte(s, strm.adler >> 16 & 255);
                put_byte(s, strm.adler >> 24 & 255);
                put_byte(s, strm.total_in & 255);
                put_byte(s, strm.total_in >> 8 & 255);
                put_byte(s, strm.total_in >> 16 & 255);
                put_byte(s, strm.total_in >> 24 & 255);
            } else {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 65535);
            }
            flush_pending(strm);
            if (s.wrap > 0) {
                s.wrap = -s.wrap;
            }
            return s.pending !== 0 ? Z_OK : Z_STREAM_END;
        }
        function deflateEnd(strm) {
            var status;
            if (!strm || !strm.state) {
                return Z_STREAM_ERROR;
            }
            status = strm.state.status;
            if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
                return err(strm, Z_STREAM_ERROR);
            }
            strm.state = null;
            return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
        }
        function deflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length;
            var s;
            var str, n;
            var wrap;
            var avail;
            var next;
            var input;
            var tmpDict;
            if (!strm || !strm.state) {
                return Z_STREAM_ERROR;
            }
            s = strm.state;
            wrap = s.wrap;
            if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
                return Z_STREAM_ERROR;
            }
            if (wrap === 1) {
                strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
            }
            s.wrap = 0;
            if (dictLength >= s.w_size) {
                if (wrap === 0) {
                    zero(s.head);
                    s.strstart = 0;
                    s.block_start = 0;
                    s.insert = 0;
                }
                tmpDict = new utils.Buf8(s.w_size);
                utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
                dictionary = tmpDict;
                dictLength = s.w_size;
            }
            avail = strm.avail_in;
            next = strm.next_in;
            input = strm.input;
            strm.avail_in = dictLength;
            strm.next_in = 0;
            strm.input = dictionary;
            fill_window(s);
            while (s.lookahead >= MIN_MATCH) {
                str = s.strstart;
                n = s.lookahead - (MIN_MATCH - 1);
                do {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = str;
                    str++;
                } while (--n);
                s.strstart = str;
                s.lookahead = MIN_MATCH - 1;
                fill_window(s);
            }
            s.strstart += s.lookahead;
            s.block_start = s.strstart;
            s.insert = s.lookahead;
            s.lookahead = 0;
            s.match_length = s.prev_length = MIN_MATCH - 1;
            s.match_available = 0;
            strm.next_in = next;
            strm.input = input;
            strm.avail_in = avail;
            s.wrap = wrap;
            return Z_OK;
        }
        exports.deflateInit = deflateInit;
        exports.deflateInit2 = deflateInit2;
        exports.deflateReset = deflateReset;
        exports.deflateResetKeep = deflateResetKeep;
        exports.deflateSetHeader = deflateSetHeader;
        exports.deflate = deflate;
        exports.deflateEnd = deflateEnd;
        exports.deflateSetDictionary = deflateSetDictionary;
        exports.deflateInfo = "pako deflate (from Nodeca project)";
    }, {
        "../utils/common": 120,
        "./adler32": 122,
        "./crc32": 124,
        "./messages": 130,
        "./trees": 131
    } ],
    126: [ function(require, module, exports) {
        "use strict";
        function GZheader() {
            this.text = 0;
            this.time = 0;
            this.xflags = 0;
            this.os = 0;
            this.extra = null;
            this.extra_len = 0;
            this.name = "";
            this.comment = "";
            this.hcrc = 0;
            this.done = false;
        }
        module.exports = GZheader;
    }, {} ],
    127: [ function(require, module, exports) {
        "use strict";
        var BAD = 30;
        var TYPE = 12;
        module.exports = function inflate_fast(strm, start) {
            var state;
            var _in;
            var last;
            var _out;
            var beg;
            var end;
            var dmax;
            var wsize;
            var whave;
            var wnext;
            var s_window;
            var hold;
            var bits;
            var lcode;
            var dcode;
            var lmask;
            var dmask;
            var here;
            var op;
            var len;
            var dist;
            var from;
            var from_source;
            var input, output;
            state = strm.state;
            _in = strm.next_in;
            input = strm.input;
            last = _in + (strm.avail_in - 5);
            _out = strm.next_out;
            output = strm.output;
            beg = _out - (start - strm.avail_out);
            end = _out + (strm.avail_out - 257);
            dmax = state.dmax;
            wsize = state.wsize;
            whave = state.whave;
            wnext = state.wnext;
            s_window = state.window;
            hold = state.hold;
            bits = state.bits;
            lcode = state.lencode;
            dcode = state.distcode;
            lmask = (1 << state.lenbits) - 1;
            dmask = (1 << state.distbits) - 1;
            top: do {
                if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                }
                here = lcode[hold & lmask];
                dolen: for (;;) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op === 0) {
                        output[_out++] = here & 65535;
                    } else if (op & 16) {
                        len = here & 65535;
                        op &= 15;
                        if (op) {
                            if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                            }
                            len += hold & (1 << op) - 1;
                            hold >>>= op;
                            bits -= op;
                        }
                        if (bits < 15) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            hold += input[_in++] << bits;
                            bits += 8;
                        }
                        here = dcode[hold & dmask];
                        dodist: for (;;) {
                            op = here >>> 24;
                            hold >>>= op;
                            bits -= op;
                            op = here >>> 16 & 255;
                            if (op & 16) {
                                dist = here & 65535;
                                op &= 15;
                                if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                    if (bits < op) {
                                        hold += input[_in++] << bits;
                                        bits += 8;
                                    }
                                }
                                dist += hold & (1 << op) - 1;
                                if (dist > dmax) {
                                    strm.msg = "invalid distance too far back";
                                    state.mode = BAD;
                                    break top;
                                }
                                hold >>>= op;
                                bits -= op;
                                op = _out - beg;
                                if (dist > op) {
                                    op = dist - op;
                                    if (op > whave) {
                                        if (state.sane) {
                                            strm.msg = "invalid distance too far back";
                                            state.mode = BAD;
                                            break top;
                                        }
                                    }
                                    from = 0;
                                    from_source = s_window;
                                    if (wnext === 0) {
                                        from += wsize - op;
                                        if (op < len) {
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++];
                                            } while (--op);
                                            from = _out - dist;
                                            from_source = output;
                                        }
                                    } else if (wnext < op) {
                                        from += wsize + wnext - op;
                                        op -= wnext;
                                        if (op < len) {
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++];
                                            } while (--op);
                                            from = 0;
                                            if (wnext < len) {
                                                op = wnext;
                                                len -= op;
                                                do {
                                                    output[_out++] = s_window[from++];
                                                } while (--op);
                                                from = _out - dist;
                                                from_source = output;
                                            }
                                        }
                                    } else {
                                        from += wnext - op;
                                        if (op < len) {
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++];
                                            } while (--op);
                                            from = _out - dist;
                                            from_source = output;
                                        }
                                    }
                                    while (len > 2) {
                                        output[_out++] = from_source[from++];
                                        output[_out++] = from_source[from++];
                                        output[_out++] = from_source[from++];
                                        len -= 3;
                                    }
                                    if (len) {
                                        output[_out++] = from_source[from++];
                                        if (len > 1) {
                                            output[_out++] = from_source[from++];
                                        }
                                    }
                                } else {
                                    from = _out - dist;
                                    do {
                                        output[_out++] = output[from++];
                                        output[_out++] = output[from++];
                                        output[_out++] = output[from++];
                                        len -= 3;
                                    } while (len > 2);
                                    if (len) {
                                        output[_out++] = output[from++];
                                        if (len > 1) {
                                            output[_out++] = output[from++];
                                        }
                                    }
                                }
                            } else if ((op & 64) === 0) {
                                here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                                continue dodist;
                            } else {
                                strm.msg = "invalid distance code";
                                state.mode = BAD;
                                break top;
                            }
                            break;
                        }
                    } else if ((op & 64) === 0) {
                        here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dolen;
                    } else if (op & 32) {
                        state.mode = TYPE;
                        break top;
                    } else {
                        strm.msg = "invalid literal/length code";
                        state.mode = BAD;
                        break top;
                    }
                    break;
                }
            } while (_in < last && _out < end);
            len = bits >> 3;
            _in -= len;
            bits -= len << 3;
            hold &= (1 << bits) - 1;
            strm.next_in = _in;
            strm.next_out = _out;
            strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
            strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
            state.hold = hold;
            state.bits = bits;
            return;
        };
    }, {} ],
    128: [ function(require, module, exports) {
        "use strict";
        var utils = require("../utils/common");
        var adler32 = require("./adler32");
        var crc32 = require("./crc32");
        var inflate_fast = require("./inffast");
        var inflate_table = require("./inftrees");
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_TREES = 6;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_NEED_DICT = 2;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_MEM_ERROR = -4;
        var Z_BUF_ERROR = -5;
        var Z_DEFLATED = 8;
        var HEAD = 1;
        var FLAGS = 2;
        var TIME = 3;
        var OS = 4;
        var EXLEN = 5;
        var EXTRA = 6;
        var NAME = 7;
        var COMMENT = 8;
        var HCRC = 9;
        var DICTID = 10;
        var DICT = 11;
        var TYPE = 12;
        var TYPEDO = 13;
        var STORED = 14;
        var COPY_ = 15;
        var COPY = 16;
        var TABLE = 17;
        var LENLENS = 18;
        var CODELENS = 19;
        var LEN_ = 20;
        var LEN = 21;
        var LENEXT = 22;
        var DIST = 23;
        var DISTEXT = 24;
        var MATCH = 25;
        var LIT = 26;
        var CHECK = 27;
        var LENGTH = 28;
        var DONE = 29;
        var BAD = 30;
        var MEM = 31;
        var SYNC = 32;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var MAX_WBITS = 15;
        var DEF_WBITS = MAX_WBITS;
        function zswap32(q) {
            return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
        }
        function InflateState() {
            this.mode = 0;
            this.last = false;
            this.wrap = 0;
            this.havedict = false;
            this.flags = 0;
            this.dmax = 0;
            this.check = 0;
            this.total = 0;
            this.head = null;
            this.wbits = 0;
            this.wsize = 0;
            this.whave = 0;
            this.wnext = 0;
            this.window = null;
            this.hold = 0;
            this.bits = 0;
            this.length = 0;
            this.offset = 0;
            this.extra = 0;
            this.lencode = null;
            this.distcode = null;
            this.lenbits = 0;
            this.distbits = 0;
            this.ncode = 0;
            this.nlen = 0;
            this.ndist = 0;
            this.have = 0;
            this.next = null;
            this.lens = new utils.Buf16(320);
            this.work = new utils.Buf16(288);
            this.lendyn = null;
            this.distdyn = null;
            this.sane = 0;
            this.back = 0;
            this.was = 0;
        }
        function inflateResetKeep(strm) {
            var state;
            if (!strm || !strm.state) {
                return Z_STREAM_ERROR;
            }
            state = strm.state;
            strm.total_in = strm.total_out = state.total = 0;
            strm.msg = "";
            if (state.wrap) {
                strm.adler = state.wrap & 1;
            }
            state.mode = HEAD;
            state.last = 0;
            state.havedict = 0;
            state.dmax = 32768;
            state.head = null;
            state.hold = 0;
            state.bits = 0;
            state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
            state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
            state.sane = 1;
            state.back = -1;
            return Z_OK;
        }
        function inflateReset(strm) {
            var state;
            if (!strm || !strm.state) {
                return Z_STREAM_ERROR;
            }
            state = strm.state;
            state.wsize = 0;
            state.whave = 0;
            state.wnext = 0;
            return inflateResetKeep(strm);
        }
        function inflateReset2(strm, windowBits) {
            var wrap;
            var state;
            if (!strm || !strm.state) {
                return Z_STREAM_ERROR;
            }
            state = strm.state;
            if (windowBits < 0) {
                wrap = 0;
                windowBits = -windowBits;
            } else {
                wrap = (windowBits >> 4) + 1;
                if (windowBits < 48) {
                    windowBits &= 15;
                }
            }
            if (windowBits && (windowBits < 8 || windowBits > 15)) {
                return Z_STREAM_ERROR;
            }
            if (state.window !== null && state.wbits !== windowBits) {
                state.window = null;
            }
            state.wrap = wrap;
            state.wbits = windowBits;
            return inflateReset(strm);
        }
        function inflateInit2(strm, windowBits) {
            var ret;
            var state;
            if (!strm) {
                return Z_STREAM_ERROR;
            }
            state = new InflateState();
            strm.state = state;
            state.window = null;
            ret = inflateReset2(strm, windowBits);
            if (ret !== Z_OK) {
                strm.state = null;
            }
            return ret;
        }
        function inflateInit(strm) {
            return inflateInit2(strm, DEF_WBITS);
        }
        var virgin = true;
        var lenfix, distfix;
        function fixedtables(state) {
            if (virgin) {
                var sym;
                lenfix = new utils.Buf32(512);
                distfix = new utils.Buf32(32);
                sym = 0;
                while (sym < 144) {
                    state.lens[sym++] = 8;
                }
                while (sym < 256) {
                    state.lens[sym++] = 9;
                }
                while (sym < 280) {
                    state.lens[sym++] = 7;
                }
                while (sym < 288) {
                    state.lens[sym++] = 8;
                }
                inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                    bits: 9
                });
                sym = 0;
                while (sym < 32) {
                    state.lens[sym++] = 5;
                }
                inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                    bits: 5
                });
                virgin = false;
            }
            state.lencode = lenfix;
            state.lenbits = 9;
            state.distcode = distfix;
            state.distbits = 5;
        }
        function updatewindow(strm, src, end, copy) {
            var dist;
            var state = strm.state;
            if (state.window === null) {
                state.wsize = 1 << state.wbits;
                state.wnext = 0;
                state.whave = 0;
                state.window = new utils.Buf8(state.wsize);
            }
            if (copy >= state.wsize) {
                utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
                state.wnext = 0;
                state.whave = state.wsize;
            } else {
                dist = state.wsize - state.wnext;
                if (dist > copy) {
                    dist = copy;
                }
                utils.arraySet(state.window, src, end - copy, dist, state.wnext);
                copy -= dist;
                if (copy) {
                    utils.arraySet(state.window, src, end - copy, copy, 0);
                    state.wnext = copy;
                    state.whave = state.wsize;
                } else {
                    state.wnext += dist;
                    if (state.wnext === state.wsize) {
                        state.wnext = 0;
                    }
                    if (state.whave < state.wsize) {
                        state.whave += dist;
                    }
                }
            }
            return 0;
        }
        function inflate(strm, flush) {
            var state;
            var input, output;
            var next;
            var put;
            var have, left;
            var hold;
            var bits;
            var _in, _out;
            var copy;
            var from;
            var from_source;
            var here = 0;
            var here_bits, here_op, here_val;
            var last_bits, last_op, last_val;
            var len;
            var ret;
            var hbuf = new utils.Buf8(4);
            var opts;
            var n;
            var order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
            if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
                return Z_STREAM_ERROR;
            }
            state = strm.state;
            if (state.mode === TYPE) {
                state.mode = TYPEDO;
            }
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            _in = have;
            _out = left;
            ret = Z_OK;
            inf_leave: for (;;) {
                switch (state.mode) {
                  case HEAD:
                    if (state.wrap === 0) {
                        state.mode = TYPEDO;
                        break;
                    }
                    while (bits < 16) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.wrap & 2 && hold === 35615) {
                        state.check = 0;
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state.check = crc32(state.check, hbuf, 2, 0);
                        hold = 0;
                        bits = 0;
                        state.mode = FLAGS;
                        break;
                    }
                    state.flags = 0;
                    if (state.head) {
                        state.head.done = false;
                    }
                    if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                        strm.msg = "incorrect header check";
                        state.mode = BAD;
                        break;
                    }
                    if ((hold & 15) !== Z_DEFLATED) {
                        strm.msg = "unknown compression method";
                        state.mode = BAD;
                        break;
                    }
                    hold >>>= 4;
                    bits -= 4;
                    len = (hold & 15) + 8;
                    if (state.wbits === 0) {
                        state.wbits = len;
                    } else if (len > state.wbits) {
                        strm.msg = "invalid window size";
                        state.mode = BAD;
                        break;
                    }
                    state.dmax = 1 << len;
                    strm.adler = state.check = 1;
                    state.mode = hold & 512 ? DICTID : TYPE;
                    hold = 0;
                    bits = 0;
                    break;

                  case FLAGS:
                    while (bits < 16) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.flags = hold;
                    if ((state.flags & 255) !== Z_DEFLATED) {
                        strm.msg = "unknown compression method";
                        state.mode = BAD;
                        break;
                    }
                    if (state.flags & 57344) {
                        strm.msg = "unknown header flags set";
                        state.mode = BAD;
                        break;
                    }
                    if (state.head) {
                        state.head.text = hold >> 8 & 1;
                    }
                    if (state.flags & 512) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                    state.mode = TIME;

                  case TIME:
                    while (bits < 32) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.head) {
                        state.head.time = hold;
                    }
                    if (state.flags & 512) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        hbuf[2] = hold >>> 16 & 255;
                        hbuf[3] = hold >>> 24 & 255;
                        state.check = crc32(state.check, hbuf, 4, 0);
                    }
                    hold = 0;
                    bits = 0;
                    state.mode = OS;

                  case OS:
                    while (bits < 16) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.head) {
                        state.head.xflags = hold & 255;
                        state.head.os = hold >> 8;
                    }
                    if (state.flags & 512) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                    state.mode = EXLEN;

                  case EXLEN:
                    if (state.flags & 1024) {
                        while (bits < 16) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        state.length = hold;
                        if (state.head) {
                            state.head.extra_len = hold;
                        }
                        if (state.flags & 512) {
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            state.check = crc32(state.check, hbuf, 2, 0);
                        }
                        hold = 0;
                        bits = 0;
                    } else if (state.head) {
                        state.head.extra = null;
                    }
                    state.mode = EXTRA;

                  case EXTRA:
                    if (state.flags & 1024) {
                        copy = state.length;
                        if (copy > have) {
                            copy = have;
                        }
                        if (copy) {
                            if (state.head) {
                                len = state.head.extra_len - state.length;
                                if (!state.head.extra) {
                                    state.head.extra = new Array(state.head.extra_len);
                                }
                                utils.arraySet(state.head.extra, input, next, copy, len);
                            }
                            if (state.flags & 512) {
                                state.check = crc32(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            state.length -= copy;
                        }
                        if (state.length) {
                            break inf_leave;
                        }
                    }
                    state.length = 0;
                    state.mode = NAME;

                  case NAME:
                    if (state.flags & 2048) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        copy = 0;
                        do {
                            len = input[next + copy++];
                            if (state.head && len && state.length < 65536) {
                                state.head.name += String.fromCharCode(len);
                            }
                        } while (len && copy < have);
                        if (state.flags & 512) {
                            state.check = crc32(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        if (len) {
                            break inf_leave;
                        }
                    } else if (state.head) {
                        state.head.name = null;
                    }
                    state.length = 0;
                    state.mode = COMMENT;

                  case COMMENT:
                    if (state.flags & 4096) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        copy = 0;
                        do {
                            len = input[next + copy++];
                            if (state.head && len && state.length < 65536) {
                                state.head.comment += String.fromCharCode(len);
                            }
                        } while (len && copy < have);
                        if (state.flags & 512) {
                            state.check = crc32(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        if (len) {
                            break inf_leave;
                        }
                    } else if (state.head) {
                        state.head.comment = null;
                    }
                    state.mode = HCRC;

                  case HCRC:
                    if (state.flags & 512) {
                        while (bits < 16) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if (hold !== (state.check & 65535)) {
                            strm.msg = "header crc mismatch";
                            state.mode = BAD;
                            break;
                        }
                        hold = 0;
                        bits = 0;
                    }
                    if (state.head) {
                        state.head.hcrc = state.flags >> 9 & 1;
                        state.head.done = true;
                    }
                    strm.adler = state.check = 0;
                    state.mode = TYPE;
                    break;

                  case DICTID:
                    while (bits < 32) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    strm.adler = state.check = zswap32(hold);
                    hold = 0;
                    bits = 0;
                    state.mode = DICT;

                  case DICT:
                    if (state.havedict === 0) {
                        strm.next_out = put;
                        strm.avail_out = left;
                        strm.next_in = next;
                        strm.avail_in = have;
                        state.hold = hold;
                        state.bits = bits;
                        return Z_NEED_DICT;
                    }
                    strm.adler = state.check = 1;
                    state.mode = TYPE;

                  case TYPE:
                    if (flush === Z_BLOCK || flush === Z_TREES) {
                        break inf_leave;
                    }

                  case TYPEDO:
                    if (state.last) {
                        hold >>>= bits & 7;
                        bits -= bits & 7;
                        state.mode = CHECK;
                        break;
                    }
                    while (bits < 3) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.last = hold & 1;
                    hold >>>= 1;
                    bits -= 1;
                    switch (hold & 3) {
                      case 0:
                        state.mode = STORED;
                        break;

                      case 1:
                        fixedtables(state);
                        state.mode = LEN_;
                        if (flush === Z_TREES) {
                            hold >>>= 2;
                            bits -= 2;
                            break inf_leave;
                        }
                        break;

                      case 2:
                        state.mode = TABLE;
                        break;

                      case 3:
                        strm.msg = "invalid block type";
                        state.mode = BAD;
                    }
                    hold >>>= 2;
                    bits -= 2;
                    break;

                  case STORED:
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    while (bits < 32) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                        strm.msg = "invalid stored block lengths";
                        state.mode = BAD;
                        break;
                    }
                    state.length = hold & 65535;
                    hold = 0;
                    bits = 0;
                    state.mode = COPY_;
                    if (flush === Z_TREES) {
                        break inf_leave;
                    }

                  case COPY_:
                    state.mode = COPY;

                  case COPY:
                    copy = state.length;
                    if (copy) {
                        if (copy > have) {
                            copy = have;
                        }
                        if (copy > left) {
                            copy = left;
                        }
                        if (copy === 0) {
                            break inf_leave;
                        }
                        utils.arraySet(output, input, next, copy, put);
                        have -= copy;
                        next += copy;
                        left -= copy;
                        put += copy;
                        state.length -= copy;
                        break;
                    }
                    state.mode = TYPE;
                    break;

                  case TABLE:
                    while (bits < 14) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.nlen = (hold & 31) + 257;
                    hold >>>= 5;
                    bits -= 5;
                    state.ndist = (hold & 31) + 1;
                    hold >>>= 5;
                    bits -= 5;
                    state.ncode = (hold & 15) + 4;
                    hold >>>= 4;
                    bits -= 4;
                    if (state.nlen > 286 || state.ndist > 30) {
                        strm.msg = "too many length or distance symbols";
                        state.mode = BAD;
                        break;
                    }
                    state.have = 0;
                    state.mode = LENLENS;

                  case LENLENS:
                    while (state.have < state.ncode) {
                        while (bits < 3) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        state.lens[order[state.have++]] = hold & 7;
                        hold >>>= 3;
                        bits -= 3;
                    }
                    while (state.have < 19) {
                        state.lens[order[state.have++]] = 0;
                    }
                    state.lencode = state.lendyn;
                    state.lenbits = 7;
                    opts = {
                        bits: state.lenbits
                    };
                    ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                    state.lenbits = opts.bits;
                    if (ret) {
                        strm.msg = "invalid code lengths set";
                        state.mode = BAD;
                        break;
                    }
                    state.have = 0;
                    state.mode = CODELENS;

                  case CODELENS:
                    while (state.have < state.nlen + state.ndist) {
                        for (;;) {
                            here = state.lencode[hold & (1 << state.lenbits) - 1];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (here_bits <= bits) {
                                break;
                            }
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if (here_val < 16) {
                            hold >>>= here_bits;
                            bits -= here_bits;
                            state.lens[state.have++] = here_val;
                        } else {
                            if (here_val === 16) {
                                n = here_bits + 2;
                                while (bits < n) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                hold >>>= here_bits;
                                bits -= here_bits;
                                if (state.have === 0) {
                                    strm.msg = "invalid bit length repeat";
                                    state.mode = BAD;
                                    break;
                                }
                                len = state.lens[state.have - 1];
                                copy = 3 + (hold & 3);
                                hold >>>= 2;
                                bits -= 2;
                            } else if (here_val === 17) {
                                n = here_bits + 3;
                                while (bits < n) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                hold >>>= here_bits;
                                bits -= here_bits;
                                len = 0;
                                copy = 3 + (hold & 7);
                                hold >>>= 3;
                                bits -= 3;
                            } else {
                                n = here_bits + 7;
                                while (bits < n) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                hold >>>= here_bits;
                                bits -= here_bits;
                                len = 0;
                                copy = 11 + (hold & 127);
                                hold >>>= 7;
                                bits -= 7;
                            }
                            if (state.have + copy > state.nlen + state.ndist) {
                                strm.msg = "invalid bit length repeat";
                                state.mode = BAD;
                                break;
                            }
                            while (copy--) {
                                state.lens[state.have++] = len;
                            }
                        }
                    }
                    if (state.mode === BAD) {
                        break;
                    }
                    if (state.lens[256] === 0) {
                        strm.msg = "invalid code -- missing end-of-block";
                        state.mode = BAD;
                        break;
                    }
                    state.lenbits = 9;
                    opts = {
                        bits: state.lenbits
                    };
                    ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                    state.lenbits = opts.bits;
                    if (ret) {
                        strm.msg = "invalid literal/lengths set";
                        state.mode = BAD;
                        break;
                    }
                    state.distbits = 6;
                    state.distcode = state.distdyn;
                    opts = {
                        bits: state.distbits
                    };
                    ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                    state.distbits = opts.bits;
                    if (ret) {
                        strm.msg = "invalid distances set";
                        state.mode = BAD;
                        break;
                    }
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                        break inf_leave;
                    }

                  case LEN_:
                    state.mode = LEN;

                  case LEN:
                    if (have >= 6 && left >= 258) {
                        strm.next_out = put;
                        strm.avail_out = left;
                        strm.next_in = next;
                        strm.avail_in = have;
                        state.hold = hold;
                        state.bits = bits;
                        inflate_fast(strm, _out);
                        put = strm.next_out;
                        output = strm.output;
                        left = strm.avail_out;
                        next = strm.next_in;
                        input = strm.input;
                        have = strm.avail_in;
                        hold = state.hold;
                        bits = state.bits;
                        if (state.mode === TYPE) {
                            state.back = -1;
                        }
                        break;
                    }
                    state.back = 0;
                    for (;;) {
                        here = state.lencode[hold & (1 << state.lenbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (here_op && (here_op & 240) === 0) {
                        last_bits = here_bits;
                        last_op = here_op;
                        last_val = here_val;
                        for (;;) {
                            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (last_bits + here_bits <= bits) {
                                break;
                            }
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        hold >>>= last_bits;
                        bits -= last_bits;
                        state.back += last_bits;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.back += here_bits;
                    state.length = here_val;
                    if (here_op === 0) {
                        state.mode = LIT;
                        break;
                    }
                    if (here_op & 32) {
                        state.back = -1;
                        state.mode = TYPE;
                        break;
                    }
                    if (here_op & 64) {
                        strm.msg = "invalid literal/length code";
                        state.mode = BAD;
                        break;
                    }
                    state.extra = here_op & 15;
                    state.mode = LENEXT;

                  case LENEXT:
                    if (state.extra) {
                        n = state.extra;
                        while (bits < n) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        state.length += hold & (1 << state.extra) - 1;
                        hold >>>= state.extra;
                        bits -= state.extra;
                        state.back += state.extra;
                    }
                    state.was = state.length;
                    state.mode = DIST;

                  case DIST:
                    for (;;) {
                        here = state.distcode[hold & (1 << state.distbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if ((here_op & 240) === 0) {
                        last_bits = here_bits;
                        last_op = here_op;
                        last_val = here_val;
                        for (;;) {
                            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (last_bits + here_bits <= bits) {
                                break;
                            }
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        hold >>>= last_bits;
                        bits -= last_bits;
                        state.back += last_bits;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.back += here_bits;
                    if (here_op & 64) {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break;
                    }
                    state.offset = here_val;
                    state.extra = here_op & 15;
                    state.mode = DISTEXT;

                  case DISTEXT:
                    if (state.extra) {
                        n = state.extra;
                        while (bits < n) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        state.offset += hold & (1 << state.extra) - 1;
                        hold >>>= state.extra;
                        bits -= state.extra;
                        state.back += state.extra;
                    }
                    if (state.offset > state.dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break;
                    }
                    state.mode = MATCH;

                  case MATCH:
                    if (left === 0) {
                        break inf_leave;
                    }
                    copy = _out - left;
                    if (state.offset > copy) {
                        copy = state.offset - copy;
                        if (copy > state.whave) {
                            if (state.sane) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD;
                                break;
                            }
                        }
                        if (copy > state.wnext) {
                            copy -= state.wnext;
                            from = state.wsize - copy;
                        } else {
                            from = state.wnext - copy;
                        }
                        if (copy > state.length) {
                            copy = state.length;
                        }
                        from_source = state.window;
                    } else {
                        from_source = output;
                        from = put - state.offset;
                        copy = state.length;
                    }
                    if (copy > left) {
                        copy = left;
                    }
                    left -= copy;
                    state.length -= copy;
                    do {
                        output[put++] = from_source[from++];
                    } while (--copy);
                    if (state.length === 0) {
                        state.mode = LEN;
                    }
                    break;

                  case LIT:
                    if (left === 0) {
                        break inf_leave;
                    }
                    output[put++] = state.length;
                    left--;
                    state.mode = LEN;
                    break;

                  case CHECK:
                    if (state.wrap) {
                        while (bits < 32) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold |= input[next++] << bits;
                            bits += 8;
                        }
                        _out -= left;
                        strm.total_out += _out;
                        state.total += _out;
                        if (_out) {
                            strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                        }
                        _out = left;
                        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                            strm.msg = "incorrect data check";
                            state.mode = BAD;
                            break;
                        }
                        hold = 0;
                        bits = 0;
                    }
                    state.mode = LENGTH;

                  case LENGTH:
                    if (state.wrap && state.flags) {
                        while (bits < 32) {
                            if (have === 0) {
                                break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                        }
                        if (hold !== (state.total & 4294967295)) {
                            strm.msg = "incorrect length check";
                            state.mode = BAD;
                            break;
                        }
                        hold = 0;
                        bits = 0;
                    }
                    state.mode = DONE;

                  case DONE:
                    ret = Z_STREAM_END;
                    break inf_leave;

                  case BAD:
                    ret = Z_DATA_ERROR;
                    break inf_leave;

                  case MEM:
                    return Z_MEM_ERROR;

                  case SYNC:
                  default:
                    return Z_STREAM_ERROR;
                }
            }
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
                if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                    state.mode = MEM;
                    return Z_MEM_ERROR;
                }
            }
            _in -= strm.avail_in;
            _out -= strm.avail_out;
            strm.total_in += _in;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap && _out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
            }
            strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
            if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
                ret = Z_BUF_ERROR;
            }
            return ret;
        }
        function inflateEnd(strm) {
            if (!strm || !strm.state) {
                return Z_STREAM_ERROR;
            }
            var state = strm.state;
            if (state.window) {
                state.window = null;
            }
            strm.state = null;
            return Z_OK;
        }
        function inflateGetHeader(strm, head) {
            var state;
            if (!strm || !strm.state) {
                return Z_STREAM_ERROR;
            }
            state = strm.state;
            if ((state.wrap & 2) === 0) {
                return Z_STREAM_ERROR;
            }
            state.head = head;
            head.done = false;
            return Z_OK;
        }
        function inflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length;
            var state;
            var dictid;
            var ret;
            if (!strm || !strm.state) {
                return Z_STREAM_ERROR;
            }
            state = strm.state;
            if (state.wrap !== 0 && state.mode !== DICT) {
                return Z_STREAM_ERROR;
            }
            if (state.mode === DICT) {
                dictid = 1;
                dictid = adler32(dictid, dictionary, dictLength, 0);
                if (dictid !== state.check) {
                    return Z_DATA_ERROR;
                }
            }
            ret = updatewindow(strm, dictionary, dictLength, dictLength);
            if (ret) {
                state.mode = MEM;
                return Z_MEM_ERROR;
            }
            state.havedict = 1;
            return Z_OK;
        }
        exports.inflateReset = inflateReset;
        exports.inflateReset2 = inflateReset2;
        exports.inflateResetKeep = inflateResetKeep;
        exports.inflateInit = inflateInit;
        exports.inflateInit2 = inflateInit2;
        exports.inflate = inflate;
        exports.inflateEnd = inflateEnd;
        exports.inflateGetHeader = inflateGetHeader;
        exports.inflateSetDictionary = inflateSetDictionary;
        exports.inflateInfo = "pako inflate (from Nodeca project)";
    }, {
        "../utils/common": 120,
        "./adler32": 122,
        "./crc32": 124,
        "./inffast": 127,
        "./inftrees": 129
    } ],
    129: [ function(require, module, exports) {
        "use strict";
        var utils = require("../utils/common");
        var MAXBITS = 15;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var lbase = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];
        var lext = [ 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78 ];
        var dbase = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 ];
        var dext = [ 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64 ];
        module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
            var bits = opts.bits;
            var len = 0;
            var sym = 0;
            var min = 0, max = 0;
            var root = 0;
            var curr = 0;
            var drop = 0;
            var left = 0;
            var used = 0;
            var huff = 0;
            var incr;
            var fill;
            var low;
            var mask;
            var next;
            var base = null;
            var base_index = 0;
            var end;
            var count = new utils.Buf16(MAXBITS + 1);
            var offs = new utils.Buf16(MAXBITS + 1);
            var extra = null;
            var extra_index = 0;
            var here_bits, here_op, here_val;
            for (len = 0; len <= MAXBITS; len++) {
                count[len] = 0;
            }
            for (sym = 0; sym < codes; sym++) {
                count[lens[lens_index + sym]]++;
            }
            root = bits;
            for (max = MAXBITS; max >= 1; max--) {
                if (count[max] !== 0) {
                    break;
                }
            }
            if (root > max) {
                root = max;
            }
            if (max === 0) {
                table[table_index++] = 1 << 24 | 64 << 16 | 0;
                table[table_index++] = 1 << 24 | 64 << 16 | 0;
                opts.bits = 1;
                return 0;
            }
            for (min = 1; min < max; min++) {
                if (count[min] !== 0) {
                    break;
                }
            }
            if (root < min) {
                root = min;
            }
            left = 1;
            for (len = 1; len <= MAXBITS; len++) {
                left <<= 1;
                left -= count[len];
                if (left < 0) {
                    return -1;
                }
            }
            if (left > 0 && (type === CODES || max !== 1)) {
                return -1;
            }
            offs[1] = 0;
            for (len = 1; len < MAXBITS; len++) {
                offs[len + 1] = offs[len] + count[len];
            }
            for (sym = 0; sym < codes; sym++) {
                if (lens[lens_index + sym] !== 0) {
                    work[offs[lens[lens_index + sym]]++] = sym;
                }
            }
            if (type === CODES) {
                base = extra = work;
                end = 19;
            } else if (type === LENS) {
                base = lbase;
                base_index -= 257;
                extra = lext;
                extra_index -= 257;
                end = 256;
            } else {
                base = dbase;
                extra = dext;
                end = -1;
            }
            huff = 0;
            sym = 0;
            len = min;
            next = table_index;
            curr = root;
            drop = 0;
            low = -1;
            used = 1 << root;
            mask = used - 1;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                return 1;
            }
            for (;;) {
                here_bits = len - drop;
                if (work[sym] < end) {
                    here_op = 0;
                    here_val = work[sym];
                } else if (work[sym] > end) {
                    here_op = extra[extra_index + work[sym]];
                    here_val = base[base_index + work[sym]];
                } else {
                    here_op = 32 + 64;
                    here_val = 0;
                }
                incr = 1 << len - drop;
                fill = 1 << curr;
                min = fill;
                do {
                    fill -= incr;
                    table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
                } while (fill !== 0);
                incr = 1 << len - 1;
                while (huff & incr) {
                    incr >>= 1;
                }
                if (incr !== 0) {
                    huff &= incr - 1;
                    huff += incr;
                } else {
                    huff = 0;
                }
                sym++;
                if (--count[len] === 0) {
                    if (len === max) {
                        break;
                    }
                    len = lens[lens_index + work[sym]];
                }
                if (len > root && (huff & mask) !== low) {
                    if (drop === 0) {
                        drop = root;
                    }
                    next += min;
                    curr = len - drop;
                    left = 1 << curr;
                    while (curr + drop < max) {
                        left -= count[curr + drop];
                        if (left <= 0) {
                            break;
                        }
                        curr++;
                        left <<= 1;
                    }
                    used += 1 << curr;
                    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                        return 1;
                    }
                    low = huff & mask;
                    table[low] = root << 24 | curr << 16 | next - table_index | 0;
                }
            }
            if (huff !== 0) {
                table[next + huff] = len - drop << 24 | 64 << 16 | 0;
            }
            opts.bits = root;
            return 0;
        };
    }, {
        "../utils/common": 120
    } ],
    130: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version"
        };
    }, {} ],
    131: [ function(require, module, exports) {
        "use strict";
        var utils = require("../utils/common");
        var Z_FIXED = 4;
        var Z_BINARY = 0;
        var Z_TEXT = 1;
        var Z_UNKNOWN = 2;
        function zero(buf) {
            var len = buf.length;
            while (--len >= 0) {
                buf[len] = 0;
            }
        }
        var STORED_BLOCK = 0;
        var STATIC_TREES = 1;
        var DYN_TREES = 2;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var Buf_size = 16;
        var MAX_BL_BITS = 7;
        var END_BLOCK = 256;
        var REP_3_6 = 16;
        var REPZ_3_10 = 17;
        var REPZ_11_138 = 18;
        var extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ];
        var extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
        var extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ];
        var bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
        var DIST_CODE_LEN = 512;
        var static_ltree = new Array((L_CODES + 2) * 2);
        zero(static_ltree);
        var static_dtree = new Array(D_CODES * 2);
        zero(static_dtree);
        var _dist_code = new Array(DIST_CODE_LEN);
        zero(_dist_code);
        var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
        zero(_length_code);
        var base_length = new Array(LENGTH_CODES);
        zero(base_length);
        var base_dist = new Array(D_CODES);
        zero(base_dist);
        function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
            this.static_tree = static_tree;
            this.extra_bits = extra_bits;
            this.extra_base = extra_base;
            this.elems = elems;
            this.max_length = max_length;
            this.has_stree = static_tree && static_tree.length;
        }
        var static_l_desc;
        var static_d_desc;
        var static_bl_desc;
        function TreeDesc(dyn_tree, stat_desc) {
            this.dyn_tree = dyn_tree;
            this.max_code = 0;
            this.stat_desc = stat_desc;
        }
        function d_code(dist) {
            return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
        }
        function put_short(s, w) {
            s.pending_buf[s.pending++] = w & 255;
            s.pending_buf[s.pending++] = w >>> 8 & 255;
        }
        function send_bits(s, value, length) {
            if (s.bi_valid > Buf_size - length) {
                s.bi_buf |= value << s.bi_valid & 65535;
                put_short(s, s.bi_buf);
                s.bi_buf = value >> Buf_size - s.bi_valid;
                s.bi_valid += length - Buf_size;
            } else {
                s.bi_buf |= value << s.bi_valid & 65535;
                s.bi_valid += length;
            }
        }
        function send_code(s, c, tree) {
            send_bits(s, tree[c * 2], tree[c * 2 + 1]);
        }
        function bi_reverse(code, len) {
            var res = 0;
            do {
                res |= code & 1;
                code >>>= 1;
                res <<= 1;
            } while (--len > 0);
            return res >>> 1;
        }
        function bi_flush(s) {
            if (s.bi_valid === 16) {
                put_short(s, s.bi_buf);
                s.bi_buf = 0;
                s.bi_valid = 0;
            } else if (s.bi_valid >= 8) {
                s.pending_buf[s.pending++] = s.bi_buf & 255;
                s.bi_buf >>= 8;
                s.bi_valid -= 8;
            }
        }
        function gen_bitlen(s, desc) {
            var tree = desc.dyn_tree;
            var max_code = desc.max_code;
            var stree = desc.stat_desc.static_tree;
            var has_stree = desc.stat_desc.has_stree;
            var extra = desc.stat_desc.extra_bits;
            var base = desc.stat_desc.extra_base;
            var max_length = desc.stat_desc.max_length;
            var h;
            var n, m;
            var bits;
            var xbits;
            var f;
            var overflow = 0;
            for (bits = 0; bits <= MAX_BITS; bits++) {
                s.bl_count[bits] = 0;
            }
            tree[s.heap[s.heap_max] * 2 + 1] = 0;
            for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
                n = s.heap[h];
                bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
                if (bits > max_length) {
                    bits = max_length;
                    overflow++;
                }
                tree[n * 2 + 1] = bits;
                if (n > max_code) {
                    continue;
                }
                s.bl_count[bits]++;
                xbits = 0;
                if (n >= base) {
                    xbits = extra[n - base];
                }
                f = tree[n * 2];
                s.opt_len += f * (bits + xbits);
                if (has_stree) {
                    s.static_len += f * (stree[n * 2 + 1] + xbits);
                }
            }
            if (overflow === 0) {
                return;
            }
            do {
                bits = max_length - 1;
                while (s.bl_count[bits] === 0) {
                    bits--;
                }
                s.bl_count[bits]--;
                s.bl_count[bits + 1] += 2;
                s.bl_count[max_length]--;
                overflow -= 2;
            } while (overflow > 0);
            for (bits = max_length; bits !== 0; bits--) {
                n = s.bl_count[bits];
                while (n !== 0) {
                    m = s.heap[--h];
                    if (m > max_code) {
                        continue;
                    }
                    if (tree[m * 2 + 1] !== bits) {
                        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                        tree[m * 2 + 1] = bits;
                    }
                    n--;
                }
            }
        }
        function gen_codes(tree, max_code, bl_count) {
            var next_code = new Array(MAX_BITS + 1);
            var code = 0;
            var bits;
            var n;
            for (bits = 1; bits <= MAX_BITS; bits++) {
                next_code[bits] = code = code + bl_count[bits - 1] << 1;
            }
            for (n = 0; n <= max_code; n++) {
                var len = tree[n * 2 + 1];
                if (len === 0) {
                    continue;
                }
                tree[n * 2] = bi_reverse(next_code[len]++, len);
            }
        }
        function tr_static_init() {
            var n;
            var bits;
            var length;
            var code;
            var dist;
            var bl_count = new Array(MAX_BITS + 1);
            length = 0;
            for (code = 0; code < LENGTH_CODES - 1; code++) {
                base_length[code] = length;
                for (n = 0; n < 1 << extra_lbits[code]; n++) {
                    _length_code[length++] = code;
                }
            }
            _length_code[length - 1] = code;
            dist = 0;
            for (code = 0; code < 16; code++) {
                base_dist[code] = dist;
                for (n = 0; n < 1 << extra_dbits[code]; n++) {
                    _dist_code[dist++] = code;
                }
            }
            dist >>= 7;
            for (;code < D_CODES; code++) {
                base_dist[code] = dist << 7;
                for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                    _dist_code[256 + dist++] = code;
                }
            }
            for (bits = 0; bits <= MAX_BITS; bits++) {
                bl_count[bits] = 0;
            }
            n = 0;
            while (n <= 143) {
                static_ltree[n * 2 + 1] = 8;
                n++;
                bl_count[8]++;
            }
            while (n <= 255) {
                static_ltree[n * 2 + 1] = 9;
                n++;
                bl_count[9]++;
            }
            while (n <= 279) {
                static_ltree[n * 2 + 1] = 7;
                n++;
                bl_count[7]++;
            }
            while (n <= 287) {
                static_ltree[n * 2 + 1] = 8;
                n++;
                bl_count[8]++;
            }
            gen_codes(static_ltree, L_CODES + 1, bl_count);
            for (n = 0; n < D_CODES; n++) {
                static_dtree[n * 2 + 1] = 5;
                static_dtree[n * 2] = bi_reverse(n, 5);
            }
            static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
            static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
            static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
        }
        function init_block(s) {
            var n;
            for (n = 0; n < L_CODES; n++) {
                s.dyn_ltree[n * 2] = 0;
            }
            for (n = 0; n < D_CODES; n++) {
                s.dyn_dtree[n * 2] = 0;
            }
            for (n = 0; n < BL_CODES; n++) {
                s.bl_tree[n * 2] = 0;
            }
            s.dyn_ltree[END_BLOCK * 2] = 1;
            s.opt_len = s.static_len = 0;
            s.last_lit = s.matches = 0;
        }
        function bi_windup(s) {
            if (s.bi_valid > 8) {
                put_short(s, s.bi_buf);
            } else if (s.bi_valid > 0) {
                s.pending_buf[s.pending++] = s.bi_buf;
            }
            s.bi_buf = 0;
            s.bi_valid = 0;
        }
        function copy_block(s, buf, len, header) {
            bi_windup(s);
            if (header) {
                put_short(s, len);
                put_short(s, ~len);
            }
            utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
            s.pending += len;
        }
        function smaller(tree, n, m, depth) {
            var _n2 = n * 2;
            var _m2 = m * 2;
            return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
        }
        function pqdownheap(s, tree, k) {
            var v = s.heap[k];
            var j = k << 1;
            while (j <= s.heap_len) {
                if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                    j++;
                }
                if (smaller(tree, v, s.heap[j], s.depth)) {
                    break;
                }
                s.heap[k] = s.heap[j];
                k = j;
                j <<= 1;
            }
            s.heap[k] = v;
        }
        function compress_block(s, ltree, dtree) {
            var dist;
            var lc;
            var lx = 0;
            var code;
            var extra;
            if (s.last_lit !== 0) {
                do {
                    dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
                    lc = s.pending_buf[s.l_buf + lx];
                    lx++;
                    if (dist === 0) {
                        send_code(s, lc, ltree);
                    } else {
                        code = _length_code[lc];
                        send_code(s, code + LITERALS + 1, ltree);
                        extra = extra_lbits[code];
                        if (extra !== 0) {
                            lc -= base_length[code];
                            send_bits(s, lc, extra);
                        }
                        dist--;
                        code = d_code(dist);
                        send_code(s, code, dtree);
                        extra = extra_dbits[code];
                        if (extra !== 0) {
                            dist -= base_dist[code];
                            send_bits(s, dist, extra);
                        }
                    }
                } while (lx < s.last_lit);
            }
            send_code(s, END_BLOCK, ltree);
        }
        function build_tree(s, desc) {
            var tree = desc.dyn_tree;
            var stree = desc.stat_desc.static_tree;
            var has_stree = desc.stat_desc.has_stree;
            var elems = desc.stat_desc.elems;
            var n, m;
            var max_code = -1;
            var node;
            s.heap_len = 0;
            s.heap_max = HEAP_SIZE;
            for (n = 0; n < elems; n++) {
                if (tree[n * 2] !== 0) {
                    s.heap[++s.heap_len] = max_code = n;
                    s.depth[n] = 0;
                } else {
                    tree[n * 2 + 1] = 0;
                }
            }
            while (s.heap_len < 2) {
                node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
                tree[node * 2] = 1;
                s.depth[node] = 0;
                s.opt_len--;
                if (has_stree) {
                    s.static_len -= stree[node * 2 + 1];
                }
            }
            desc.max_code = max_code;
            for (n = s.heap_len >> 1; n >= 1; n--) {
                pqdownheap(s, tree, n);
            }
            node = elems;
            do {
                n = s.heap[1];
                s.heap[1] = s.heap[s.heap_len--];
                pqdownheap(s, tree, 1);
                m = s.heap[1];
                s.heap[--s.heap_max] = n;
                s.heap[--s.heap_max] = m;
                tree[node * 2] = tree[n * 2] + tree[m * 2];
                s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
                tree[n * 2 + 1] = tree[m * 2 + 1] = node;
                s.heap[1] = node++;
                pqdownheap(s, tree, 1);
            } while (s.heap_len >= 2);
            s.heap[--s.heap_max] = s.heap[1];
            gen_bitlen(s, desc);
            gen_codes(tree, max_code, s.bl_count);
        }
        function scan_tree(s, tree, max_code) {
            var n;
            var prevlen = -1;
            var curlen;
            var nextlen = tree[0 * 2 + 1];
            var count = 0;
            var max_count = 7;
            var min_count = 4;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            }
            tree[(max_code + 1) * 2 + 1] = 65535;
            for (n = 0; n <= max_code; n++) {
                curlen = nextlen;
                nextlen = tree[(n + 1) * 2 + 1];
                if (++count < max_count && curlen === nextlen) {
                    continue;
                } else if (count < min_count) {
                    s.bl_tree[curlen * 2] += count;
                } else if (curlen !== 0) {
                    if (curlen !== prevlen) {
                        s.bl_tree[curlen * 2]++;
                    }
                    s.bl_tree[REP_3_6 * 2]++;
                } else if (count <= 10) {
                    s.bl_tree[REPZ_3_10 * 2]++;
                } else {
                    s.bl_tree[REPZ_11_138 * 2]++;
                }
                count = 0;
                prevlen = curlen;
                if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                } else if (curlen === nextlen) {
                    max_count = 6;
                    min_count = 3;
                } else {
                    max_count = 7;
                    min_count = 4;
                }
            }
        }
        function send_tree(s, tree, max_code) {
            var n;
            var prevlen = -1;
            var curlen;
            var nextlen = tree[0 * 2 + 1];
            var count = 0;
            var max_count = 7;
            var min_count = 4;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            }
            for (n = 0; n <= max_code; n++) {
                curlen = nextlen;
                nextlen = tree[(n + 1) * 2 + 1];
                if (++count < max_count && curlen === nextlen) {
                    continue;
                } else if (count < min_count) {
                    do {
                        send_code(s, curlen, s.bl_tree);
                    } while (--count !== 0);
                } else if (curlen !== 0) {
                    if (curlen !== prevlen) {
                        send_code(s, curlen, s.bl_tree);
                        count--;
                    }
                    send_code(s, REP_3_6, s.bl_tree);
                    send_bits(s, count - 3, 2);
                } else if (count <= 10) {
                    send_code(s, REPZ_3_10, s.bl_tree);
                    send_bits(s, count - 3, 3);
                } else {
                    send_code(s, REPZ_11_138, s.bl_tree);
                    send_bits(s, count - 11, 7);
                }
                count = 0;
                prevlen = curlen;
                if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                } else if (curlen === nextlen) {
                    max_count = 6;
                    min_count = 3;
                } else {
                    max_count = 7;
                    min_count = 4;
                }
            }
        }
        function build_bl_tree(s) {
            var max_blindex;
            scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
            scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
            build_tree(s, s.bl_desc);
            for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
                if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                    break;
                }
            }
            s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
            return max_blindex;
        }
        function send_all_trees(s, lcodes, dcodes, blcodes) {
            var rank;
            send_bits(s, lcodes - 257, 5);
            send_bits(s, dcodes - 1, 5);
            send_bits(s, blcodes - 4, 4);
            for (rank = 0; rank < blcodes; rank++) {
                send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
            }
            send_tree(s, s.dyn_ltree, lcodes - 1);
            send_tree(s, s.dyn_dtree, dcodes - 1);
        }
        function detect_data_type(s) {
            var black_mask = 4093624447;
            var n;
            for (n = 0; n <= 31; n++, black_mask >>>= 1) {
                if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                    return Z_BINARY;
                }
            }
            if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
                return Z_TEXT;
            }
            for (n = 32; n < LITERALS; n++) {
                if (s.dyn_ltree[n * 2] !== 0) {
                    return Z_TEXT;
                }
            }
            return Z_BINARY;
        }
        var static_init_done = false;
        function _tr_init(s) {
            if (!static_init_done) {
                tr_static_init();
                static_init_done = true;
            }
            s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
            s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
            s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
            s.bi_buf = 0;
            s.bi_valid = 0;
            init_block(s);
        }
        function _tr_stored_block(s, buf, stored_len, last) {
            send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
            copy_block(s, buf, stored_len, true);
        }
        function _tr_align(s) {
            send_bits(s, STATIC_TREES << 1, 3);
            send_code(s, END_BLOCK, static_ltree);
            bi_flush(s);
        }
        function _tr_flush_block(s, buf, stored_len, last) {
            var opt_lenb, static_lenb;
            var max_blindex = 0;
            if (s.level > 0) {
                if (s.strm.data_type === Z_UNKNOWN) {
                    s.strm.data_type = detect_data_type(s);
                }
                build_tree(s, s.l_desc);
                build_tree(s, s.d_desc);
                max_blindex = build_bl_tree(s);
                opt_lenb = s.opt_len + 3 + 7 >>> 3;
                static_lenb = s.static_len + 3 + 7 >>> 3;
                if (static_lenb <= opt_lenb) {
                    opt_lenb = static_lenb;
                }
            } else {
                opt_lenb = static_lenb = stored_len + 5;
            }
            if (stored_len + 4 <= opt_lenb && buf !== -1) {
                _tr_stored_block(s, buf, stored_len, last);
            } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
                send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
                compress_block(s, static_ltree, static_dtree);
            } else {
                send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
                send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
                compress_block(s, s.dyn_ltree, s.dyn_dtree);
            }
            init_block(s);
            if (last) {
                bi_windup(s);
            }
        }
        function _tr_tally(s, dist, lc) {
            s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
            s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
            s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
            s.last_lit++;
            if (dist === 0) {
                s.dyn_ltree[lc * 2]++;
            } else {
                s.matches++;
                dist--;
                s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
                s.dyn_dtree[d_code(dist) * 2]++;
            }
            return s.last_lit === s.lit_bufsize - 1;
        }
        exports._tr_init = _tr_init;
        exports._tr_stored_block = _tr_stored_block;
        exports._tr_flush_block = _tr_flush_block;
        exports._tr_tally = _tr_tally;
        exports._tr_align = _tr_align;
    }, {
        "../utils/common": 120
    } ],
    132: [ function(require, module, exports) {
        "use strict";
        function ZStream() {
            this.input = null;
            this.next_in = 0;
            this.avail_in = 0;
            this.total_in = 0;
            this.output = null;
            this.next_out = 0;
            this.avail_out = 0;
            this.total_out = 0;
            this.msg = "";
            this.state = null;
            this.data_type = 2;
            this.adler = 0;
        }
        module.exports = ZStream;
    }, {} ],
    133: [ function(require, module, exports) {
        (function(Buffer) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            const utils_1 = require("./utils");
            const DEFAULT_SMARTBUFFER_SIZE = 4096;
            const DEFAULT_SMARTBUFFER_ENCODING = "utf8";
            class SmartBuffer {
                constructor(options) {
                    this.length = 0;
                    this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
                    this._writeOffset = 0;
                    this._readOffset = 0;
                    if (SmartBuffer.isSmartBufferOptions(options)) {
                        if (options.encoding) {
                            utils_1.checkEncoding(options.encoding);
                            this._encoding = options.encoding;
                        }
                        if (options.size) {
                            if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
                                this._buff = Buffer.allocUnsafe(options.size);
                            } else {
                                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
                            }
                        } else if (options.buff) {
                            if (options.buff instanceof Buffer) {
                                this._buff = options.buff;
                                this.length = options.buff.length;
                            } else {
                                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
                            }
                        } else {
                            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
                        }
                    } else {
                        if (typeof options !== "undefined") {
                            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
                        }
                        this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
                    }
                }
                static fromSize(size, encoding) {
                    return new this({
                        size: size,
                        encoding: encoding
                    });
                }
                static fromBuffer(buff, encoding) {
                    return new this({
                        buff: buff,
                        encoding: encoding
                    });
                }
                static fromOptions(options) {
                    return new this(options);
                }
                static isSmartBufferOptions(options) {
                    const castOptions = options;
                    return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);
                }
                readInt8(offset) {
                    return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
                }
                readInt16BE(offset) {
                    return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
                }
                readInt16LE(offset) {
                    return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
                }
                readInt32BE(offset) {
                    return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
                }
                readInt32LE(offset) {
                    return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
                }
                readBigInt64BE(offset) {
                    utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
                    return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
                }
                readBigInt64LE(offset) {
                    utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
                    return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
                }
                writeInt8(value, offset) {
                    this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
                    return this;
                }
                insertInt8(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
                }
                writeInt16BE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
                }
                insertInt16BE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
                }
                writeInt16LE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
                }
                insertInt16LE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
                }
                writeInt32BE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
                }
                insertInt32BE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
                }
                writeInt32LE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
                }
                insertInt32LE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
                }
                writeBigInt64BE(value, offset) {
                    utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
                    return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
                }
                insertBigInt64BE(value, offset) {
                    utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
                    return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
                }
                writeBigInt64LE(value, offset) {
                    utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
                    return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
                }
                insertBigInt64LE(value, offset) {
                    utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
                    return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
                }
                readUInt8(offset) {
                    return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
                }
                readUInt16BE(offset) {
                    return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
                }
                readUInt16LE(offset) {
                    return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
                }
                readUInt32BE(offset) {
                    return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
                }
                readUInt32LE(offset) {
                    return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
                }
                readBigUInt64BE(offset) {
                    utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
                    return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
                }
                readBigUInt64LE(offset) {
                    utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
                    return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
                }
                writeUInt8(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
                }
                insertUInt8(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
                }
                writeUInt16BE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
                }
                insertUInt16BE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
                }
                writeUInt16LE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
                }
                insertUInt16LE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
                }
                writeUInt32BE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
                }
                insertUInt32BE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
                }
                writeUInt32LE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
                }
                insertUInt32LE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
                }
                writeBigUInt64BE(value, offset) {
                    utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
                    return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
                }
                insertBigUInt64BE(value, offset) {
                    utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
                    return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
                }
                writeBigUInt64LE(value, offset) {
                    utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
                    return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
                }
                insertBigUInt64LE(value, offset) {
                    utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
                    return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
                }
                readFloatBE(offset) {
                    return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
                }
                readFloatLE(offset) {
                    return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
                }
                writeFloatBE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
                }
                insertFloatBE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
                }
                writeFloatLE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
                }
                insertFloatLE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
                }
                readDoubleBE(offset) {
                    return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
                }
                readDoubleLE(offset) {
                    return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
                }
                writeDoubleBE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
                }
                insertDoubleBE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
                }
                writeDoubleLE(value, offset) {
                    return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
                }
                insertDoubleLE(value, offset) {
                    return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
                }
                readString(arg1, encoding) {
                    let lengthVal;
                    if (typeof arg1 === "number") {
                        utils_1.checkLengthValue(arg1);
                        lengthVal = Math.min(arg1, this.length - this._readOffset);
                    } else {
                        encoding = arg1;
                        lengthVal = this.length - this._readOffset;
                    }
                    if (typeof encoding !== "undefined") {
                        utils_1.checkEncoding(encoding);
                    }
                    const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
                    this._readOffset += lengthVal;
                    return value;
                }
                insertString(value, offset, encoding) {
                    utils_1.checkOffsetValue(offset);
                    return this._handleString(value, true, offset, encoding);
                }
                writeString(value, arg2, encoding) {
                    return this._handleString(value, false, arg2, encoding);
                }
                readStringNT(encoding) {
                    if (typeof encoding !== "undefined") {
                        utils_1.checkEncoding(encoding);
                    }
                    let nullPos = this.length;
                    for (let i = this._readOffset; i < this.length; i++) {
                        if (this._buff[i] === 0) {
                            nullPos = i;
                            break;
                        }
                    }
                    const value = this._buff.slice(this._readOffset, nullPos);
                    this._readOffset = nullPos + 1;
                    return value.toString(encoding || this._encoding);
                }
                insertStringNT(value, offset, encoding) {
                    utils_1.checkOffsetValue(offset);
                    this.insertString(value, offset, encoding);
                    this.insertUInt8(0, offset + value.length);
                    return this;
                }
                writeStringNT(value, arg2, encoding) {
                    this.writeString(value, arg2, encoding);
                    this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
                    return this;
                }
                readBuffer(length) {
                    if (typeof length !== "undefined") {
                        utils_1.checkLengthValue(length);
                    }
                    const lengthVal = typeof length === "number" ? length : this.length;
                    const endPoint = Math.min(this.length, this._readOffset + lengthVal);
                    const value = this._buff.slice(this._readOffset, endPoint);
                    this._readOffset = endPoint;
                    return value;
                }
                insertBuffer(value, offset) {
                    utils_1.checkOffsetValue(offset);
                    return this._handleBuffer(value, true, offset);
                }
                writeBuffer(value, offset) {
                    return this._handleBuffer(value, false, offset);
                }
                readBufferNT() {
                    let nullPos = this.length;
                    for (let i = this._readOffset; i < this.length; i++) {
                        if (this._buff[i] === 0) {
                            nullPos = i;
                            break;
                        }
                    }
                    const value = this._buff.slice(this._readOffset, nullPos);
                    this._readOffset = nullPos + 1;
                    return value;
                }
                insertBufferNT(value, offset) {
                    utils_1.checkOffsetValue(offset);
                    this.insertBuffer(value, offset);
                    this.insertUInt8(0, offset + value.length);
                    return this;
                }
                writeBufferNT(value, offset) {
                    if (typeof offset !== "undefined") {
                        utils_1.checkOffsetValue(offset);
                    }
                    this.writeBuffer(value, offset);
                    this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
                    return this;
                }
                clear() {
                    this._writeOffset = 0;
                    this._readOffset = 0;
                    this.length = 0;
                    return this;
                }
                remaining() {
                    return this.length - this._readOffset;
                }
                get readOffset() {
                    return this._readOffset;
                }
                set readOffset(offset) {
                    utils_1.checkOffsetValue(offset);
                    utils_1.checkTargetOffset(offset, this);
                    this._readOffset = offset;
                }
                get writeOffset() {
                    return this._writeOffset;
                }
                set writeOffset(offset) {
                    utils_1.checkOffsetValue(offset);
                    utils_1.checkTargetOffset(offset, this);
                    this._writeOffset = offset;
                }
                get encoding() {
                    return this._encoding;
                }
                set encoding(encoding) {
                    utils_1.checkEncoding(encoding);
                    this._encoding = encoding;
                }
                get internalBuffer() {
                    return this._buff;
                }
                toBuffer() {
                    return this._buff.slice(0, this.length);
                }
                toString(encoding) {
                    const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
                    utils_1.checkEncoding(encodingVal);
                    return this._buff.toString(encodingVal, 0, this.length);
                }
                destroy() {
                    this.clear();
                    return this;
                }
                _handleString(value, isInsert, arg3, encoding) {
                    let offsetVal = this._writeOffset;
                    let encodingVal = this._encoding;
                    if (typeof arg3 === "number") {
                        offsetVal = arg3;
                    } else if (typeof arg3 === "string") {
                        utils_1.checkEncoding(arg3);
                        encodingVal = arg3;
                    }
                    if (typeof encoding === "string") {
                        utils_1.checkEncoding(encoding);
                        encodingVal = encoding;
                    }
                    const byteLength = Buffer.byteLength(value, encodingVal);
                    if (isInsert) {
                        this.ensureInsertable(byteLength, offsetVal);
                    } else {
                        this._ensureWriteable(byteLength, offsetVal);
                    }
                    this._buff.write(value, offsetVal, byteLength, encodingVal);
                    if (isInsert) {
                        this._writeOffset += byteLength;
                    } else {
                        if (typeof arg3 === "number") {
                            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
                        } else {
                            this._writeOffset += byteLength;
                        }
                    }
                    return this;
                }
                _handleBuffer(value, isInsert, offset) {
                    const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
                    if (isInsert) {
                        this.ensureInsertable(value.length, offsetVal);
                    } else {
                        this._ensureWriteable(value.length, offsetVal);
                    }
                    value.copy(this._buff, offsetVal);
                    if (isInsert) {
                        this._writeOffset += value.length;
                    } else {
                        if (typeof offset === "number") {
                            this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
                        } else {
                            this._writeOffset += value.length;
                        }
                    }
                    return this;
                }
                ensureReadable(length, offset) {
                    let offsetVal = this._readOffset;
                    if (typeof offset !== "undefined") {
                        utils_1.checkOffsetValue(offset);
                        offsetVal = offset;
                    }
                    if (offsetVal < 0 || offsetVal + length > this.length) {
                        throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
                    }
                }
                ensureInsertable(dataLength, offset) {
                    utils_1.checkOffsetValue(offset);
                    this._ensureCapacity(this.length + dataLength);
                    if (offset < this.length) {
                        this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
                    }
                    if (offset + dataLength > this.length) {
                        this.length = offset + dataLength;
                    } else {
                        this.length += dataLength;
                    }
                }
                _ensureWriteable(dataLength, offset) {
                    const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
                    this._ensureCapacity(offsetVal + dataLength);
                    if (offsetVal + dataLength > this.length) {
                        this.length = offsetVal + dataLength;
                    }
                }
                _ensureCapacity(minLength) {
                    const oldLength = this._buff.length;
                    if (minLength > oldLength) {
                        let data = this._buff;
                        let newLength = oldLength * 3 / 2 + 1;
                        if (newLength < minLength) {
                            newLength = minLength;
                        }
                        this._buff = Buffer.allocUnsafe(newLength);
                        data.copy(this._buff, 0, 0, oldLength);
                    }
                }
                _readNumberValue(func, byteSize, offset) {
                    this.ensureReadable(byteSize, offset);
                    const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
                    if (typeof offset === "undefined") {
                        this._readOffset += byteSize;
                    }
                    return value;
                }
                _insertNumberValue(func, byteSize, value, offset) {
                    utils_1.checkOffsetValue(offset);
                    this.ensureInsertable(byteSize, offset);
                    func.call(this._buff, value, offset);
                    this._writeOffset += byteSize;
                    return this;
                }
                _writeNumberValue(func, byteSize, value, offset) {
                    if (typeof offset === "number") {
                        if (offset < 0) {
                            throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
                        }
                        utils_1.checkOffsetValue(offset);
                    }
                    const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
                    this._ensureWriteable(byteSize, offsetVal);
                    func.call(this._buff, value, offsetVal);
                    if (typeof offset === "number") {
                        this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
                    } else {
                        this._writeOffset += byteSize;
                    }
                    return this;
                }
            }
            exports.SmartBuffer = SmartBuffer;
        }).call(this, require("buffer").Buffer);
    }, {
        "./utils": 134,
        buffer: 44
    } ],
    134: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const buffer_1 = require("buffer");
        const ERRORS = {
            INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
            INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
            INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
            INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
            INVALID_OFFSET: "An invalid offset value was provided.",
            INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
            INVALID_LENGTH: "An invalid length value was provided.",
            INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
            INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
            INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
            INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
            INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
        };
        exports.ERRORS = ERRORS;
        function checkEncoding(encoding) {
            if (!buffer_1.Buffer.isEncoding(encoding)) {
                throw new Error(ERRORS.INVALID_ENCODING);
            }
        }
        exports.checkEncoding = checkEncoding;
        function isFiniteInteger(value) {
            return typeof value === "number" && isFinite(value) && isInteger(value);
        }
        exports.isFiniteInteger = isFiniteInteger;
        function checkOffsetOrLengthValue(value, offset) {
            if (typeof value === "number") {
                if (!isFiniteInteger(value) || value < 0) {
                    throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
                }
            } else {
                throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
            }
        }
        function checkLengthValue(length) {
            checkOffsetOrLengthValue(length, false);
        }
        exports.checkLengthValue = checkLengthValue;
        function checkOffsetValue(offset) {
            checkOffsetOrLengthValue(offset, true);
        }
        exports.checkOffsetValue = checkOffsetValue;
        function checkTargetOffset(offset, buff) {
            if (offset < 0 || offset > buff.length) {
                throw new Error(ERRORS.INVALID_TARGET_OFFSET);
            }
        }
        exports.checkTargetOffset = checkTargetOffset;
        function isInteger(value) {
            return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
        }
        function bigIntAndBufferInt64Check(bufferMethod) {
            if (typeof BigInt === "undefined") {
                throw new Error("Platform does not support JS BigInt type.");
            }
            if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
                throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
            }
        }
        exports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
    }, {
        buffer: 44
    } ],
    135: [ function(require, module, exports) {
        function E() {}
        E.prototype = {
            on: function(name, callback, ctx) {
                var e = this.e || (this.e = {});
                (e[name] || (e[name] = [])).push({
                    fn: callback,
                    ctx: ctx
                });
                return this;
            },
            once: function(name, callback, ctx) {
                var self = this;
                function listener() {
                    self.off(name, listener);
                    callback.apply(ctx, arguments);
                }
                listener._ = callback;
                return this.on(name, listener, ctx);
            },
            emit: function(name) {
                var data = [].slice.call(arguments, 1);
                var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
                var i = 0;
                var len = evtArr.length;
                for (i; i < len; i++) {
                    evtArr[i].fn.apply(evtArr[i].ctx, data);
                }
                return this;
            },
            off: function(name, callback) {
                var e = this.e || (this.e = {});
                var evts = e[name];
                var liveEvents = [];
                if (evts && callback) {
                    for (var i = 0, len = evts.length; i < len; i++) {
                        if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
                    }
                }
                liveEvents.length ? e[name] = liveEvents : delete e[name];
                return this;
            }
        };
        module.exports = E;
        module.exports.TinyEmitter = E;
    }, {} ],
    136: [ function(require, module, exports) {
        "use strict";
        (function(root, factory) {
            if (typeof define === "function" && define.amd) {
                define([], factory);
            } else if (typeof exports === "object") {
                module.exports = factory();
            } else {
                root.typed = factory();
            }
        })(this, function() {
            function ok() {
                return true;
            }
            function notOk() {
                return false;
            }
            function undef() {
                return undefined;
            }
            function create() {
                var _types = [ {
                    name: "number",
                    test: function(x) {
                        return typeof x === "number";
                    }
                }, {
                    name: "string",
                    test: function(x) {
                        return typeof x === "string";
                    }
                }, {
                    name: "boolean",
                    test: function(x) {
                        return typeof x === "boolean";
                    }
                }, {
                    name: "Function",
                    test: function(x) {
                        return typeof x === "function";
                    }
                }, {
                    name: "Array",
                    test: Array.isArray
                }, {
                    name: "Date",
                    test: function(x) {
                        return x instanceof Date;
                    }
                }, {
                    name: "RegExp",
                    test: function(x) {
                        return x instanceof RegExp;
                    }
                }, {
                    name: "Object",
                    test: function(x) {
                        return typeof x === "object" && x.constructor === Object;
                    }
                }, {
                    name: "null",
                    test: function(x) {
                        return x === null;
                    }
                }, {
                    name: "undefined",
                    test: function(x) {
                        return x === undefined;
                    }
                } ];
                var anyType = {
                    name: "any",
                    test: ok
                };
                var _ignore = [];
                var _conversions = [];
                var typed = {
                    types: _types,
                    conversions: _conversions,
                    ignore: _ignore
                };
                function findTypeByName(typeName) {
                    var entry = findInArray(typed.types, function(entry) {
                        return entry.name === typeName;
                    });
                    if (entry) {
                        return entry;
                    }
                    if (typeName === "any") {
                        return anyType;
                    }
                    var hint = findInArray(typed.types, function(entry) {
                        return entry.name.toLowerCase() === typeName.toLowerCase();
                    });
                    throw new TypeError('Unknown type "' + typeName + '"' + (hint ? '. Did you mean "' + hint.name + '"?' : ""));
                }
                function findTypeIndex(type) {
                    if (type === anyType) {
                        return 999;
                    }
                    return typed.types.indexOf(type);
                }
                function findTypeName(value) {
                    var entry = findInArray(typed.types, function(entry) {
                        return entry.test(value);
                    });
                    if (entry) {
                        return entry.name;
                    }
                    throw new TypeError("Value has unknown type. Value: " + value);
                }
                function find(fn, signature) {
                    if (!fn.signatures) {
                        throw new TypeError("Function is no typed-function");
                    }
                    var arr;
                    if (typeof signature === "string") {
                        arr = signature.split(",");
                        for (var i = 0; i < arr.length; i++) {
                            arr[i] = arr[i].trim();
                        }
                    } else if (Array.isArray(signature)) {
                        arr = signature;
                    } else {
                        throw new TypeError("String array or a comma separated string expected");
                    }
                    var str = arr.join(",");
                    var match = fn.signatures[str];
                    if (match) {
                        return match;
                    }
                    throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + arr.join(", ") + "))");
                }
                function convert(value, type) {
                    var from = findTypeName(value);
                    if (type === from) {
                        return value;
                    }
                    for (var i = 0; i < typed.conversions.length; i++) {
                        var conversion = typed.conversions[i];
                        if (conversion.from === from && conversion.to === type) {
                            return conversion.convert(value);
                        }
                    }
                    throw new Error("Cannot convert from " + from + " to " + type);
                }
                function stringifyParams(params) {
                    return params.map(function(param) {
                        var typeNames = param.types.map(getTypeName);
                        return (param.restParam ? "..." : "") + typeNames.join("|");
                    }).join(",");
                }
                function parseParam(param, conversions) {
                    var restParam = param.indexOf("...") === 0;
                    var types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
                    var typeNames = types.split("|").map(trim).filter(notEmpty).filter(notIgnore);
                    var matchingConversions = filterConversions(conversions, typeNames);
                    var exactTypes = typeNames.map(function(typeName) {
                        var type = findTypeByName(typeName);
                        return {
                            name: typeName,
                            typeIndex: findTypeIndex(type),
                            test: type.test,
                            conversion: null,
                            conversionIndex: -1
                        };
                    });
                    var convertibleTypes = matchingConversions.map(function(conversion) {
                        var type = findTypeByName(conversion.from);
                        return {
                            name: conversion.from,
                            typeIndex: findTypeIndex(type),
                            test: type.test,
                            conversion: conversion,
                            conversionIndex: conversions.indexOf(conversion)
                        };
                    });
                    return {
                        types: exactTypes.concat(convertibleTypes),
                        restParam: restParam
                    };
                }
                function parseSignature(signature, fn, conversions) {
                    var params = [];
                    if (signature.trim() !== "") {
                        params = signature.split(",").map(trim).map(function(param, index, array) {
                            var parsedParam = parseParam(param, conversions);
                            if (parsedParam.restParam && index !== array.length - 1) {
                                throw new SyntaxError('Unexpected rest parameter "' + param + '": ' + "only allowed for the last parameter");
                            }
                            return parsedParam;
                        });
                    }
                    if (params.some(isInvalidParam)) {
                        return null;
                    }
                    return {
                        params: params,
                        fn: fn
                    };
                }
                function hasRestParam(params) {
                    var param = last(params);
                    return param ? param.restParam : false;
                }
                function hasConversions(param) {
                    return param.types.some(function(type) {
                        return type.conversion != null;
                    });
                }
                function compileTest(param) {
                    if (!param || param.types.length === 0) {
                        return ok;
                    } else if (param.types.length === 1) {
                        return findTypeByName(param.types[0].name).test;
                    } else if (param.types.length === 2) {
                        var test0 = findTypeByName(param.types[0].name).test;
                        var test1 = findTypeByName(param.types[1].name).test;
                        return function or(x) {
                            return test0(x) || test1(x);
                        };
                    } else {
                        var tests = param.types.map(function(type) {
                            return findTypeByName(type.name).test;
                        });
                        return function or(x) {
                            for (var i = 0; i < tests.length; i++) {
                                if (tests[i](x)) {
                                    return true;
                                }
                            }
                            return false;
                        };
                    }
                }
                function compileTests(params) {
                    var tests, test0, test1;
                    if (hasRestParam(params)) {
                        tests = initial(params).map(compileTest);
                        var varIndex = tests.length;
                        var lastTest = compileTest(last(params));
                        var testRestParam = function(args) {
                            for (var i = varIndex; i < args.length; i++) {
                                if (!lastTest(args[i])) {
                                    return false;
                                }
                            }
                            return true;
                        };
                        return function testArgs(args) {
                            for (var i = 0; i < tests.length; i++) {
                                if (!tests[i](args[i])) {
                                    return false;
                                }
                            }
                            return testRestParam(args) && args.length >= varIndex + 1;
                        };
                    } else {
                        if (params.length === 0) {
                            return function testArgs(args) {
                                return args.length === 0;
                            };
                        } else if (params.length === 1) {
                            test0 = compileTest(params[0]);
                            return function testArgs(args) {
                                return test0(args[0]) && args.length === 1;
                            };
                        } else if (params.length === 2) {
                            test0 = compileTest(params[0]);
                            test1 = compileTest(params[1]);
                            return function testArgs(args) {
                                return test0(args[0]) && test1(args[1]) && args.length === 2;
                            };
                        } else {
                            tests = params.map(compileTest);
                            return function testArgs(args) {
                                for (var i = 0; i < tests.length; i++) {
                                    if (!tests[i](args[i])) {
                                        return false;
                                    }
                                }
                                return args.length === tests.length;
                            };
                        }
                    }
                }
                function getParamAtIndex(signature, index) {
                    return index < signature.params.length ? signature.params[index] : hasRestParam(signature.params) ? last(signature.params) : null;
                }
                function getExpectedTypeNames(signature, index, excludeConversions) {
                    var param = getParamAtIndex(signature, index);
                    var types = param ? excludeConversions ? param.types.filter(isExactType) : param.types : [];
                    return types.map(getTypeName);
                }
                function getTypeName(type) {
                    return type.name;
                }
                function isExactType(type) {
                    return type.conversion === null || type.conversion === undefined;
                }
                function mergeExpectedParams(signatures, index) {
                    var typeNames = uniq(flatMap(signatures, function(signature) {
                        return getExpectedTypeNames(signature, index, false);
                    }));
                    return typeNames.indexOf("any") !== -1 ? [ "any" ] : typeNames;
                }
                function createError(name, args, signatures) {
                    var err, expected;
                    var _name = name || "unnamed";
                    var matchingSignatures = signatures;
                    var index;
                    for (index = 0; index < args.length; index++) {
                        var nextMatchingDefs = matchingSignatures.filter(function(signature) {
                            var test = compileTest(getParamAtIndex(signature, index));
                            return (index < signature.params.length || hasRestParam(signature.params)) && test(args[index]);
                        });
                        if (nextMatchingDefs.length === 0) {
                            expected = mergeExpectedParams(matchingSignatures, index);
                            if (expected.length > 0) {
                                var actualType = findTypeName(args[index]);
                                err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualType + ", index: " + index + ")");
                                err.data = {
                                    category: "wrongType",
                                    fn: _name,
                                    index: index,
                                    actual: actualType,
                                    expected: expected
                                };
                                return err;
                            }
                        } else {
                            matchingSignatures = nextMatchingDefs;
                        }
                    }
                    var lengths = matchingSignatures.map(function(signature) {
                        return hasRestParam(signature.params) ? Infinity : signature.params.length;
                    });
                    if (args.length < Math.min.apply(null, lengths)) {
                        expected = mergeExpectedParams(matchingSignatures, index);
                        err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
                        err.data = {
                            category: "tooFewArgs",
                            fn: _name,
                            index: args.length,
                            expected: expected
                        };
                        return err;
                    }
                    var maxLength = Math.max.apply(null, lengths);
                    if (args.length > maxLength) {
                        err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
                        err.data = {
                            category: "tooManyArgs",
                            fn: _name,
                            index: args.length,
                            expectedLength: maxLength
                        };
                        return err;
                    }
                    err = new TypeError('Arguments of type "' + args.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
                    err.data = {
                        category: "mismatch",
                        actual: args.map(findTypeName)
                    };
                    return err;
                }
                function getLowestTypeIndex(param) {
                    var min = 999;
                    for (var i = 0; i < param.types.length; i++) {
                        if (isExactType(param.types[i])) {
                            min = Math.min(min, param.types[i].typeIndex);
                        }
                    }
                    return min;
                }
                function getLowestConversionIndex(param) {
                    var min = 999;
                    for (var i = 0; i < param.types.length; i++) {
                        if (!isExactType(param.types[i])) {
                            min = Math.min(min, param.types[i].conversionIndex);
                        }
                    }
                    return min;
                }
                function compareParams(param1, param2) {
                    var c;
                    c = param1.restParam - param2.restParam;
                    if (c !== 0) {
                        return c;
                    }
                    c = hasConversions(param1) - hasConversions(param2);
                    if (c !== 0) {
                        return c;
                    }
                    c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
                    if (c !== 0) {
                        return c;
                    }
                    return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
                }
                function compareSignatures(signature1, signature2) {
                    var len = Math.min(signature1.params.length, signature2.params.length);
                    var i;
                    var c;
                    c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);
                    if (c !== 0) {
                        return c;
                    }
                    for (i = 0; i < len; i++) {
                        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);
                        if (c !== 0) {
                            return c;
                        }
                    }
                    for (i = 0; i < len; i++) {
                        c = compareParams(signature1.params[i], signature2.params[i]);
                        if (c !== 0) {
                            return c;
                        }
                    }
                    return signature1.params.length - signature2.params.length;
                }
                function filterConversions(conversions, typeNames) {
                    var matches = {};
                    conversions.forEach(function(conversion) {
                        if (typeNames.indexOf(conversion.from) === -1 && typeNames.indexOf(conversion.to) !== -1 && !matches[conversion.from]) {
                            matches[conversion.from] = conversion;
                        }
                    });
                    return Object.keys(matches).map(function(from) {
                        return matches[from];
                    });
                }
                function compileArgsPreprocessing(params, fn) {
                    var fnConvert = fn;
                    if (params.some(hasConversions)) {
                        var restParam = hasRestParam(params);
                        var compiledConversions = params.map(compileArgConversion);
                        fnConvert = function convertArgs() {
                            var args = [];
                            var last = restParam ? arguments.length - 1 : arguments.length;
                            for (var i = 0; i < last; i++) {
                                args[i] = compiledConversions[i](arguments[i]);
                            }
                            if (restParam) {
                                args[last] = arguments[last].map(compiledConversions[last]);
                            }
                            return fn.apply(null, args);
                        };
                    }
                    var fnPreprocess = fnConvert;
                    if (hasRestParam(params)) {
                        var offset = params.length - 1;
                        fnPreprocess = function preprocessRestParams() {
                            return fnConvert.apply(null, slice(arguments, 0, offset).concat([ slice(arguments, offset) ]));
                        };
                    }
                    return fnPreprocess;
                }
                function compileArgConversion(param) {
                    var test0, test1, conversion0, conversion1;
                    var tests = [];
                    var conversions = [];
                    param.types.forEach(function(type) {
                        if (type.conversion) {
                            tests.push(findTypeByName(type.conversion.from).test);
                            conversions.push(type.conversion.convert);
                        }
                    });
                    switch (conversions.length) {
                      case 0:
                        return function convertArg(arg) {
                            return arg;
                        };

                      case 1:
                        test0 = tests[0];
                        conversion0 = conversions[0];
                        return function convertArg(arg) {
                            if (test0(arg)) {
                                return conversion0(arg);
                            }
                            return arg;
                        };

                      case 2:
                        test0 = tests[0];
                        test1 = tests[1];
                        conversion0 = conversions[0];
                        conversion1 = conversions[1];
                        return function convertArg(arg) {
                            if (test0(arg)) {
                                return conversion0(arg);
                            }
                            if (test1(arg)) {
                                return conversion1(arg);
                            }
                            return arg;
                        };

                      default:
                        return function convertArg(arg) {
                            for (var i = 0; i < conversions.length; i++) {
                                if (tests[i](arg)) {
                                    return conversions[i](arg);
                                }
                            }
                            return arg;
                        };
                    }
                }
                function createSignaturesMap(signatures) {
                    var signaturesMap = {};
                    signatures.forEach(function(signature) {
                        if (!signature.params.some(hasConversions)) {
                            splitParams(signature.params, true).forEach(function(params) {
                                signaturesMap[stringifyParams(params)] = signature.fn;
                            });
                        }
                    });
                    return signaturesMap;
                }
                function splitParams(params, ignoreConversionTypes) {
                    function _splitParams(params, index, types) {
                        if (index < params.length) {
                            var param = params[index];
                            var filteredTypes = ignoreConversionTypes ? param.types.filter(isExactType) : param.types;
                            var typeGroups;
                            if (param.restParam) {
                                var exactTypes = filteredTypes.filter(isExactType);
                                typeGroups = exactTypes.length < filteredTypes.length ? [ exactTypes, filteredTypes ] : [ filteredTypes ];
                            } else {
                                typeGroups = filteredTypes.map(function(type) {
                                    return [ type ];
                                });
                            }
                            return flatMap(typeGroups, function(typeGroup) {
                                return _splitParams(params, index + 1, types.concat([ typeGroup ]));
                            });
                        } else {
                            var splittedParams = types.map(function(type, typeIndex) {
                                return {
                                    types: type,
                                    restParam: typeIndex === params.length - 1 && hasRestParam(params)
                                };
                            });
                            return [ splittedParams ];
                        }
                    }
                    return _splitParams(params, 0, []);
                }
                function hasConflictingParams(signature1, signature2) {
                    var ii = Math.max(signature1.params.length, signature2.params.length);
                    for (var i = 0; i < ii; i++) {
                        var typesNames1 = getExpectedTypeNames(signature1, i, true);
                        var typesNames2 = getExpectedTypeNames(signature2, i, true);
                        if (!hasOverlap(typesNames1, typesNames2)) {
                            return false;
                        }
                    }
                    var len1 = signature1.params.length;
                    var len2 = signature2.params.length;
                    var restParam1 = hasRestParam(signature1.params);
                    var restParam2 = hasRestParam(signature2.params);
                    return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
                }
                function createTypedFunction(name, signaturesMap) {
                    if (Object.keys(signaturesMap).length === 0) {
                        throw new SyntaxError("No signatures provided");
                    }
                    var parsedSignatures = [];
                    Object.keys(signaturesMap).map(function(signature) {
                        return parseSignature(signature, signaturesMap[signature], typed.conversions);
                    }).filter(notNull).forEach(function(parsedSignature) {
                        var conflictingSignature = findInArray(parsedSignatures, function(s) {
                            return hasConflictingParams(s, parsedSignature);
                        });
                        if (conflictingSignature) {
                            throw new TypeError('Conflicting signatures "' + stringifyParams(conflictingSignature.params) + '" and "' + stringifyParams(parsedSignature.params) + '".');
                        }
                        parsedSignatures.push(parsedSignature);
                    });
                    var signatures = flatMap(parsedSignatures, function(parsedSignature) {
                        var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];
                        return params.map(function(params) {
                            return {
                                params: params,
                                fn: parsedSignature.fn
                            };
                        });
                    }).filter(notNull);
                    signatures.sort(compareSignatures);
                    var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
                    var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
                    var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
                    var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
                    var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
                    var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
                    var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
                    var tests = signatures.map(function(signature) {
                        return compileTests(signature.params);
                    });
                    var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
                    var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
                    var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
                    var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
                    var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
                    var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
                    var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
                    var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
                    var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
                    var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
                    var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
                    var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
                    var fns = signatures.map(function(signature) {
                        return compileArgsPreprocessing(signature.params, signature.fn);
                    });
                    var fn0 = ok0 ? fns[0] : undef;
                    var fn1 = ok1 ? fns[1] : undef;
                    var fn2 = ok2 ? fns[2] : undef;
                    var fn3 = ok3 ? fns[3] : undef;
                    var fn4 = ok4 ? fns[4] : undef;
                    var fn5 = ok5 ? fns[5] : undef;
                    var len0 = ok0 ? signatures[0].params.length : -1;
                    var len1 = ok1 ? signatures[1].params.length : -1;
                    var len2 = ok2 ? signatures[2].params.length : -1;
                    var len3 = ok3 ? signatures[3].params.length : -1;
                    var len4 = ok4 ? signatures[4].params.length : -1;
                    var len5 = ok5 ? signatures[5].params.length : -1;
                    var iStart = allOk ? 6 : 0;
                    var iEnd = signatures.length;
                    var generic = function generic() {
                        "use strict";
                        for (var i = iStart; i < iEnd; i++) {
                            if (tests[i](arguments)) {
                                return fns[i].apply(null, arguments);
                            }
                        }
                        throw createError(name, arguments, signatures);
                    };
                    var fn = function fn(arg0, arg1) {
                        "use strict";
                        if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
                            return fn0.apply(null, arguments);
                        }
                        if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
                            return fn1.apply(null, arguments);
                        }
                        if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
                            return fn2.apply(null, arguments);
                        }
                        if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
                            return fn3.apply(null, arguments);
                        }
                        if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
                            return fn4.apply(null, arguments);
                        }
                        if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
                            return fn5.apply(null, arguments);
                        }
                        return generic.apply(null, arguments);
                    };
                    try {
                        Object.defineProperty(fn, "name", {
                            value: name
                        });
                    } catch (err) {}
                    fn.signatures = createSignaturesMap(signatures);
                    return fn;
                }
                function notIgnore(typeName) {
                    return typed.ignore.indexOf(typeName) === -1;
                }
                function trim(str) {
                    return str.trim();
                }
                function notEmpty(str) {
                    return !!str;
                }
                function notNull(value) {
                    return value !== null;
                }
                function isInvalidParam(param) {
                    return param.types.length === 0;
                }
                function initial(arr) {
                    return arr.slice(0, arr.length - 1);
                }
                function last(arr) {
                    return arr[arr.length - 1];
                }
                function slice(arr, start, end) {
                    return Array.prototype.slice.call(arr, start, end);
                }
                function contains(array, item) {
                    return array.indexOf(item) !== -1;
                }
                function hasOverlap(array1, array2) {
                    for (var i = 0; i < array1.length; i++) {
                        if (contains(array2, array1[i])) {
                            return true;
                        }
                    }
                    return false;
                }
                function findInArray(arr, test) {
                    for (var i = 0; i < arr.length; i++) {
                        if (test(arr[i])) {
                            return arr[i];
                        }
                    }
                    return undefined;
                }
                function uniq(arr) {
                    var entries = {};
                    for (var i = 0; i < arr.length; i++) {
                        entries[arr[i]] = true;
                    }
                    return Object.keys(entries);
                }
                function flatMap(arr, callback) {
                    return Array.prototype.concat.apply([], arr.map(callback));
                }
                function getName(fns) {
                    var name = "";
                    for (var i = 0; i < fns.length; i++) {
                        var fn = fns[i];
                        if ((typeof fn.signatures === "object" || typeof fn.signature === "string") && fn.name !== "") {
                            if (name === "") {
                                name = fn.name;
                            } else if (name !== fn.name) {
                                var err = new Error("Function names do not match (expected: " + name + ", actual: " + fn.name + ")");
                                err.data = {
                                    actual: fn.name,
                                    expected: name
                                };
                                throw err;
                            }
                        }
                    }
                    return name;
                }
                function extractSignatures(fns) {
                    var err;
                    var signaturesMap = {};
                    function validateUnique(_signature, _fn) {
                        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {
                            err = new Error('Signature "' + _signature + '" is defined twice');
                            err.data = {
                                signature: _signature
                            };
                            throw err;
                        }
                    }
                    for (var i = 0; i < fns.length; i++) {
                        var fn = fns[i];
                        if (typeof fn.signatures === "object") {
                            for (var signature in fn.signatures) {
                                if (fn.signatures.hasOwnProperty(signature)) {
                                    validateUnique(signature, fn.signatures[signature]);
                                    signaturesMap[signature] = fn.signatures[signature];
                                }
                            }
                        } else if (typeof fn.signature === "string") {
                            validateUnique(fn.signature, fn);
                            signaturesMap[fn.signature] = fn;
                        } else {
                            err = new TypeError("Function is no typed-function (index: " + i + ")");
                            err.data = {
                                index: i
                            };
                            throw err;
                        }
                    }
                    return signaturesMap;
                }
                typed = createTypedFunction("typed", {
                    "string, Object": createTypedFunction,
                    Object: function(signaturesMap) {
                        var fns = [];
                        for (var signature in signaturesMap) {
                            if (signaturesMap.hasOwnProperty(signature)) {
                                fns.push(signaturesMap[signature]);
                            }
                        }
                        var name = getName(fns);
                        return createTypedFunction(name, signaturesMap);
                    },
                    "...Function": function(fns) {
                        return createTypedFunction(getName(fns), extractSignatures(fns));
                    },
                    "string, ...Function": function(name, fns) {
                        return createTypedFunction(name, extractSignatures(fns));
                    }
                });
                typed.create = create;
                typed.types = _types;
                typed.conversions = _conversions;
                typed.ignore = _ignore;
                typed.convert = convert;
                typed.find = find;
                typed.addType = function(type, beforeObjectTest) {
                    if (!type || typeof type.name !== "string" || typeof type.test !== "function") {
                        throw new TypeError("Object with properties {name: string, test: function} expected");
                    }
                    if (beforeObjectTest !== false) {
                        for (var i = 0; i < typed.types.length; i++) {
                            if (typed.types[i].name === "Object") {
                                typed.types.splice(i, 0, type);
                                return;
                            }
                        }
                    }
                    typed.types.push(type);
                };
                typed.addConversion = function(conversion) {
                    if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
                        throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
                    }
                    typed.conversions.push(conversion);
                };
                return typed;
            }
            return create();
        });
    }, {} ],
    137: [ function(require, module, exports) {
        (function(Buffer) {
            "use strict";
            var delta = 2654435769;
            function toUint8Array(v, includeLength) {
                var length = v.length;
                var n = length << 2;
                if (includeLength) {
                    var m = v[length - 1];
                    n -= 4;
                    if (m < n - 3 || m > n) {
                        return null;
                    }
                    n = m;
                }
                var bytes = new Uint8Array(n);
                for (var i = 0; i < n; ++i) {
                    bytes[i] = v[i >> 2] >> ((i & 3) << 3);
                }
                return bytes;
            }
            function toUint32Array(bytes, includeLength) {
                var length = bytes.length;
                var n = length >> 2;
                if ((length & 3) !== 0) {
                    ++n;
                }
                var v;
                if (includeLength) {
                    v = new Uint32Array(n + 1);
                    v[n] = length;
                } else {
                    v = new Uint32Array(n);
                }
                for (var i = 0; i < length; ++i) {
                    v[i >> 2] |= bytes[i] << ((i & 3) << 3);
                }
                return v;
            }
            function mx(sum, y, z, p, e, k) {
                return (z >>> 5 ^ y << 2) + (y >>> 3 ^ z << 4) ^ (sum ^ y) + (k[p & 3 ^ e] ^ z);
            }
            function fixk(k) {
                if (k.length < 16) {
                    var key = new Uint8Array(16);
                    key.set(k);
                    k = key;
                }
                return k;
            }
            function encryptUint32Array(v, k) {
                var length = v.length;
                var n = length - 1;
                var y, z, sum, e, p, q;
                z = v[n];
                sum = 0;
                for (q = Math.floor(6 + 52 / length) | 0; q > 0; --q) {
                    sum += delta;
                    e = sum >>> 2 & 3;
                    for (p = 0; p < n; ++p) {
                        y = v[p + 1];
                        z = v[p] += mx(sum, y, z, p, e, k);
                    }
                    y = v[0];
                    z = v[n] += mx(sum, y, z, p, e, k);
                }
                return v;
            }
            function decryptUint32Array(v, k) {
                var length = v.length;
                var n = length - 1;
                var y, z, sum, e, p, q;
                y = v[0];
                q = Math.floor(6 + 52 / length);
                for (sum = q * delta; sum !== 0; sum -= delta) {
                    e = sum >>> 2 & 3;
                    for (p = n; p > 0; --p) {
                        z = v[p - 1];
                        y = v[p] -= mx(sum, y, z, p, e, k);
                    }
                    z = v[n];
                    y = v[0] -= mx(sum, y, z, p, e, k);
                }
                return v;
            }
            function toBytes(str) {
                var n = str.length;
                var bytes = new Uint8Array(n * 3);
                var length = 0;
                for (var i = 0; i < n; i++) {
                    var codeUnit = str.charCodeAt(i);
                    if (codeUnit < 128) {
                        bytes[length++] = codeUnit;
                    } else if (codeUnit < 2048) {
                        bytes[length++] = 192 | codeUnit >> 6;
                        bytes[length++] = 128 | codeUnit & 63;
                    } else if (codeUnit < 55296 || codeUnit > 57343) {
                        bytes[length++] = 224 | codeUnit >> 12;
                        bytes[length++] = 128 | codeUnit >> 6 & 63;
                        bytes[length++] = 128 | codeUnit & 63;
                    } else {
                        if (i + 1 < n) {
                            var nextCodeUnit = str.charCodeAt(i + 1);
                            if (codeUnit < 56320 && 56320 <= nextCodeUnit && nextCodeUnit <= 57343) {
                                var rune = ((codeUnit & 1023) << 10 | nextCodeUnit & 1023) + 65536;
                                bytes[length++] = 240 | rune >> 18;
                                bytes[length++] = 128 | rune >> 12 & 63;
                                bytes[length++] = 128 | rune >> 6 & 63;
                                bytes[length++] = 128 | rune & 63;
                                i++;
                                continue;
                            }
                        }
                        throw new Error("Malformed string");
                    }
                }
                return bytes.subarray(0, length);
            }
            function toShortString(bytes, n) {
                var charCodes = new Uint16Array(n);
                var i = 0, off = 0;
                for (var len = bytes.length; i < n && off < len; i++) {
                    var unit = bytes[off++];
                    switch (unit >> 4) {
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                        charCodes[i] = unit;
                        break;

                      case 12:
                      case 13:
                        if (off < len) {
                            charCodes[i] = (unit & 31) << 6 | bytes[off++] & 63;
                        } else {
                            throw new Error("Unfinished UTF-8 octet sequence");
                        }
                        break;

                      case 14:
                        if (off + 1 < len) {
                            charCodes[i] = (unit & 15) << 12 | (bytes[off++] & 63) << 6 | bytes[off++] & 63;
                        } else {
                            throw new Error("Unfinished UTF-8 octet sequence");
                        }
                        break;

                      case 15:
                        if (off + 2 < len) {
                            var rune = ((unit & 7) << 18 | (bytes[off++] & 63) << 12 | (bytes[off++] & 63) << 6 | bytes[off++] & 63) - 65536;
                            if (0 <= rune && rune <= 1048575) {
                                charCodes[i++] = rune >> 10 & 1023 | 55296;
                                charCodes[i] = rune & 1023 | 56320;
                            } else {
                                throw new Error("Character outside valid Unicode range: 0x" + rune.toString(16));
                            }
                        } else {
                            throw new Error("Unfinished UTF-8 octet sequence");
                        }
                        break;

                      default:
                        throw new Error("Bad UTF-8 encoding 0x" + unit.toString(16));
                    }
                }
                if (i < n) {
                    charCodes = charCodes.subarray(0, i);
                }
                return String.fromCharCode.apply(String, charCodes);
            }
            function toLongString(bytes, n) {
                var buf = [];
                var charCodes = new Uint16Array(32768);
                var i = 0, off = 0;
                for (var len = bytes.length; i < n && off < len; i++) {
                    var unit = bytes[off++];
                    switch (unit >> 4) {
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                        charCodes[i] = unit;
                        break;

                      case 12:
                      case 13:
                        if (off < len) {
                            charCodes[i] = (unit & 31) << 6 | bytes[off++] & 63;
                        } else {
                            throw new Error("Unfinished UTF-8 octet sequence");
                        }
                        break;

                      case 14:
                        if (off + 1 < len) {
                            charCodes[i] = (unit & 15) << 12 | (bytes[off++] & 63) << 6 | bytes[off++] & 63;
                        } else {
                            throw new Error("Unfinished UTF-8 octet sequence");
                        }
                        break;

                      case 15:
                        if (off + 2 < len) {
                            var rune = ((unit & 7) << 18 | (bytes[off++] & 63) << 12 | (bytes[off++] & 63) << 6 | bytes[off++] & 63) - 65536;
                            if (0 <= rune && rune <= 1048575) {
                                charCodes[i++] = rune >> 10 & 1023 | 55296;
                                charCodes[i] = rune & 1023 | 56320;
                            } else {
                                throw new Error("Character outside valid Unicode range: 0x" + rune.toString(16));
                            }
                        } else {
                            throw new Error("Unfinished UTF-8 octet sequence");
                        }
                        break;

                      default:
                        throw new Error("Bad UTF-8 encoding 0x" + unit.toString(16));
                    }
                    if (i >= 32767 - 1) {
                        var size = i + 1;
                        buf.push(String.fromCharCode.apply(String, charCodes.subarray(0, size)));
                        n -= size;
                        i = -1;
                    }
                }
                if (i > 0) {
                    buf.push(String.fromCharCode.apply(String, charCodes.subarray(0, i)));
                }
                return buf.join("");
            }
            function toString(bytes) {
                var n = bytes.length;
                if (n === 0) return "";
                return n < 32767 ? toShortString(bytes, n) : toLongString(bytes, n);
            }
            function encrypt(data, key) {
                if (typeof data === "string") data = toBytes(data);
                if (typeof key === "string") key = toBytes(key);
                if (data === undefined || data === null || data.length === 0) {
                    return data;
                }
                return toUint8Array(encryptUint32Array(toUint32Array(data, true), toUint32Array(fixk(key), false)), false);
            }
            function encryptToString(data, key) {
                return new Buffer(encrypt(data, key)).toString("base64");
            }
            function decrypt(data, key) {
                if (typeof data === "string") data = new Buffer(data, "base64");
                if (typeof key === "string") key = toBytes(key);
                if (data === undefined || data === null || data.length === 0) {
                    return data;
                }
                return toUint8Array(decryptUint32Array(toUint32Array(data, false), toUint32Array(fixk(key), false)), true);
            }
            function decryptToString(data, key) {
                return toString(decrypt(data, key));
            }
            module.exports = Object.create(null, {
                toBytes: {
                    value: toBytes
                },
                toString: {
                    value: toString
                },
                encrypt: {
                    value: encrypt
                },
                encryptToString: {
                    value: encryptToString
                },
                decrypt: {
                    value: decrypt
                },
                decryptToString: {
                    value: decryptToString
                }
            });
        }).call(this, require("buffer").Buffer);
    }, {
        buffer: 44
    } ],
    138: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "44434U5tKxIF6l16TXeSy2v", "gdk_Binding");
        const EventTrigger = require("../core/gdk_EventTrigger");
        const PoolManager = require("../managers/gdk_PoolManager");
        const __bindSourceObj__ = "__gdk_bindSourceObj__";
        const __bindTargetObj__ = "__gdk_bindTargetObj__";
        const USE_POOL = true;
        const POOL_MAX = 999;
        const POOL_CLEAR_TIME = 30;
        var pool = {
            index: Object.create(null),
            get(c) {
                let k = "__gdk_bind__" + c.name;
                let v = PoolManager.get(k);
                if (!v) {
                    v = new c();
                }
                return v;
            },
            put(v) {
                let k = "__gdk_bind__" + v.constructor.name;
                if (!this.index[k]) {
                    this.index[k] = true;
                    PoolManager.setSize(k, POOL_MAX);
                    PoolManager.setClearTime(k, POOL_CLEAR_TIME);
                }
                PoolManager.put(k, v);
            }
        };
        function BindLinkObj() {}
        Object.defineProperty(BindLinkObj.prototype, "lastChild", {
            get: function() {
                if (this.children) {
                    for (var p in this.children) {
                        return this.children[p].lastChild;
                    }
                } else {
                    return this;
                }
            },
            enumerable: true,
            configurable: true
        });
        BindLinkObj.prototype.getLastChildren = function(arr) {
            arr = arr || [];
            if (this.children) {
                for (var p in this.children) {
                    this.children[p].getLastChildren(arr);
                }
            } else {
                arr.push(this);
            }
            return arr;
        };
        BindLinkObj.prototype.findChild = function(source, prop) {
            if (this.source === source) {
                return this.children[prop];
            }
            if (this.children) {
                var l = void 0;
                for (var p in this.children) {
                    l = this.children[p].findChild(source, prop);
                    if (l) {
                        return l;
                    }
                }
            }
        };
        BindLinkObj.prototype.bind = function(source, bindTargetObj, targetProp) {
            if (this.source !== source) {
                if (this.handler) {
                    this.handler.release();
                    this.handler = null;
                }
                if (this.children && source && typeof source === "object") {
                    this.source = source;
                    this.handler = pool.get(PropChangedHandler);
                    this.handler.bindTargetObj = bindTargetObj;
                    this.handler.targetProp = targetProp;
                    this.handler.on(source[__bindSourceObj__].onPropChanged);
                } else {
                    this.source = null;
                }
            }
        };
        BindLinkObj.prototype.release = function() {
            this.handler && this.handler.release();
            if (this.children) {
                for (var p in this.children) {
                    this.children[p].release();
                }
                this.children = null;
            }
            this.handler = null;
            this.source = null;
            this.parent = null;
            this.sourceProp = null;
            USE_POOL && pool.put(this);
        };
        function BindSourceObj() {
            this.onPropChanged = EventTrigger.get();
            this.sourcePropDic = {};
        }
        BindSourceObj.prototype.release = function() {
            this.onPropChanged.release();
            this.source = null;
            this.sourcePropDic = null;
            this.onPropChanged = null;
        };
        function PropChangedHandler() {}
        PropChangedHandler.prototype.on = function(v) {
            if (this.trigger) {
                this.trigger.off(this.onPropChanged, this);
            }
            this.trigger = v;
            if (v) {
                v.on(this.onPropChanged, this);
            }
        };
        PropChangedHandler.prototype.onPropChanged = function(source1, prop1, oldValue, newValue) {
            if (!this.bindTargetObj) return;
            var bindTargetObj = this.bindTargetObj;
            var targetProp = this.targetProp;
            var link = bindTargetObj.getLink(targetProp, source1, prop1);
            if (!link) return;
            if (link.children != null) {
                var links = link.getLastChildren();
                var n = links.length;
                if (n > 0) {
                    var a = [];
                    var l = null;
                    for (var i = 0; i < n; i++) {
                        l = links[i];
                        if (newValue != null) {
                            for (;;) {
                                a.unshift(l.sourceProp);
                                l = l.parent;
                                if (l === link) {
                                    a.unshift(l.sourceProp);
                                    break;
                                }
                            }
                            Utils.createBindSourceObj(source1, a, 0);
                        }
                        l = a.length > 0 ? l.parent : l;
                        while (l.parent) {
                            a.unshift(l.sourceProp);
                            l = l.parent;
                        }
                        l = bindTargetObj.bindLink(targetProp, l.source, a);
                        a.length = 0;
                    }
                    l && bindTargetObj.updateBindValue(targetProp, l);
                }
            } else {
                bindTargetObj.updateBindValue(targetProp, link, oldValue, newValue);
            }
        };
        PropChangedHandler.prototype.release = function() {
            this.trigger && this.on();
            this.bindTargetObj = null;
            this.targetProp = null;
            USE_POOL && pool.put(this);
        };
        function BindTargetObj() {
            this.targetPropDic = {};
        }
        Object.defineProperty(BindTargetObj.prototype, "count", {
            get: function() {
                return Object.keys(this.targetPropDic).length;
            },
            enumerable: true,
            configurable: true
        });
        BindTargetObj.prototype.creatLink = function(targetProp, source, sourceProps) {
            var n = sourceProps.length;
            if (n < 1) return;
            var parent = this.targetPropDic[targetProp];
            if (!parent) {
                parent = this.targetPropDic[targetProp] = pool.get(BindLinkObj);
                parent.children = {};
            }
            var link = parent.children;
            for (var i = 0; i < n; i++) {
                var prop = sourceProps[i];
                if (!link[prop]) {
                    link[prop] = pool.get(BindLinkObj);
                    link[prop].parent = parent;
                    link[prop].sourceProp = prop;
                }
                parent = link[prop];
                if (i < n - 1) {
                    if (!link[prop].children) {
                        link[prop].children = {};
                    }
                    link = link[prop].children;
                }
            }
            this.bindLink(targetProp, source, sourceProps);
        };
        BindTargetObj.prototype.bindLink = function(targetProp, source, sourceProps) {
            var parent = this.targetPropDic[targetProp];
            if (!parent) return;
            parent.bind(source, this, targetProp);
            var n = sourceProps.length;
            if (n > 0) {
                var s = source;
                var o = parent.children;
                var l = null;
                for (var i = 0; i < n; i++) {
                    var p = sourceProps[i];
                    l = o[p];
                    s = s && s[p];
                    l.bind(s, this, targetProp);
                    o = l.children;
                }
                return l;
            }
        };
        BindTargetObj.prototype.unbindLink = function(targetProp) {
            var parent = this.targetPropDic[targetProp];
            if (parent) {
                parent.release();
                delete this.targetPropDic[targetProp];
            }
        };
        BindTargetObj.prototype.unbindLinks = function() {
            for (var propName in this.targetPropDic) {
                this.unbindLink(propName);
            }
        };
        BindTargetObj.prototype.getLink = function(targetProp, source, prop) {
            var parent = this.targetPropDic[targetProp];
            if (!parent) {
                return null;
            }
            return parent.findChild(source, prop);
        };
        BindTargetObj.prototype.getSourceValue = function(link) {
            var source = link && link.parent && link.parent.source;
            if (source) {
                return source[link.sourceProp];
            }
            return null;
        };
        BindTargetObj.prototype.updateBindValue = function(targetProp, link, oldValue, newValue) {
            if (!link) {
                var parent = this.targetPropDic[targetProp];
                if (!parent) return;
                link = parent.lastChild;
            }
            var value = this.getSourceValue(link);
            var fun = this.target[targetProp];
            if (fun instanceof Function) {
                fun.call(this.target, value, oldValue, newValue);
            } else {
                if (value == null && this.target instanceof cc.Label && targetProp == "string") {
                    this.target[targetProp] = "";
                } else {
                    this.target[targetProp] = value;
                }
            }
        };
        BindTargetObj.prototype.release = function() {
            this.unbindLinks();
            this.target = null;
            USE_POOL && pool.put(this);
        };
        var Utils = {
            bindCache: new window["Map"](),
            bindFun: function(target, key, args) {
                var source = target;
                var targetValue = target[key];
                var targetProp, sourceProps;
                if (args.length == 1) {
                    sourceProps = args[0];
                    targetProp = null;
                } else if (args.length == 2) {
                    if (typeof args[0] != "string") {
                        source = args[0];
                        targetProp = null;
                    }
                    sourceProps = args[1];
                } else {
                    source = args[1];
                    sourceProps = args[2];
                }
                if (targetProp == null) {
                    targetProp = Utils._getBindTargetProp(targetValue);
                    if (targetProp == null) {
                        targetProp = key;
                    } else {
                        target = targetValue;
                    }
                } else {
                    target = targetValue;
                }
                Binding.bind(target, targetProp, source, sourceProps, false);
            },
            canOverride: function(target) {
                if (target instanceof cc.Component) {
                    return true;
                }
                if (target.constructor && target.constructor.__gdk_bindable__) {
                    return true;
                }
                if (target.__gdk_bindable__) {
                    return true;
                }
                return false;
            },
            createBindSourceObj: function(source, sourceProps, propIndex) {
                var bindSourceObj = source[__bindSourceObj__];
                if (!bindSourceObj) {
                    bindSourceObj = new BindSourceObj();
                    bindSourceObj.source = source;
                    source[__bindSourceObj__] = bindSourceObj;
                }
                var sourceProp = sourceProps[propIndex];
                var propValue = source[sourceProp];
                if (!bindSourceObj.sourcePropDic[sourceProp]) {
                    let dr = Utils._getDescriptor(source, sourceProp);
                    bindSourceObj.sourcePropDic[sourceProp] = dr;
                    Object.defineProperty(source, sourceProp, {
                        get: function() {
                            let bindSourceObj = this[__bindSourceObj__];
                            if (!bindSourceObj) {
                                return;
                            }
                            let dr = bindSourceObj.sourcePropDic[sourceProp];
                            if (dr.get != null) {
                                return dr.get.call(this);
                            } else {
                                return dr.value;
                            }
                        },
                        set: function(value) {
                            let bindSourceObj = this[__bindSourceObj__];
                            if (!bindSourceObj) {
                                return;
                            }
                            let dr = bindSourceObj.sourcePropDic[sourceProp];
                            let oldValue = this[sourceProp];
                            if (dr.set != null) {
                                dr.set.call(this, value);
                            } else {
                                dr.value = value;
                            }
                            bindSourceObj.onPropChanged.emit(source, sourceProp, oldValue, value);
                        },
                        enumerable: dr.enumerable,
                        configurable: false
                    });
                    if (Utils.canOverride(source)) {
                        if (!source.__bindOnDestroy__) {
                            source.onDestroy && (source.__onDestroy__ = source.onDestroy);
                            source.__bindOnDestroy__ = true;
                            source.onDestroy = Utils.bindOnDestroy;
                        }
                    }
                }
                propIndex++;
                if (propValue != null && propIndex < sourceProps.length && typeof propValue == "object") {
                    Utils.createBindSourceObj(propValue, sourceProps, propIndex);
                }
            },
            _getBindTargetProp: function(value) {
                if (value instanceof cc.Label) return "string";
                if (value instanceof cc.Toggle) return "isChecked";
                if (value instanceof cc.Slider) return "progress";
                if (value instanceof cc.EditBox) return "string";
            },
            _getDescriptor: function(source, sourceProp) {
                var descriptor;
                while (source) {
                    descriptor = Object.getOwnPropertyDescriptor(source, sourceProp);
                    if (descriptor) {
                        break;
                    } else {
                        source = source.__proto__;
                    }
                }
                if (descriptor == null) {
                    descriptor = {
                        enumerable: true,
                        value: null,
                        configurable: true
                    };
                }
                return descriptor;
            },
            bindOnEnable: function() {
                this.__onEnable__ && this.__onEnable__.call(this);
                let ctor = this.constructor;
                let arr = [];
                for (;;) {
                    let a = Utils.bindCache.get(ctor);
                    if (a && a.length > 0) {
                        let temp = [];
                        let loop = function(i) {
                            let s = a[i];
                            let b = arr.some(function(l) {
                                return l.key == s.key;
                            });
                            !b && temp.push(s);
                        };
                        for (let i = 0; i < a.length; i++) {
                            loop(i);
                        }
                        temp.length && arr.push(...temp);
                    }
                    ctor = cc.js.getSuper(ctor);
                    if (!ctor || ctor === Object) {
                        break;
                    }
                }
                if (arr && arr.length > 0) {
                    for (let i = 0, n = arr.length; i < n; i++) {
                        Utils.bindFun(this, arr[i].key, arr[i].args);
                    }
                    let bindTargetObj = this[__bindTargetObj__];
                    for (let propName in bindTargetObj.targetPropDic) {
                        bindTargetObj.updateBindValue(propName);
                    }
                }
            },
            bindOnDisable: function() {
                Binding.unbind(this);
                this.__onDisable__ && this.__onDisable__.call(this);
            },
            bindOnDestroy: function() {
                this.__onDestroy__ && this.__onDestroy__.call(this);
                let bindSourceObj = this[__bindSourceObj__];
                if (bindSourceObj) {
                    bindSourceObj.release();
                    delete this[__bindSourceObj__];
                }
            }
        };
        var Binding = {
            bind: function(target, targetProp, source, sourceProps, update) {
                if (update === void 0) {
                    update = true;
                }
                if (target == null) {
                    console.error("Binding target can not null!!");
                    return;
                }
                if (source == null) {
                    console.error("Binding source can not null!!");
                    return;
                }
                if (typeof sourceProps === "string") {
                    sourceProps = sourceProps.split(".");
                }
                Utils.createBindSourceObj(source, sourceProps, 0);
                var bindTargetObj = target[__bindTargetObj__];
                if (!bindTargetObj) {
                    bindTargetObj = pool.get(BindTargetObj);
                    bindTargetObj.target = target;
                    target[__bindTargetObj__] = bindTargetObj;
                }
                bindTargetObj.creatLink(targetProp, source, sourceProps);
                update && bindTargetObj.updateBindValue(targetProp);
                if (Utils.canOverride(target)) {
                    if (!target.__bindOnDisable__) {
                        target.onDisable && (target.__onDisable__ = target.onDisable);
                        target.__bindOnDisable__ = true;
                        target.onDisable = Utils.bindOnDisable;
                    }
                }
            },
            unbind: function(target, targetProp) {
                var bindTarget = target[__bindTargetObj__];
                if (bindTarget) {
                    if (targetProp) {
                        bindTarget.unbindLink(targetProp);
                        if (bindTarget.count == 0) {
                            bindTarget.release();
                            delete target[__bindTargetObj__];
                        }
                    } else {
                        bindTarget.release();
                        delete target[__bindTargetObj__];
                    }
                }
            },
            bindDescriptor: function(targetProp, sourceProps) {
                var args = arguments;
                return function(target, key, descriptor) {
                    if (args.length == 0) return;
                    if (Utils.canOverride(target)) {
                        let ctor = target.constructor;
                        let targetProps = Utils.bindCache.get(ctor);
                        if (!targetProps) {
                            targetProps = [];
                            Utils.bindCache.set(ctor, targetProps);
                        }
                        targetProps.push({
                            key: key,
                            args: args
                        });
                        if (!target.__bindOnEnable__) {
                            target.onEnable && (target.__onEnable__ = target.onEnable);
                            target.__bindOnEnable__ = true;
                            target.onEnable = Utils.bindOnEnable;
                        }
                    } else {
                        Utils.bindFun(target, key, args);
                    }
                    return descriptor;
                };
            }
        };
        module.exports = Binding;
        cc._RF.pop();
    }, {
        "../core/gdk_EventTrigger": 173,
        "../managers/gdk_PoolManager": 219
    } ],
    139: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "14a90v8NjdE97FsQZMdQDgv", "gdk_Log");
        var LogLevel = require("../const/gdk_LogLevel");
        var Log = {
            isShowLog: true,
            logLevel: LogLevel.LOG | LogLevel.WARN | LogLevel.ERROR,
            get logEnable() {
                return this.isShowLog && this.logLevel & LogLevel.LOG;
            },
            get warnEnable() {
                return this.isShowLog && this.logLevel & LogLevel.WARN;
            },
            get errorEnable() {
                return this.isShowLog && this.logLevel & LogLevel.ERROR;
            },
            log() {
                if (this.logEnable) console.log.apply(console, arguments);
            },
            info() {
                if (this.logEnable) console.info.apply(console, arguments);
            },
            debug() {
                if (this.logEnable) console.debug.apply(console, arguments);
            },
            warn() {
                if (this.warnEnable) console.warn.apply(console, arguments);
            },
            error() {
                if (this.errorEnable) console.error.apply(console, arguments);
            }
        };
        module.exports = Log;
        cc._RF.pop();
    }, {
        "../const/gdk_LogLevel": 166
    } ],
    140: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "d52d6Ed32pOBbi656gIax5x", "gdk_NodeTool");
        var ShowHideComponent = require("../components/gdk_ShowHideComponent");
        var PoolManager = require("../managers/gdk_PoolManager");
        var HideMode = require("../const/gdk_HideMode");
        var NodeTool = {
            show(node, isEffect = true, callback = null, thisArg = null) {
                if (!node || !cc.isValid(node, true)) {
                    return;
                }
                var showhides = node.getComponents(ShowHideComponent);
                if (showhides && showhides.length > 0) {
                    for (var i = 0; i < showhides.length; i++) {
                        if (i == 0) {
                            showhides[i].show(isEffect, callback, thisArg);
                        } else {
                            showhides[i].show(isEffect);
                        }
                    }
                } else {
                    try {
                        node.active = true;
                    } catch (err) {
                        callback && callback.call(thisArg, "error:" + err);
                        return;
                    }
                    callback && callback.call(thisArg, node);
                }
            },
            onStartShow(node) {
                var showhide = node.getComponent(ShowHideComponent);
                if (!showhide) {
                    showhide = node.addComponent(ShowHideComponent);
                }
                return showhide.onStartShow;
            },
            onShow(node) {
                var showhide = node.getComponent(ShowHideComponent);
                if (!showhide) {
                    showhide = node.addComponent(ShowHideComponent);
                }
                return showhide.onShow;
            },
            isShow(node) {
                var showhide = node.getComponent(ShowHideComponent);
                if (showhide) {
                    return showhide.isShow;
                }
                return node.parent && node.active;
            },
            hide(node, isEffect = true, callback = null, thisArg = null) {
                if (!node || !cc.isValid(node, true)) {
                    return;
                }
                var showhides = node.getComponents(ShowHideComponent);
                if (showhides && showhides.length > 0) {
                    for (var i = 0; i < showhides.length; i++) {
                        if (i == 0) {
                            showhides[i].hide(isEffect, callback, thisArg);
                        } else {
                            showhides[i].hide(isEffect);
                        }
                    }
                } else {
                    var mode = callback;
                    if (typeof callback === "function") {
                        callback.call(thisArg);
                        mode = HideMode.REMOVE_FROM_PARENT;
                    }
                    switch (mode) {
                      case HideMode.DISABLE:
                        node.active = false;
                        return node;

                      case HideMode.POOL:
                      case HideMode.CACHE:
                        let key = node.name;
                        if (node._prefab) {
                            key += "#" + node._prefab.fileId;
                        }
                        if (mode == HideMode.POOL) PoolManager.put(key, node); else PoolManager.cache(key, node);
                        break;

                      case HideMode.REMOVE_FROM_PARENT:
                        node.removeFromParent(false);
                        break;

                      default:
                        node.destroy();
                    }
                }
                return null;
            },
            onStartHide(node) {
                var showhide = node.getComponent(ShowHideComponent);
                if (!showhide) {
                    showhide = node.addComponent(ShowHideComponent);
                }
                return showhide.onStartHide;
            },
            onHide(node) {
                var showhide = node.getComponent(ShowHideComponent);
                if (!showhide) {
                    showhide = node.addComponent(ShowHideComponent);
                }
                return showhide.onHide;
            },
            bringTop(node) {
                var n = node.parent.childrenCount;
                if (n > 1) {
                    var index = node.getSiblingIndex();
                    if (index < n - 1) node.setSiblingIndex(n - 1);
                }
            },
            bringBottom(node) {
                var n = node.parent.childrenCount;
                if (n > 1) {
                    var index = node.getSiblingIndex();
                    if (index > 0) node.setSiblingIndex(0);
                }
            },
            bringBefore(node, targetNode) {
                if (node.parent != targetNode.parent) node.parent = targetNode.parent;
                var targetNodeIndex = targetNodeIndex.getSiblingIndex();
                this.bringAt(node, targetNodeIndex);
            },
            bringAfter(node, targetNode) {
                if (node.parent != targetNode.parent) node.parent = targetNode.parent;
                var targetNodeIndex = targetNodeIndex.getSiblingIndex();
                this.bringAt(node, targetNodeIndex + 1);
            },
            bringAt(node, targetNodeIndex) {
                var nodeIndex = node.getSiblingIndex();
                if (nodeIndex != targetNodeIndex - 1) {
                    if (targetNodeIndex > nodeIndex) this._mask.node.setSiblingIndex(targetNodeIndex - 1); else this._mask.node.setSiblingIndex(targetNodeIndex);
                }
            },
            getCenter(node, target = null) {
                var parent = target || node.parent;
                var cx = parent.width * (.5 - parent.anchorX);
                var cy = parent.height * (.5 - parent.anchorY);
                var x = node.width * (.5 - node.anchorX);
                var y = node.height * (.5 - node.anchorY);
                x = cx - x;
                y = cy - y;
                return cc.v2(x, y);
            },
            getTop(node, isOut = false, target = null) {
                var parent = target || node.parent;
                var cy = parent.height * (1 - parent.anchorY);
                var y = node.height * ((isOut ? 0 : 1) - node.anchorY);
                y = cy - y;
                return cc.v2(node.x, y);
            },
            getBottom(node, isOut = false, target = null) {
                var parent = target || node.parent;
                var cy = parent.height * -parent.anchorY;
                var y = node.height * ((isOut ? 1 : 0) - node.anchorY);
                y = cy - y;
                return cc.v2(node.x, y);
            },
            getLeft(node, isOut = false, target = null) {
                var parent = target || node.parent;
                var cx = parent.width * -parent.anchorX;
                var x = node.width * ((isOut ? 1 : 0) - node.anchorX);
                x = cx - x;
                return cc.v2(x, node.y);
            },
            getRight(node, isOut = false, target = null) {
                var parent = target || node.parent;
                var cx = parent.width * (1 - parent.anchorX);
                var x = node.width * ((isOut ? 0 : 1) - node.anchorX);
                x = cx - x;
                return cc.v2(x, node.y);
            },
            center(node, target = null) {
                node.setPosition(NodeTool.getCenter(node, target));
            },
            top(node, isOut = false, target = null) {
                node.y = NodeTool.getTop(node, isOut, target).y;
            },
            bottom(node, isOut = false, target = null) {
                node.y = NodeTool.getBottom(node, isOut, target).y;
            },
            left(node, isOut = false, target = null) {
                node.x = NodeTool.getLeft(node, isOut, target).x;
            },
            right(node, isOut = false, target = null) {
                node.x = NodeTool.getRight(node, isOut, target).x;
            },
            getPosInBox(node, x, y, gap = 20, isUpFrist = true, target = null) {
                var parent = target || node.parent;
                if (isUpFrist) {
                    var cy = parent.height * (1 - parent.anchorY);
                    if (y + node.height + gap > cy) y = y - node.height * (1 - node.anchorY) - gap; else y = y - node.height * -node.anchorY + gap;
                } else {
                    var cy = parent.height * -parent.anchorY;
                    if (y - node.height - gap < cy) y = y - node.height * -node.anchorY + gap; else y = y - node.height * (1 - node.anchorY) - gap;
                }
                var cx = parent.width * -parent.anchorX;
                var nx = node.width * -node.anchorX;
                if (x + nx < cx) {
                    x = cx - nx;
                } else {
                    cx = parent.width * (1 - parent.anchorX);
                    nx = node.width * (1 - node.anchorX);
                    if (x + nx > cx) {
                        x = cx - nx;
                    }
                }
                return cc.v2(x, y);
            },
            callBeforeDraw(callback, thisArg) {
                cc.director.once(cc.Director.EVENT_BEFORE_DRAW, callback, thisArg);
            },
            cancelCallBeforeDraw(callback, thisArg) {
                cc.director.off(cc.Director.EVENT_BEFORE_DRAW, callback, thisArg);
            },
            callAfterUpdate(callback, thisArg) {
                cc.director.once(cc.Director.EVENT_AFTER_UPDATE, callback, thisArg);
            },
            cancelCallAfterUpdate(callback, thisArg) {
                cc.director.off(cc.Director.EVENT_AFTER_UPDATE, callback, thisArg);
            }
        };
        module.exports = NodeTool;
        cc._RF.pop();
    }, {
        "../components/gdk_ShowHideComponent": 155,
        "../const/gdk_HideMode": 165,
        "../managers/gdk_PoolManager": 219
    } ],
    141: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "3e6betyYoJD0rHh8rfIb4vg", "gdk_SizeTool");
        const SizeType = require("../const/gdk_SizeType");
        const SizeTool = {
            full(source, border) {
                source.width = border.width;
                source.height = border.height;
                return source;
            },
            sizeByWidth(source, border) {
                let size = source;
                let scale = source.width / source.height;
                size.width = border.width;
                size.height = size.width / scale;
                return size;
            },
            sizeByHeight(source, border) {
                let size = source;
                let scale = source.width / source.height;
                size.height = border.height;
                size.width = size.height * scale;
                return size;
            },
            showAll(source, border) {
                let scale = source.width / source.height;
                let borderScale = border.width / border.height;
                if (scale > borderScale) return this.sizeByWidth(source, border); else return this.sizeByHeight(source, border);
            },
            clip(source, border) {
                let scale = source.width / source.height;
                let borderScale = border.width / border.height;
                if (scale < borderScale) return this.sizeByWidth(source, border); else return this.sizeByHeight(source, border);
            },
            size(source, border, type) {
                if (type == SizeType.FULL) {
                    return this.full(source, border);
                } else if (type == SizeType.SHOW_ALL) {
                    this.showAll(source, border);
                } else if (type == SizeType.CLIP) {
                    this.clip(source, border);
                } else if (type == SizeType.WIDTH) {
                    return this.sizeByWidth(source, border);
                } else if (type == SizeType.HEIGHT) {
                    return this.sizeByHeight(source, border);
                }
                return source;
            }
        };
        module.exports = SizeTool;
        cc._RF.pop();
    }, {
        "../const/gdk_SizeType": 168
    } ],
    142: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "eaa96xgXnRFWYwaXMckX3WL", "gdk_i18n");
        const i18n = {
            t(str, opt) {
                if (str && typeof str === "string" && str.startsWith("i18n:")) {
                    const i = require("../i18/LanguageData");
                    str = str.substring(5);
                    return i.t(str, opt);
                }
                return str;
            },
            init(language) {
                const i = require("../i18/LanguageData");
                i.init(language);
            }
        };
        module.exports = i18n;
        cc._RF.pop();
    }, {
        "../i18/LanguageData": 208
    } ],
    143: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "3def87vqHBEHLVJm9+A6vB7", "gdk_BaseShowHideEffect");
        var HideMode = require("../../const/gdk_HideMode");
        var ShowHideComponent = require("../gdk_ShowHideComponent");
        var EaseType = require("../../const/gdk_EaseType");
        var BaseShowHideEffect = cc.Class({
            extends: ShowHideComponent,
            editor: {
                disallowMultiple: false
            },
            properties: {
                startValue: 0,
                normalValue: 1,
                endValue: 0,
                showTime: .5,
                hideTime: .5,
                showDelay: 0,
                hideDelay: 0,
                ease: {
                    default: EaseType.easeQuarticActionOut,
                    type: EaseType
                },
                hideEase: {
                    default: EaseType.easeQuarticActionIn,
                    type: EaseType
                }
            },
            doShow() {
                this.node.active = true;
                this.showComplete();
            },
            doHide() {
                this.hideComplete();
            },
            isShowEffect() {
                return this.showTime > 0 || this.showDelay;
            },
            isHideEffect() {
                return this.hideTime > 0 || this.hideDelay > 0;
            },
            easeShowFun(p = 3) {
                let ease = EaseType[this.ease];
                let fun = cc[ease];
                if (fun == null) {
                    fun = cc[EaseType[EaseType.easeLinear]];
                }
                return fun.call(this, p);
            },
            easeHideFun(p = 3) {
                let ease = EaseType[this.hideEase];
                let fun = cc[ease];
                if (fun == null) {
                    fun = cc[EaseType[EaseType.easeLinear]];
                }
                return fun.call(this, p);
            }
        });
        module.exports = BaseShowHideEffect;
        cc._RF.pop();
    }, {
        "../../const/gdk_EaseType": 164,
        "../../const/gdk_HideMode": 165,
        "../gdk_ShowHideComponent": 155
    } ],
    144: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "c4e0cDDk7xGtLewEhO0zk+G", "gdk_DelayShowHideEffect");
        var HideMode = require("../../const/gdk_HideMode");
        var ShowHideComponent = require("../gdk_ShowHideComponent");
        var EaseType = require("../../const/gdk_EaseType");
        var DelayCall = require("../../core/gdk_DelayCall");
        var DelayShowHideEffect = cc.Class({
            extends: ShowHideComponent,
            editor: {
                menu: "gdk(Effect)/DelayShowHideEffect",
                disallowMultiple: false
            },
            properties: {
                showDelay: 1,
                hideDelay: 1
            },
            onDisable() {
                let _super = cc.js.getSuper(this.__proto__.constructor);
                if (_super && _super.prototype && _super.prototype.onDisable) {
                    _super.prototype.onDisable.call(this);
                }
                DelayCall.cancel(this._hideComplete, this);
                DelayCall.cancel(this._showComplete, this);
            },
            doShow() {
                DelayCall.cancel(this._hideComplete, this);
                DelayCall.addCall(this._showComplete, this, this.showDelay);
            },
            doHide() {
                DelayCall.cancel(this._showComplete, this);
                DelayCall.addCall(this._hideComplete, this, this.hideDelay);
            },
            _showComplete() {
                if (cc.isValid(this.node, true)) this.showComplete();
            },
            _hideComplete() {
                if (cc.isValid(this.node, true)) this.hideComplete();
            },
            isShowEffect() {
                return this.showDelay;
            },
            isHideEffect() {
                return this.hideDelay > 0;
            }
        });
        module.exports = DelayShowHideEffect;
        cc._RF.pop();
    }, {
        "../../const/gdk_EaseType": 164,
        "../../const/gdk_HideMode": 165,
        "../../core/gdk_DelayCall": 171,
        "../gdk_ShowHideComponent": 155
    } ],
    145: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "6b7e889/kBHj7Qn9zfEGs93", "gdk_FadeShowHideEffect");
        var FadeShowHideEffect = cc.Class({
            extends: require("./gdk_BaseShowHideEffect"),
            editor: {
                menu: "gdk(Effect)/FadeShowHideEffect",
                disallowMultiple: false
            },
            properties: {
                normalValue: {
                    default: 255,
                    override: true
                }
            },
            doShow(isActioning) {
                if (isActioning == false) {
                    this.node.opacity = this.startValue;
                }
                var actionn = cc.sequence(cc.delayTime(this.showDelay), cc.fadeTo(this.showTime, this.normalValue).easing(this.easeShowFun()), cc.callFunc(() => {
                    this.showComplete();
                }));
                return actionn;
            },
            doHide(isActioning) {
                var actionn = cc.sequence(cc.delayTime(this.hideDelay), cc.fadeTo(this.hideTime, this.endValue).easing(this.easeHideFun()), cc.callFunc(() => {
                    this.hideComplete();
                }));
                return actionn;
            }
        });
        module.exports = FadeShowHideEffect;
        cc._RF.pop();
    }, {
        "./gdk_BaseShowHideEffect": 143
    } ],
    146: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "c4fca93xZ1P2YfqyN0ASHRu", "gdk_ScaleShowHideEffect");
        var ScaleShowHideEffect = cc.Class({
            extends: require("./gdk_BaseShowHideEffect"),
            editor: {
                menu: "gdk(Effect)/ScaleShowHideEffect",
                disallowMultiple: false
            },
            properties: {},
            ctor() {
                this.showAction = null;
                this.hideAction = null;
            },
            doShow(isActioning) {
                if (isActioning == false) {
                    this.node.scaleX = this.node.scaleY = this.startValue;
                }
                var action = cc.sequence(cc.delayTime(this.showDelay), cc.scaleTo(this.showTime, this.normalValue, this.normalValue).easing(this.easeShowFun()), cc.callFunc(() => {
                    this.showComplete();
                }));
                return action;
            },
            doHide(isActioning) {
                var action = cc.sequence(cc.delayTime(this.hideDelay), cc.scaleTo(this.hideTime, this.endValue, this.endValue).easing(this.easeHideFun()), cc.callFunc(() => {
                    this.hideComplete();
                }));
                return action;
            }
        });
        module.exports = ScaleShowHideEffect;
        cc._RF.pop();
    }, {
        "./gdk_BaseShowHideEffect": 143
    } ],
    147: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "78a76x3NllNoJwQRJNthFHr", "gdk_SlideShowHideEffect");
        var BaseShowHideEffect = require("./gdk_BaseShowHideEffect");
        var SlideEffectMode = require("../../const/gdk_SlideEffectMode");
        var DelayCall = require("../../core/gdk_DelayCall");
        var SlideShowHideEffect = cc.Class({
            extends: BaseShowHideEffect,
            editor: {
                menu: "gdk(Effect)/SlideShowHideEffect",
                disallowMultiple: false
            },
            properties: {
                normalValue: {
                    default: 1,
                    visible: false,
                    override: true
                },
                slideMode: {
                    default: SlideEffectMode.CENTER,
                    type: SlideEffectMode
                },
                target: {
                    default: null,
                    type: cc.Node,
                    tooltip: CC_DEV && "指定对齐节点，默认为空，为空时表时当前父节点"
                }
            },
            onLoad() {
                this._x = this.node.x;
                this._y = this.node.y;
            },
            onEnable() {
                switch (this.slideMode) {
                  case SlideEffectMode.CENTER:
                  case SlideEffectMode.LEFT:
                  case SlideEffectMode.RIGHT:
                  case SlideEffectMode.TOP:
                  case SlideEffectMode.BOTTOM:
                    let parent = this.target || this.node.parent;
                    if (cc.isValid(parent) && parent.getComponent(cc.Widget)) {
                        parent.on(cc.Node.EventType.POSITION_CHANGED, this._resize, this);
                        parent.on(cc.Node.EventType.SIZE_CHANGED, this._resize, this);
                        this._$NhasWidget = true;
                    }
                    break;

                  default:
                    break;
                }
            },
            onDisable() {
                if (this._$NhasWidget) {
                    let parent = this.target || this.node.parent;
                    if (cc.isValid(parent)) {
                        parent.off(cc.Node.EventType.POSITION_CHANGED, this._resize, this);
                        parent.off(cc.Node.EventType.SIZE_CHANGED, this._resize, this);
                    }
                    delete this._$NhasWidget;
                }
            },
            _resize() {
                if (this._isShow === true) {
                    let isActioning = this._stopAction();
                    this._action = this.doShow(isActioning);
                    if (this._action) {
                        DelayCall.addCall(this._runAction, this, .15);
                    }
                } else if (this._isShow === false) {
                    let isActioning = this._stopAction();
                    this._action = this.doHide(isActioning);
                    if (this._action) {
                        this.node.runAction(this._action);
                    }
                } else if (this._action == null) {
                    this._x = this.node.x;
                    this._y = this.node.y;
                }
            },
            doShow(isActioning) {
                var NodeTool = require("../../Tools/gdk_NodeTool");
                var node = this.node;
                var parent = this.target || node.parent;
                var x;
                var y;
                if (this.slideMode == SlideEffectMode.CENTER) {
                    var pos = NodeTool.getCenter(node, parent);
                    x = pos.x;
                    y = pos.y;
                    if (isActioning == false) {
                        node.y = y + this.startValue;
                        node.x = x;
                    }
                } else if (this.slideMode == SlideEffectMode.LEFT) {
                    var pos = NodeTool.getLeft(node, true, parent);
                    x = pos.x + node.width;
                    y = node.y;
                    if (isActioning == false) {
                        node.x = pos.x;
                    }
                } else if (this.slideMode == SlideEffectMode.RIGHT) {
                    var pos = NodeTool.getRight(node, true, parent);
                    x = pos.x - node.width;
                    y = node.y;
                    if (isActioning == false) {
                        node.x = pos.x;
                    }
                } else if (this.slideMode == SlideEffectMode.TOP) {
                    NodeTool.top(node, true);
                    var pos = NodeTool.getTop(node, true, parent);
                    x = node.x;
                    y = pos.y - node.height;
                    if (isActioning == false) {
                        node.y = pos.y;
                    }
                } else if (this.slideMode == SlideEffectMode.BOTTOM) {
                    var pos = NodeTool.getBottom(node, true, parent);
                    x = node.x;
                    y = pos.y + node.height;
                    if (isActioning == false) {
                        node.y = pos.y;
                    }
                } else if (this.slideMode == SlideEffectMode.HORIZONTAL) {
                    x = this._x;
                    y = this._y;
                    if (isActioning == false) {
                        node.y = y;
                        node.x = x + this.startValue;
                    }
                } else if (this.slideMode == SlideEffectMode.VERTICAL) {
                    x = this._x;
                    y = this._y;
                    if (isActioning == false) {
                        node.y = y + this.startValue;
                        node.x = x;
                    }
                }
                var action = cc.sequence(cc.delayTime(this.showDelay), cc.moveTo(this.showTime, x, y).easing(this.easeShowFun()), cc.callFunc(() => {
                    this.showComplete();
                }));
                return action;
            },
            doHide(isActioning) {
                var NodeTool = require("../../Tools/gdk_NodeTool");
                var node = this.node;
                var x;
                var y;
                var parent = this.node.parent;
                if (this.slideMode == SlideEffectMode.CENTER) {
                    var pos = NodeTool.getCenter(node, parent);
                    x = pos.x;
                    y = pos.y + this.endValue;
                } else if (this.slideMode == SlideEffectMode.LEFT) {
                    var pos = NodeTool.getLeft(node, true, parent);
                    x = pos.x;
                    y = pos.y;
                } else if (this.slideMode == SlideEffectMode.RIGHT) {
                    var pos = NodeTool.getRight(node, true, parent);
                    x = pos.x;
                    y = pos.y;
                } else if (this.slideMode == SlideEffectMode.TOP) {
                    var pos = NodeTool.getTop(node, true, parent);
                    x = pos.x;
                    y = pos.y;
                } else if (this.slideMode == SlideEffectMode.BOTTOM) {
                    var pos = NodeTool.getBottom(node, true, parent);
                    x = pos.x;
                    y = pos.y;
                } else if (this.slideMode == SlideEffectMode.HORIZONTAL) {
                    x = this._x + this.endValue;
                    y = this._y;
                } else if (this.slideMode == SlideEffectMode.VERTICAL) {
                    x = this._x;
                    y = this._y + this.endValue;
                }
                var action = cc.sequence(cc.delayTime(this.hideDelay), cc.moveTo(this.hideTime, x, y).easing(this.easeHideFun()), cc.callFunc(() => {
                    this.hideComplete();
                }));
                return action;
            }
        });
        module.exports = SlideShowHideEffect;
        cc._RF.pop();
    }, {
        "../../Tools/gdk_NodeTool": 140,
        "../../const/gdk_SlideEffectMode": 169,
        "../../core/gdk_DelayCall": 171,
        "./gdk_BaseShowHideEffect": 143
    } ],
    148: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ea844zRrmtOlbYtIicg7iqy", "gdk_BatchChildrenRender");
        var Timer = require("../core/gdk_Timer");
        var BatchChildrenRender = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Component)/BatchChildrenRender",
                disallowMultiple: true,
                executeInEditMode: false
            },
            properties: {},
            onEnable() {
                this.node.___batch_children_render___ = true;
                this.node.on("child-added", this._updateRenderFlag, this);
                this.node.on("child-removed", this._updateRenderFlag, this);
            },
            onDisable() {
                delete this.node.___batch_children_render___;
                this.node.targetOff(this);
                Timer.clearAll(this);
            },
            _updateRenderFlag() {
                Timer.once(100, this, this._updateRenderFlagLater);
            },
            _updateRenderFlagLater() {
                if (!cc.isValid(this.node)) return;
                if (!this.node.activeInHierarchy) return;
                this.node["setLocalDirty"](cc.Node._LocalDirtyFlag.ALL_POSITION);
            }
        });
        module.exports = BatchChildrenRender;
        cc._RF.pop();
    }, {
        "../core/gdk_Timer": 177
    } ],
    149: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "aa980nC961O5azk8mqQpGHc", "gdk_CameraChildrenRender");
        let CameraChildrenRender = null;
        if (CC_JSB) {
            CameraChildrenRender = cc.Class({
                extends: cc.Component,
                editor: {
                    menu: "gdk(Component)/CameraChildrenRender",
                    disallowMultiple: true,
                    executeInEditMode: false
                },
                properties: {
                    _target: {
                        default: null,
                        type: cc.Node
                    },
                    target: {
                        get() {
                            return this._target;
                        },
                        set(value) {
                            this._target = value;
                        },
                        animatable: false,
                        type: cc.Node,
                        tooltip: CC_DEV && "优化目标节点"
                    },
                    content: cc.Node,
                    sprite: cc.Sprite,
                    camera: cc.Camera
                }
            });
        } else {
            function isDirty(node) {
                let comp = node.getComponent(cc.RenderComponent);
                if (comp && comp.isValid && comp.enabledInHierarchy && comp._inValidateList) {
                    return true;
                }
                let a = node._children;
                let n = a.length;
                for (let i = 0; i < n; i++) {
                    let c = a[i];
                    if (!c._activeInHierarchy || c._opacity === 0 || c._$N_visible === false) continue;
                    if (!isDirty(c)) continue;
                    return true;
                }
                return false;
            }
            CameraChildrenRender = cc.Class({
                extends: cc.Component,
                editor: {
                    menu: "gdk(Component)/CameraChildrenRender",
                    disallowMultiple: true,
                    executeInEditMode: false
                },
                properties: {
                    _target: {
                        default: null,
                        type: cc.Node
                    },
                    target: {
                        get() {
                            return this._target;
                        },
                        set(value) {
                            if (value === this._target) return;
                            if (this.enabledInHierarchy) {
                                this._updateTarget(value);
                                this._target = value;
                            } else {
                                this._target = value;
                            }
                        },
                        animatable: false,
                        type: cc.Node,
                        tooltip: CC_DEV && "优化目标节点"
                    },
                    content: cc.Node,
                    sprite: cc.Sprite,
                    camera: cc.Camera
                },
                onEnable() {
                    this.renderTexture = new cc.RenderTexture();
                    this.renderTexture.initWithSize(cc.visibleRect.width, cc.visibleRect.height, cc.game._renderContext.STENCIL_INDEX8);
                    if (!this.content) {
                        this.content = new cc.Node("___CameraChildrenRender___");
                        this.content.scaleY = -1;
                        this.content.parent = this.node;
                    }
                    this.content.active = false;
                    if (!this.sprite) {
                        this.sprite = this.content.getComponent(cc.Sprite);
                        if (!this.sprite) {
                            this.sprite = this.content.addComponent(cc.Sprite);
                        }
                    }
                    this.sprite.spriteFrame = new cc.SpriteFrame(this.renderTexture);
                    if (!this.camera) {
                        let camera = this.node.addComponent(cc.Camera);
                        camera.backgroundColor = cc.color(0, 0, 0, 0);
                        camera.clearFlags = 7;
                        camera.depth = -1;
                        this.camera = camera;
                    }
                    this.camera.enabled = false;
                    this._updateTarget(this._target);
                },
                onDisable() {
                    if (this.sprite) {
                        this.sprite.spriteFrame && this.sprite.spriteFrame.destroy();
                        this.sprite.destroy();
                    }
                    this.renderTexture && this.renderTexture.destroy();
                    this.content && this.content.destroy();
                    this.camera && this.camera.destroy();
                    this.sprite = null;
                    this.renderTexture = null;
                    this.content = null;
                    this.camera = null;
                    this._isNodeDirty = false;
                    this._updateTarget(null);
                },
                _updateTarget(node) {
                    let lastNode = this._target;
                    if (lastNode && lastNode !== node) {
                        delete lastNode._$N_visible;
                        lastNode.targetOff(this);
                        cc.director.off(cc.Director.EVENT_BEFORE_DRAW, this._beforeDraw, this);
                    }
                    if (node) {
                        [ cc.Node.EventType.CHILD_ADDED, cc.Node.EventType.CHILD_REMOVED, cc.Node.EventType.POSITION_CHANGED, cc.Node.EventType.SIZE_CHANGED, cc.Node.EventType.SCALE_CHANGED ].forEach(type => {
                            node.on(type, () => this._isNodeDirty = true, this, true);
                        });
                        node._$N_visible = false;
                        cc.director.on(cc.Director.EVENT_BEFORE_DRAW, this._beforeDraw, this);
                    }
                },
                _beforeDraw() {
                    if (!cc.isValid(this.node)) return;
                    if (!this.enabledInHierarchy) return;
                    if (this._isNodeDirty || isDirty(this._target)) {
                        this._isNodeDirty = false;
                        this.content.active = false;
                        this._target._$N_visible = true;
                        this.renderTexture.updateSize(cc.visibleRect.width, cc.visibleRect.height);
                        this.camera.targetTexture = this.renderTexture;
                        this.camera.enabled = true;
                        this.camera.render(this._target);
                        this.camera.renderTexture = null;
                        this.camera.enabled = false;
                        this._target._$N_visible = false;
                        this.content.active = true;
                    }
                }
            });
        }
        module.exports = CameraChildrenRender;
        cc._RF.pop();
    }, {} ],
    150: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ec2c2X45wtFnp0h7U5N00sr", "gdk_ChangeSceneUnDestroyComponent");
        var ChangeSceneUnDestroyComponent = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Component)/ChangeSceneUnDestroyComponent",
                disallowMultiple: false
            },
            properties: {
                _isDestroy: {
                    default: false,
                    visible: true
                },
                isDestroy: {
                    get() {
                        return this._isDestroy;
                    },
                    set(value) {
                        if (value == this._isDestroy) {
                            return;
                        }
                        this._isDestroy = value;
                        this.uddateView();
                    },
                    visible: false
                }
            },
            onLoad() {
                this.uddateView();
            },
            onDestroy() {
                this._isDestroy = false;
                this.uddateView();
            },
            uddateView() {
                this.node.__gdk__persistNode__ = !this.isDestroy;
                if (this.isDestroy) {
                    if (this.node._persistNode) {
                        cc.game.removePersistRootNode(this.node);
                    }
                } else {
                    if (!this.node._persistNode) {
                        var scene = cc.director._scene;
                        if (this.node.parent == scene) {
                            cc.game.addPersistRootNode(this.node);
                            if (this.node.__gdk___onHierarchyChanged == null) {
                                this.node.__gdk___onHierarchyChanged = this.node._onHierarchyChanged;
                            }
                            this.node._onHierarchyChanged = this._onHierarchyChanged;
                        }
                    }
                }
            },
            _onHierarchyChanged(oldParent) {
                if (!this._persistNode) {
                    this.__gdk___onHierarchyChanged(oldParent);
                }
            }
        });
        module.exports = ChangeSceneUnDestroyComponent;
        cc._RF.pop();
    }, {} ],
    151: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "588d2R84eZP46kbqn3xxHYQ", "gdk_Music");
        var MusicManager = require("../managers/gdk_MusicManager");
        var MusicId = require("../enums/gdk_MusicId");
        var Music = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Component)/Music",
                disallowMultiple: false
            },
            properties: {
                _musicName: "",
                _music: {
                    get() {
                        return MusicId[this._musicName] || 0;
                    },
                    set(value) {
                        this._musicName = MusicId[value];
                    },
                    type: MusicId,
                    visible: true,
                    serializable: true,
                    tooltip: CC_DEV && "如果没可选值，请先配置MusicId"
                },
                _audioClip: {
                    default: null,
                    type: cc.AudioClip,
                    visible: true,
                    serializable: true,
                    tooltip: CC_DEV && "设置此值会覆盖musics的值,推荐使用musics设置，因为设置这里会影响场景加载速度，场景会把cc.AudioClip预加载进来"
                },
                _volume: {
                    default: 1,
                    visible: true,
                    serializable: true
                }
            },
            setMusic(v) {
                this._musicName = v;
                this.enabled && MusicManager._addMusic(this);
            },
            onEnable() {
                MusicManager._addMusic(this);
            },
            onDisable() {
                MusicManager._removeMusic(this);
            },
            onDestroy: function() {
                MusicManager._removeMusic(this);
            }
        });
        module.exports = Music;
        cc._RF.pop();
    }, {
        "../enums/gdk_MusicId": 200,
        "../managers/gdk_MusicManager": 217
    } ],
    152: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "3c642VuWJFIEpwhQzM3gbRr", "gdk_PopupComponent");
        const EventTrigger = require("../core/gdk_EventTrigger");
        const PoolManager = require("../managers/gdk_PoolManager");
        const NodeTool = require("../Tools/gdk_NodeTool");
        const _defaultMaskColor = cc.color(0, 0, 0, 255 * .5);
        const _popupDic = cc.js.createMap(true);
        const POOL_NAME = "__gdk_popup__Mask";
        var PopupComponent = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Component)/PopupComponent",
                disallowMultiple: false
            },
            properties: {
                _isMask: {
                    default: false,
                    visible: true,
                    serializable: true
                },
                isMask: {
                    visible: false,
                    get() {
                        return this._isMask;
                    },
                    set(value) {
                        if (this._isMask == value) {
                            return;
                        }
                        this._isMask = value;
                        this._updateMask();
                    }
                },
                _maskColor: {
                    default: _defaultMaskColor,
                    visible: true,
                    serializable: true
                },
                maskColor: {
                    visible: false,
                    get() {
                        return this._maskColor;
                    },
                    set(value) {
                        if (this._maskColor == value) {
                            return;
                        }
                        this._maskColor = value;
                        this._setMaskColor(this._maskColor);
                    }
                },
                maskAlpha: {
                    get() {
                        return this._maskColor.a;
                    },
                    set(value) {
                        if (this._maskColor.a == value) return;
                        this._maskColor.a = value;
                        this._setMaskColor(this._maskColor);
                    }
                },
                isTouchMaskClose: {
                    visible: true,
                    default: false
                },
                _isTouchBringTop: {
                    default: false,
                    visible: true,
                    serializable: true
                },
                isTouchBringTop: {
                    visible: false,
                    get() {
                        return this._isTouchBringTop;
                    },
                    set(value) {
                        if (this._isTouchBringTop == value) {
                            return;
                        }
                        this._isTouchBringTop = value;
                        this._updateTouchBringTop();
                    }
                },
                onMaskClick: {
                    default: null,
                    serializable: false,
                    visible: false
                },
                _mask: null,
                _isOrderMasking: false,
                _parent: null
            },
            statics: {
                _popupDic: _popupDic
            },
            ctor() {
                this.onMaskClick = EventTrigger.get();
                this._isEnable = true;
            },
            onLoad() {
                this._nodeName = this.node.name;
                _popupDic[this._nodeName] = this;
            },
            onEnable() {
                this._isEnable = true;
                if (this._isMask) {
                    this._updateMask();
                }
            },
            onDisable() {
                this._isEnable = false;
                if (this._isMask) {
                    this._updateMask();
                }
            },
            onDestroy() {
                delete _popupDic[this._nodeName];
                this.onMaskClick.release();
                this.onMaskClick = null;
            },
            reuse() {
                _popupDic[this._nodeName] = this;
            },
            unuse() {
                delete _popupDic[this._nodeName];
                this.isTouchMaskClose = false;
                this._maskColor = _defaultMaskColor;
                this._isTouchBringTop = false;
                this.onMaskClick.offAll();
            },
            _setMaskColor(color) {
                if (this._mask) {
                    if (this.fillColor == null || this._mask.fillColor.a != color.a || this._mask.fillColor.b != color.b || this._mask.fillColor.g != color.g || this._mask.fillColor.r != color.r) {
                        this._mask.clear();
                        if (color.a != 0) {
                            var size = cc.winSize;
                            this._mask.rect(-size.width, -size.height, 2 * size.width, 2 * size.height);
                            this._mask.fillColor = color.clone();
                            this._mask.fill();
                        }
                    }
                }
            },
            _updateMask() {
                NodeTool.callAfterUpdate(this._updateMaskLate, this);
            },
            _updateMaskLate() {
                if (this._isEnable && this._isMask && this.enabled && cc.isValid(this.node)) {
                    if (this._mask == null) {
                        var node = PoolManager.get(POOL_NAME);
                        if (!node) {
                            var size = cc.winSize;
                            node = cc.instantiate(require("../gdk").engine.maskPrefab);
                            node.width = size.width;
                            node.height = size.height;
                            node.setScale(5);
                            node.zIndex = cc.macro.MIN_ZINDEX;
                        }
                        node.parent = this.node;
                        this._mask = node.getComponent(cc.Graphics);
                        if (this.maskColor != this._mask.fillColor) {
                            this._setMaskColor(this.maskColor);
                        }
                        this._mask.node.on("touchend", this._maskOnClick, this);
                    }
                } else {
                    let mask = this._mask;
                    if (mask && cc.isValid(mask.node)) {
                        mask.node.off("touchend", this._maskOnClick, this);
                        mask.node.parent = null;
                        PoolManager.put(POOL_NAME, mask.node);
                    }
                    this._mask = null;
                }
            },
            _updateTouchBringTop() {
                if (this.isTouchBringTop) {
                    this.node.on("touchstart", this._bringTop, this);
                } else {
                    this.node.off("touchstart", this._bringTop, this);
                }
            },
            _bringTop() {
                NodeTool.bringTop(this.node);
            },
            _maskOnClick() {
                this.onMaskClick.emit();
                if (this.isTouchMaskClose) {
                    var panel = this.node.getComponent(require("../ui/gdk_BasePanel"));
                    if (panel) {
                        panel.close(-1);
                    } else {
                        NodeTool.hide(this.node);
                    }
                }
            }
        });
        module.exports = PopupComponent;
        cc._RF.pop();
    }, {
        "../Tools/gdk_NodeTool": 140,
        "../core/gdk_EventTrigger": 173,
        "../gdk": 205,
        "../managers/gdk_PoolManager": 219,
        "../ui/gdk_BasePanel": 233
    } ],
    153: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "f85a7fmJ8dOyKwcnfpjlqmb", "gdk_ScaleSizeComponent");
        const SizeType = require("../const/gdk_SizeType");
        const SizeTool = require("../Tools/gdk_SizeTool");
        const NodeTool = require("../Tools/gdk_NodeTool");
        var ScaleSizeComponent = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Component)/ScaleSizeComponent",
                disallowMultiple: false
            },
            properties: {
                _sizeOnce: {
                    default: true,
                    tootTip: CC_EDITOR && "只在onEnable时触发一次，后面父级大小改变时不再响应",
                    visible: true
                },
                sizeOnce: {
                    get() {
                        return this._sizeOnce;
                    },
                    set(value) {
                        if (value == this._sizeOnce) return;
                        this._sizeOnce = value;
                        this._updateListener();
                    },
                    visible: false
                },
                isScale: {
                    default: false,
                    tootTip: CC_EDITOR && "通过scaleX，scaleY来缩放，还是width,height来缩放",
                    visible: true
                },
                type: {
                    default: SizeType.NONE,
                    type: SizeType
                }
            },
            ctor() {
                this._once = false;
                this._enable = false;
            },
            onEnable() {
                this._enable = true;
                this._updateListener();
                if (!this._once) {
                    NodeTool.callBeforeDraw(this.updateSize, this);
                }
            },
            onDisable() {
                this._listenerOff();
            },
            updateSize() {
                if (!this._enable) return;
                this._once = true;
                let parent = this.node.parent;
                let node = this.node;
                if (parent) {
                    var parentSize = parent.getContentSize();
                    var mySize = node.getContentSize();
                    var newSzie = cc.size(mySize.width, mySize.height);
                    mySize.width = node.scaleX * mySize.width;
                    mySize.height = node.scaleY * mySize.height;
                    SizeTool.size(newSzie, parentSize, this.type);
                    if (this.isScale) {
                        node.scaleX = newSzie.width / mySize.width;
                        node.scaleY = newSzie.height / mySize.height;
                    } else {
                        newSzie.width = newSzie.width / node.scaleX;
                        newSzie.height = newSzie.height / node.scaleY;
                        node.setContentSize(newSzie);
                    }
                }
            },
            _updateListener() {
                if (this._sizeOnce || this._enable == false) this._listenerOff(); else this._listenerOn();
            },
            _listenerOn() {
                if (this._parent != this.node.parent) {
                    if (this._parent) {
                        this._listenerOff();
                    }
                    if (this.node.parent) {
                        this._parent = this.node.parent;
                        this._parent.on("size-changed", this._updateSize, this);
                        this._parent.on("child-removed", this._onParentChildRemoved, this);
                    }
                }
            },
            _listenerOff() {
                if (this._parent) {
                    this._parent.off("size-changed", this._updateSize, this);
                    this._parent.off("child-removed", this._onParentChildRemoved, this);
                }
                this._parent = null;
            },
            _onParentChildRemoved() {
                if (this._parent != this.node.parent) {
                    this._listenerOff();
                    this._updateMask();
                    this._listenerOn();
                }
            },
            _updateSize() {
                NodeTool.callAfterUpdate(this.updateSize, this);
            }
        });
        module.exports = ScaleSizeComponent;
        cc._RF.pop();
    }, {
        "../Tools/gdk_NodeTool": 140,
        "../Tools/gdk_SizeTool": 141,
        "../const/gdk_SizeType": 168
    } ],
    154: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "b6972v/qt5PEocBjOx7vjbo", "gdk_SceneAdapaterComponent");
        var SceneAdapaterComponent = cc.Class({
            extends: cc.Component,
            editor: {
                inspector: "packages://gdk/scripts/SceneAdapaterComponentInspector.js",
                menu: "gdk(Component)/SceneAdapaterComponent",
                disallowMultiple: false,
                requireComponent: cc.Canvas
            },
            __preload() {
                let canvas = this.getComponent(cc.Canvas);
                let ds = canvas.designResolution;
                let dr = ds.height / ds.width;
                let fs = cc.view.getFrameSize();
                let fr = fs.height / fs.width;
                if (cc.sys.isBrowser && cc.sys.isMobile && fr > 1.3) {
                    if (dr > 1) {
                        canvas.fitHeight = false;
                        canvas.fitWidth = true;
                    } else {
                        canvas.fitHeight = true;
                        canvas.fitWidth = false;
                    }
                } else {
                    if (fr >= dr) {
                        canvas.fitHeight = false;
                        canvas.fitWidth = true;
                    } else if (fr < dr) {
                        canvas.fitHeight = true;
                        canvas.fitWidth = false;
                    }
                }
                this.canvas = canvas;
            }
        });
        module.exports = SceneAdapaterComponent;
        cc._RF.pop();
    }, {} ],
    155: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "b4e8e85iwBJubw85f+Ks3VA", "gdk_ShowHideComponent");
        var HideMode = require("../const/gdk_HideMode");
        var EventTrigger = require("../core/gdk_EventTrigger");
        var PoolManager = require("../managers/gdk_PoolManager");
        var DelayCall = require("../core/gdk_DelayCall");
        var ShowHideComponent = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Component)/ShowHideComponent"
            },
            properties: {
                hideMode: {
                    default: HideMode.DESTROY,
                    type: HideMode,
                    visible: true,
                    serializable: true,
                    tooltip: CC_DEV && `NONE:什么也不做\nDISABLE:取消激活\nPOOL:回收进对象池\nDESTROY:销毁\nCACHE:缓存起来，但这里是单一对象的缓存,没有池子对面板等单一对象尤其适用.`
                },
                onStartShow: {
                    default: null,
                    type: EventTrigger,
                    visible: false,
                    serializable: false
                },
                onShow: {
                    default: null,
                    type: EventTrigger,
                    visible: false,
                    serializable: false
                },
                onStartHide: {
                    default: null,
                    type: EventTrigger,
                    visible: false,
                    serializable: false
                },
                onHide: {
                    default: null,
                    type: EventTrigger,
                    visible: false,
                    serializable: false
                },
                _isShow: null,
                isShow: {
                    visible: false,
                    get() {
                        if (this._isShow == null) {
                            return this.node.active;
                        }
                        return this._isShow;
                    }
                },
                isShowWheEnable: false,
                _hideMode: null,
                _action: null
            },
            ctor() {
                this.onStartShow = EventTrigger.get();
                this.onShow = EventTrigger.get();
                this.onStartHide = EventTrigger.get();
                this.onHide = EventTrigger.get();
            },
            onEnable() {
                if (this.isShowWheEnable) {
                    this.show();
                }
            },
            onDisable() {
                var isActioning = this._stopAction();
                if (isActioning && cc.isValid(this.node, true)) {
                    this.hideComplete();
                }
                DelayCall.cancel(this._runAction, this);
                this._isShow = null;
                this._action = null;
            },
            onDestroy() {
                this.onShow.release();
                this.onHide.release();
                this.onShow = null;
                this.onHide = null;
                this.onStartShow.release();
                this.onStartHide.release();
                this.onStartShow = null;
                this.onStartHide = null;
                this._isShow = null;
            },
            unuse() {
                this._isShow = null;
                this._action = null;
                this.onShow.offAll();
                this.onHide.offAll();
                this.onStartShow.offAll();
                this.onStartHide.offAll();
            },
            _stopAction() {
                var isActioning = this._action != null && this._action.isDone() == false;
                if (isActioning) {
                    if (!!this._action.getOriginalTarget() && !!cc.director.getActionManager()._hashTargets[this.node._id]) {
                        this.node.stopAction(this._action);
                    }
                }
                this._action = null;
                return isActioning;
            },
            show(isEffect = true, callback = null, thisArg = null) {
                if (this.isShow && this._isShow != null) {
                    return;
                }
                var isActioning = this._stopAction();
                this._isShow = true;
                this._hideMode = null;
                this.onHide.offOnce();
                this.onStartHide.offOnce();
                try {
                    this.node.active = true;
                } catch (err) {
                    callback && callback(thisArg, "error:" + err);
                    return;
                }
                if (callback) {
                    this.onShow.once(callback, thisArg);
                }
                this.onStartShow.emit(this);
                if (isEffect && this.isShowEffect()) {
                    this._action = this.doShow(isActioning);
                    if (this._action) {
                        DelayCall.addCall(this._runAction, this, .15);
                    }
                } else {
                    this.showComplete();
                }
            },
            _runAction() {
                if (this._action && this._isShow && this.node.active) {
                    this.node.runAction(this._action);
                } else {
                    this._action = null;
                }
            },
            hide(isEffect = true, callback = null, thisArg = null) {
                if (this.isShow == false) {
                    return;
                }
                var isActioning = this._stopAction();
                this._isShow = false;
                this.onShow.offOnce();
                this.onStartShow.offOnce();
                this._hideMode = null;
                if (typeof callback == "function") {
                    this.onHide.once(callback, thisArg);
                } else if (callback != null) {
                    this._hideMode = callback;
                }
                this.node.active = true;
                this.onStartHide.emit(this);
                if (isEffect && this.isHideEffect()) {
                    this._action = this.doHide(isActioning);
                    if (this._action) {
                        this.node.runAction(this._action);
                    }
                } else {
                    this.hideComplete();
                }
            },
            isShowEffect() {
                return true;
            },
            isHideEffect() {
                return true;
            },
            doShow(isActioning) {
                this.showComplete();
            },
            doHide(isActioning) {
                this.hideComplete();
            },
            showComplete() {
                if (this.isShow == false) {
                    return;
                }
                this._action = null;
                this.onShow.emit(this);
            },
            hideComplete() {
                if (this.isShow) {
                    return;
                }
                this._action = null;
                this.onHide.emit(this);
                let hideMode = this._hideMode != null ? this._hideMode : this.hideMode;
                this._hideMode = null;
                switch (hideMode) {
                  case HideMode.DISABLE:
                    this.node.active = false;
                    break;

                  case HideMode.POOL:
                  case HideMode.CACHE:
                    let node = this.node;
                    let key = node.name;
                    if (node._prefab) {
                        key += "#" + node._prefab.fileId;
                    }
                    if (hideMode == HideMode.POOL) PoolManager.put(key, node); else PoolManager.cache(key, node);
                    break;

                  case HideMode.DESTROY:
                    this.node.destroy();
                    break;

                  case HideMode.REMOVE_FROM_PARENT:
                    this.node.removeFromParent(false);
                    break;

                  default:
                }
            }
        });
        module.exports = ShowHideComponent;
        cc._RF.pop();
    }, {
        "../const/gdk_HideMode": 165,
        "../core/gdk_DelayCall": 171,
        "../core/gdk_EventTrigger": 173,
        "../managers/gdk_PoolManager": 219
    } ],
    156: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "dfa86VLW1RObqcfSleXGgL4", "gdk_Sound");
        var SoundManager = require("../managers/gdk_SoundManager");
        var SoundId = require("../enums/gdk_SoundId");
        var Tools = require("../core/gdk_Tool");
        var TriggerType = cc.Enum({
            NONE: -1,
            ENABLE: -1,
            DISABLE: -1,
            DESTROY: -1,
            TOUCH_START: -1,
            TOUCH_MOVE: -1,
            TOUCH_END: -1,
            MOUSE_ENTER: -1
        });
        var Sound = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Component)/Sound",
                disallowMultiple: true
            },
            properties: {
                _soundName: "",
                _sound: {
                    get() {
                        return SoundId[this._soundName] || 0;
                    },
                    set(value) {
                        this._soundName = SoundId[value];
                    },
                    type: SoundId,
                    visible: true,
                    serializable: true,
                    tooltip: CC_DEV && "如果没可选值，请先配置SoundId"
                },
                _audioClip: {
                    default: null,
                    type: cc.AudioClip,
                    visible: true,
                    serializable: true,
                    tooltip: CC_DEV && "设置此值会覆盖sound的值,推荐使用sound设置，因为设置这里会影响场景加载速度，场景会把cc.AudioClip预加载进来"
                },
                _trigger: {
                    default: TriggerType.NONE,
                    type: TriggerType,
                    visible: true,
                    serializable: true
                }
            },
            onLoad() {
                switch (this._trigger) {
                  case TriggerType.TOUCH_START:
                    this.node.on("touchstart", this.play, this);
                    break;

                  case TriggerType.TOUCH_MOVE:
                    this.node.on("touchmove", this.play, this);
                    break;

                  case TriggerType.TOUCH_END:
                    this.node.on("touchend", this.play, this);
                    break;

                  case TriggerType.MOUSE_ENTER:
                    this.node.on("mouseenter", this.play, this);
                    break;
                }
            },
            play() {
                if (this._audioClipm) {
                    SoundManager.playAudio(this._audioClip);
                } else {
                    let resId = Tools.getResIdByNode(this.node);
                    SoundManager.play(resId, SoundId.getValue(this._soundName));
                }
            },
            onEnable() {
                if (this._trigger == TriggerType.ENABLE) {
                    this.play();
                }
            },
            onDisable() {
                if (this._trigger == TriggerType.DISABLE) {
                    this.play();
                }
            },
            onDestroy: function() {
                if (this._trigger == TriggerType.DESTROY) {
                    this.play();
                }
            }
        });
        module.exports = Sound;
        cc._RF.pop();
    }, {
        "../core/gdk_Tool": 178,
        "../enums/gdk_SoundId": 204,
        "../managers/gdk_SoundManager": 223
    } ],
    157: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "f33b1gDn3pKlJQ49ElrlhF+", "gdk_ToolTipComponent");
        var GUIManager = require("../managers/gdk_GUIManager");
        var ShowMode = cc.Enum({
            Holp: 0,
            Click: 1
        });
        var ToolTipComponent = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Component)/ToolTipComponent",
                disallowMultiple: false
            },
            properties: {
                isUpFrist: {
                    default: true,
                    tootTip: "优先向上"
                },
                gapIsSelfBox: {
                    default: true,
                    tootTip: ""
                },
                gap: {
                    default: 0,
                    tootTip: "间隔"
                },
                showMode: {
                    default: ShowMode.Holp,
                    type: ShowMode,
                    tootTip: "手指离开消失"
                },
                isTouchEndHide: {
                    default: true,
                    tootTip: "手指离开消失"
                },
                text: {
                    default: "",
                    multiline: true,
                    tootTip: "提示内容"
                },
                _pressed: false,
                _isShow: false
            },
            statics: {
                longPressTime: .5,
                ShowMode: ShowMode
            },
            onEnable() {
                if (this.showMode == ShowMode.Holp) {
                    this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
                    this.node.on(cc.Node.EventType.MOUSE_ENTER, this._onTouchBegan, this);
                    this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
                    this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchEnded, this);
                    this.node.on(cc.Node.EventType.MOUSE_LEAVE, this._onTouchEnded, this);
                } else {
                    this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchClick, this);
                }
            },
            onDisable() {
                this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(cc.Node.EventType.MOUSE_ENTER, this._onTouchBegan, this);
                this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
                this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchEnded, this);
                this.node.off(cc.Node.EventType.MOUSE_LEAVE, this._onTouchEnded, this);
                this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchClick, this);
            },
            _onTouchClick(event) {
                var gap = this.gap;
                if (this.gapIsSelfBox) gap = this.node.height / 2;
                GUIManager.showNodeToolTip(this.text, this.node, gap, this.isUpFrist);
            },
            _onTouchBegan(event) {
                this._pressed = true;
                if (this._isShow == false) this.scheduleOnce(this._showTip, ToolTipComponent.longPressTime);
            },
            _onTouchEnded(event) {
                if (this._pressed) {
                    if (this._isShow) {
                        if (this.isTouchEndHide) GUIManager.hideToolTip();
                    } else this.unschedule(this._showTip);
                }
                this._isShow = false;
                this._pressed = false;
            },
            _showTip() {
                if (this._pressed) {
                    this._isShow = true;
                    var gap = this.gap;
                    if (this.gapIsSelfBox) {
                        gap = this.node.height / 2;
                    }
                    GUIManager.showNodeToolTip(this.text, this.node, gap, this.isUpFrist);
                }
            }
        });
        module.exports = ToolTipComponent;
        cc._RF.pop();
    }, {
        "../managers/gdk_GUIManager": 215
    } ],
    158: [ function(require, module, exports) {
        require("./gdk_ChangeSceneUnDestroyComponent");
        require("./gdk_Music");
        require("./gdk_PopupComponent");
        require("./gdk_ScaleSizeComponent");
        require("./gdk_SceneAdapaterComponent");
        require("./gdk_ShowHideComponent");
        require("./gdk_Sound");
        require("./gdk_ToolTipComponent");
        require("./gdk_BatchChildrenRender");
        require("./gdk_CameraChildrenRender");
        require("./effects/gdk_BaseShowHideEffect");
        require("./effects/gdk_DelayShowHideEffect");
        require("./effects/gdk_FadeShowHideEffect");
        require("./effects/gdk_ScaleShowHideEffect");
        require("./effects/gdk_SlideShowHideEffect");
        require("./layout/gdk_AlertLayout");
        require("./layout/gdk_TextSizeLayout");
        require("./tweens/gdk_BaseTween");
        require("./tweens/gdk_RotateTween");
        require("./tweens/gdk_ScaleTween");
    }, {
        "./effects/gdk_BaseShowHideEffect": 143,
        "./effects/gdk_DelayShowHideEffect": 144,
        "./effects/gdk_FadeShowHideEffect": 145,
        "./effects/gdk_ScaleShowHideEffect": 146,
        "./effects/gdk_SlideShowHideEffect": 147,
        "./gdk_BatchChildrenRender": 148,
        "./gdk_CameraChildrenRender": 149,
        "./gdk_ChangeSceneUnDestroyComponent": 150,
        "./gdk_Music": 151,
        "./gdk_PopupComponent": 152,
        "./gdk_ScaleSizeComponent": 153,
        "./gdk_SceneAdapaterComponent": 154,
        "./gdk_ShowHideComponent": 155,
        "./gdk_Sound": 156,
        "./gdk_ToolTipComponent": 157,
        "./layout/gdk_AlertLayout": 159,
        "./layout/gdk_TextSizeLayout": 160,
        "./tweens/gdk_BaseTween": 161,
        "./tweens/gdk_RotateTween": 162,
        "./tweens/gdk_ScaleTween": 163
    } ],
    159: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "d5375opRkVIzJ8ehhYm1ji7", "gdk_AlertLayout");
        var NodeTool = require("../../Tools/gdk_NodeTool");
        var AlertLayout = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Component)/AlertLayout",
                disallowMultiple: false
            },
            properties: {
                _textField: {
                    default: null,
                    type: cc.Label,
                    serializable: true,
                    visible: true
                },
                _buttonParent: {
                    default: null,
                    type: cc.Node,
                    serializable: true,
                    visible: true
                },
                _maxWidth: {
                    default: 0,
                    serializable: true,
                    visible: true
                },
                maxWidth: {
                    visible: false,
                    get: function() {
                        return this._maxWidth;
                    },
                    set: function(value) {
                        if (this._maxWidth == value) return;
                        this._maxWidth = value;
                        this.updateSize();
                    }
                },
                _minWidth: {
                    default: 0,
                    serializable: true,
                    visible: true
                },
                minWidth: {
                    visible: false,
                    get: function() {
                        return this._minWidth;
                    },
                    set: function(value) {
                        if (this._minWidth == value) return;
                        this._minWidth = value;
                        this.updateSize();
                    }
                },
                _maxHeight: {
                    default: 0,
                    serializable: true,
                    visible: true
                },
                maxHeight: {
                    visible: false,
                    get: function() {
                        return this._maxHeight;
                    },
                    set: function(value) {
                        if (this._maxHeight == value) return;
                        this._maxHeight = value;
                        this.updateSize();
                    }
                },
                _minHeight: {
                    default: 0,
                    serializable: true,
                    visible: true
                },
                minHeight: {
                    visible: false,
                    get: function() {
                        return this._minHeight;
                    },
                    set: function(value) {
                        if (this._minHeight == value) return;
                        this._minHeight = value;
                        this.updateSize();
                    }
                },
                _offsetW: 0,
                _offsetH: 0,
                _isChanging: false,
                _isLoaded: false
            },
            onLoad() {
                this._offsetW = this.node.width - this._textField.node.width;
                this._offsetH = this.node.height - this._textField.node.height;
                this._isLoaded = true;
            },
            onEnable() {
                this._textField.node.on("size-changed", this.updateSize, this);
                this._buttonParent.on("size-changed", this.updateSize, this);
            },
            unuse() {
                this._textField.overflow = cc.Label.Overflow.NONE;
            },
            onDisable() {
                this._textField.node.off("size-changed", this.updateSize, this);
                this._buttonParent.off("size-changed", this.updateSize, this);
            },
            updateSize() {
                if (this._isChanging || this._isLoaded == false) return;
                NodeTool.callBeforeDraw(this.updateSizeLate, this, 0);
            },
            updateSizeLate() {
                if (this._isChanging || this._isLoaded == false) return;
                this._isChanging = true;
                this._textField.overflow = cc.Label.Overflow.NONE;
                var h;
                var maxWidth = this._maxWidth - this._offsetW;
                var minWidth = this._minWidth - this._offsetW;
                if (this._textField.node.width > maxWidth && maxWidth > 0) {
                    this._textField.overflow = cc.Label.Overflow.RESIZE_HEIGHT;
                    this._textField.node.width = maxWidth;
                } else if (this._textField.node.width < minWidth) {
                    this._textField.overflow = cc.Label.Overflow.RESIZE_HEIGHT;
                    this._textField.node.width = minWidth;
                }
                if (this._textField.node.width < this._buttonParent.width) this._textField.node.width = this._buttonParent.width;
                var maxHeight = this._maxHeight - this._offsetH;
                var minHeight = this._minHeight - this._offsetH;
                h = this._textField.node.height;
                if (this._textField.node.height > maxHeight && maxHeight > 0) {
                    this._textField.overflow = cc.Label.Overflow.SHRINK;
                    this._textField.node.height = maxHeight;
                    h = maxHeight;
                } else if (this._textField.node.height < minHeight) {
                    this._textField.overflow = cc.Label.Overflow.RESIZE_HEIGHT;
                    this._textField.node.height = minHeight;
                    h = minHeight;
                }
                this.node.width = this._textField.node.width + this._offsetW;
                this.node.height = h + this._offsetH;
                this._isChanging = false;
            }
        });
        module.exports = AlertLayout;
        cc._RF.pop();
    }, {
        "../../Tools/gdk_NodeTool": 140
    } ],
    160: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "3cffe2jM8ZAbLZ1CSaBOeuY", "gdk_TextSizeLayout");
        var TextSizeLayout = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Component)/TextSizeLayout",
                disallowMultiple: false,
                requireComponent: cc.Label
            },
            properties: {
                _sizeParent: {
                    default: null,
                    type: cc.Node,
                    serializable: true,
                    visible: true
                },
                _maxWidth: {
                    default: 0,
                    serializable: true,
                    visible: true
                },
                maxWidth: {
                    visible: false,
                    get: function() {
                        return this._maxWidth;
                    },
                    set: function(value) {
                        if (this._maxWidth == value) return;
                        this._maxWidth = value;
                        this.updateSize();
                    }
                },
                _minWidth: {
                    default: 0,
                    serializable: true,
                    visible: true
                },
                minWidth: {
                    visible: false,
                    get: function() {
                        return this._minWidth;
                    },
                    set: function(value) {
                        if (this._minWidth == value) return;
                        this._minWidth = value;
                        this.updateSize();
                    }
                },
                _offsetW: 0,
                _offsetH: 0,
                _isChanging: false,
                _isLoaded: false
            },
            onLoad() {
                if (this._sizeParent == null) this._sizeParent = this.node.parent;
                this._offsetW = this._sizeParent.width - this.node.width;
                this._offsetH = this._sizeParent.height - this.node.height;
                this._label = this.node.getComponent(cc.Label);
                this._isLoaded = true;
                this.updateSize();
                this.node.on("size-changed", this.updateSize, this);
            },
            updateSize() {
                if (this._isChanging || this._isLoaded == false) return;
                this._isChanging = true;
                this._label.overflow = cc.Label.Overflow.NONE;
                if (this.node.width > this._maxWidth) {
                    this._label.overflow = cc.Label.Overflow.RESIZE_HEIGHT;
                    this.node.width = this._maxWidth;
                } else if (this.node.width < this._minWidth) {
                    this._label.overflow = cc.Label.Overflow.RESIZE_HEIGHT;
                    this.node.width = this._minWidth;
                }
                this._sizeParent.width = this.node.width + this._offsetW;
                this._sizeParent.height = this.node.height + this._offsetH;
                this._isChanging = false;
            }
        });
        module.exports = TextSizeLayout;
        cc._RF.pop();
    }, {} ],
    161: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "2db54+IJHtLmbJPJ7tj/QBZ", "gdk_BaseTween");
        var EventTrigger = require("../../core/gdk_EventTrigger");
        var EaseType = require("../../const/gdk_EaseType");
        var BaseTween = cc.Class({
            extends: cc.Component,
            editor: {
                disallowMultiple: false
            },
            properties: {
                _fromIsCurrent: {
                    default: true,
                    visible: true,
                    serializable: true
                },
                fromIsCurrent: {
                    visible: false,
                    get() {
                        return this._fromIsCurrent;
                    },
                    set(value) {
                        if (this._fromIsCurrent == value) {
                            return;
                        }
                        this._fromIsCurrent = value;
                        this.updateTween();
                    }
                },
                _isBy: {
                    default: true,
                    visible: true,
                    serializable: true
                },
                isBy: {
                    visible: false,
                    get() {
                        return this._isBy;
                    },
                    set(value) {
                        if (this._isBy == value) {
                            return;
                        }
                        this._isBy = value;
                        this.updateTween();
                    }
                },
                _from: {
                    default: 0,
                    visible: true,
                    serializable: true
                },
                from: {
                    visible: false,
                    get() {
                        return this._from;
                    },
                    set(value) {
                        if (this._from == value) {
                            return;
                        }
                        this._from = value;
                        this.updateTween();
                    }
                },
                _to: {
                    default: 0,
                    visible: true,
                    serializable: true
                },
                to: {
                    visible: false,
                    get() {
                        return this._to;
                    },
                    set(value) {
                        if (this._to == value) {
                            return;
                        }
                        this._to = value;
                        this.updateTween();
                    }
                },
                _time: {
                    default: 1,
                    visible: true,
                    serializable: true
                },
                time: {
                    visible: false,
                    get() {
                        return this._time;
                    },
                    set(value) {
                        if (this._time == value) {
                            return;
                        }
                        this._time = value;
                        this.updateTween();
                    }
                },
                _loop: {
                    default: 0,
                    visible: true,
                    serializable: true
                },
                loop: {
                    visible: false,
                    get() {
                        return this._loop;
                    },
                    set(value) {
                        if (this._loop == value) {
                            return;
                        }
                        this._loop = value;
                        this.updateTween();
                    }
                },
                _ease: {
                    default: EaseType.easeLinear,
                    type: EaseType,
                    visible: true,
                    serializable: true
                },
                ease: {
                    visible: false,
                    get() {
                        return this._ease;
                    },
                    set(value) {
                        if (this._ease == value) {
                            return;
                        }
                        this._ease = value;
                        this.updateTween();
                    }
                },
                onComplete: {
                    default: null,
                    serializable: false,
                    visible: false
                }
            },
            ctor() {
                this.onComplete = EventTrigger.get();
            },
            onDestroy() {
                this.onComplete.release();
                this.onComplete = null;
            },
            unuse() {
                this.onComplete.offAll();
            },
            onEnable() {
                this.updateTween();
            },
            updateTween() {}
        });
        module.exports = BaseTween;
        cc._RF.pop();
    }, {
        "../../const/gdk_EaseType": 164,
        "../../core/gdk_EventTrigger": 173
    } ],
    162: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "f402c+ubJxAuaPVqcxISLcg", "gdk_RotateTween");
        var BaseTween = require("./gdk_BaseTween");
        var EaseType = require("../../const/gdk_EaseType");
        var RotateTween = cc.Class({
            extends: BaseTween,
            editor: {
                menu: "gdk(Component)/RotateTween",
                disallowMultiple: false
            },
            properties: {
                _to: {
                    default: 360,
                    visible: true,
                    serializable: true,
                    override: true
                },
                _loop: {
                    default: -1,
                    visible: true,
                    serializable: true,
                    override: true
                },
                _action: null
            },
            updateTween() {
                if (this._action) {
                    this.node.stopAction(this._action);
                }
                let _super = cc.js.getSuper(this.__proto__.constructor);
                if (_super && _super.prototype && _super.prototype.updateTween) {
                    _super.prototype.updateTween.call(this);
                }
                if (this._fromIsCurrent == false) {
                    this.node.angle = -this._from;
                }
                var a1;
                if (this._isBy) {
                    a1 = cc.rotateBy(this._time, this._to);
                } else {
                    a1 = cc.rotateTo(this._time, this._to);
                }
                var ease = EaseType[this._ease];
                var fun = cc[ease];
                if (fun) {
                    a1.easing(fun(3));
                }
                var action = cc.sequence(a1, cc.callFunc(function() {
                    this.onComplete.emit();
                }, this));
                if (this._loop == -1) {
                    action = cc.repeatForever(action);
                } else if (this._loop > 0) {
                    action = cc.repeat(action);
                }
                this._action = action;
                this.node.runAction(action);
            }
        });
        module.exports = RotateTween;
        cc._RF.pop();
    }, {
        "../../const/gdk_EaseType": 164,
        "./gdk_BaseTween": 161
    } ],
    163: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "13d1f02cCtPlb1n/oFBQzqO", "gdk_ScaleTween");
        var BaseTween = require("./gdk_BaseTween");
        var EaseType = require("../../const/gdk_EaseType");
        var ScaleTween = cc.Class({
            extends: BaseTween,
            editor: {
                menu: "gdk(Component)/ScaleTween",
                disallowMultiple: false
            },
            properties: {
                _to: {
                    default: 2,
                    visible: true,
                    serializable: true,
                    override: true
                },
                _loop: {
                    default: -1,
                    visible: true,
                    serializable: true,
                    override: true
                },
                _action: null
            },
            updateTween() {
                if (this._action) {
                    this.node.stopAction(this._action);
                }
                let _super = cc.js.getSuper(this.__proto__.constructor);
                if (_super && _super.prototype && _super.prototype.updateTween) {
                    _super.prototype.updateTween.call(this);
                }
                if (this._fromIsCurrent == false) {
                    this.node.scale = this._from;
                }
                var a1 = cc.scaleTo(this._time, this._to);
                var a2 = cc.scaleTo(this._time, this._from);
                var ease = EaseType[this._ease];
                var fun = cc[ease];
                if (fun) {
                    a1.easing(fun(3));
                    a2.easing(fun(3));
                }
                var action = cc.sequence(a1, a2);
                if (this._loop == -1) {
                    action = cc.repeatForever(action);
                } else if (this._loop > 0) {
                    action = cc.repeat(action);
                }
                this._action = action;
                this.node.runAction(action);
            }
        });
        module.exports = ScaleTween;
        cc._RF.pop();
    }, {
        "../../const/gdk_EaseType": 164,
        "./gdk_BaseTween": 161
    } ],
    164: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "b64f8sdu3FIJIHi1vdy9Gg/", "gdk_EaseType");
        var EaseType = cc.Enum({
            easeLinear: -1,
            easeIn: -1,
            easeOut: -1,
            easeInOut: -1,
            easeExponentialIn: -1,
            easeExponentialOut: -1,
            easeExponentialInOut: -1,
            easeSineIn: -1,
            easeSineOut: -1,
            easeSineInOut: -1,
            easeElasticIn: -1,
            easeElasticOut: -1,
            easeElasticInOut: -1,
            easeBounceIn: -1,
            easeBounceOut: -1,
            easeBounceInOut: -1,
            easeBackIn: -1,
            easeBackOut: -1,
            easeBackInOut: -1,
            easeBezierAction: -1,
            easeQuadraticActionIn: -1,
            easeQuadraticActionOut: -1,
            easeQuadraticActionInOut: -1,
            easeQuarticActionIn: -1,
            easeQuarticActionOut: -1,
            easeQuarticActionInOut: -1,
            easeQuinticActionIn: -1,
            easeQuinticActionOut: -1,
            easeQuinticActionInOut: -1,
            easeCircleActionIn: -1,
            easeCircleActionOut: -1,
            easeCircleActionInOut: -1,
            easeCubicActionIn: -1,
            easeCubicActionOut: -1,
            easeCubicActionInOut: -1
        });
        cc.easeLinear = function() {
            return {
                easing: function(dt) {
                    return dt;
                },
                reverse: function() {
                    return cc.easeLinear();
                }
            };
        };
        module.exports = EaseType;
        cc._RF.pop();
    }, {} ],
    165: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "75a514jiKZGjZrlgyYn77t4", "gdk_HideMode");
        var HideMode = cc.Enum({
            NONE: -1,
            DISABLE: -1,
            POOL: -1,
            DESTROY: -1,
            CACHE: -1,
            REMOVE_FROM_PARENT: -1
        });
        module.exports = HideMode;
        cc._RF.pop();
    }, {} ],
    166: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "f2145H+FT5MWqPAupSZXocz", "gdk_LogLevel");
        var LogLevel = {
            LOG: 1,
            WARN: 2,
            ERROR: 4
        };
        module.exports = LogLevel;
        cc._RF.pop();
    }, {} ],
    167: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "50a820uQ5RD7YaO89ELaJVR", "gdk_MessageMode");
        var MessageMode = cc.Enum({
            FLOAT: -1,
            REPLACE: -1
        });
        module.exports = MessageMode;
        cc._RF.pop();
    }, {} ],
    168: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "fd2f9f9bOdL0bNVZuCxwezt", "gdk_SizeType");
        const SizeType = cc.Enum({
            NONE: -1,
            FULL: -1,
            WIDTH: -1,
            HEIGHT: -1,
            SHOW_ALL: -1,
            CLIP: -1
        });
        module.exports = SizeType;
        cc._RF.pop();
    }, {} ],
    169: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "3faf2xPVU9GDLQnF48dH9dM", "gdk_SlideEffectMode");
        var SlideEffectMode = cc.Enum({
            CENTER: -1,
            TOP: -1,
            BOTTOM: -1,
            LEFT: -1,
            RIGHT: -1,
            VERTICAL: -1,
            HORIZONTAL: -1
        });
        module.exports = SlideEffectMode;
        cc._RF.pop();
    }, {} ],
    170: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "138e0jfFdJBZY59PC5GhdGO", "gdk_Cache");
        var DelayCall = require("./gdk_DelayCall");
        var Pool = require("./gdk_Pool");
        var _cache = {};
        var _cacheClearFun = {};
        var _count = 0;
        var Cache = {
            get(key) {
                if (key == null || key == "") return null;
                var obj = _cache[key];
                if (obj) {
                    DelayCall.cancel(_cacheClearFun[key], this);
                    delete _cache[key];
                    delete _cacheClearFun[key];
                    _count--;
                    if (obj.reuse) obj.reuse.call(obj);
                    if (obj && obj.__gdk_inPool__) {
                        obj.__gdk_inPool__ = false;
                    }
                }
                return obj;
            },
            has(key) {
                if (key == null || key == "") return false;
                return _cache[key] != null;
            },
            put(key, obj, clearTime = null, clearFun = null, thisArg = null) {
                if (key == null || key == "" || obj == null) return;
                if (clearTime instanceof Function) {
                    clearTime = Pool.clearTime;
                    clearFun = arguments[2];
                    thisArg = arguments[3];
                }
                if (_cache[key] == null) {
                    _cache[key] = obj;
                    obj.__gdk_inPool__ = true;
                    if (obj.unuse) obj.unuse.call(obj);
                    _count++;
                    if (isNaN(clearTime)) return;
                    var clearCallBack = _cacheClearFun[key] = function() {
                        _count--;
                        delete _cache[key];
                        delete _cacheClearFun[key];
                        if (obj.destroy) obj.destroy.call(obj);
                        if (clearFun) clearFun.call(thisArg, obj);
                    };
                    DelayCall.addCall(clearCallBack, this, clearTime);
                }
            },
            clear(key) {
                if (key == null || key == "") return null;
                var obj = _cache[key];
                if (obj) {
                    var clearCallBack = _cacheClearFun[key];
                    DelayCall.cancel(clearCallBack, this);
                    clearCallBack();
                }
            },
            clearAll() {
                var tempCache = _cache;
                var tempCacheClearFun = _cacheClearFun;
                _cache = {};
                _cacheClearFun = {};
                for (var key in tempCache) {
                    var obj = tempCache[key];
                    var clearCallBack = tempCacheClearFun[key];
                    if (clearCallBack) {
                        DelayCall.cancel(clearCallBack, this);
                        clearCallBack();
                    }
                }
            },
            get count() {
                return _count;
            }
        };
        module.exports = Cache;
        cc._RF.pop();
    }, {
        "./gdk_DelayCall": 171,
        "./gdk_Pool": 176
    } ],
    171: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "4d74eed4YdH/J9Cpqob6lfx", "gdk_DelayCall");
        var _callbacks = [];
        var _isOrderChanged = false;
        var _time = 0;
        function _getCallBack(callback, thisArg) {
            for (var i = 0, n = _callbacks.length; i < n; i++) {
                var obj = _callbacks[i];
                if (obj.callback == callback && obj.thisArg == thisArg) {
                    return obj;
                }
            }
            return null;
        }
        function _sortCallBack(o1, o2) {
            if (o1.time < o2.time) return -1;
            return 1;
        }
        var _callbackCaches = [];
        function CallbackObj() {
            this.callback;
            this.time;
            this.thisArg;
            this.args;
        }
        function _getCallbackCache(callback, thisArg, time, args) {
            var obj;
            var n = _callbackCaches.length;
            if (n == 0) {
                obj = new CallbackObj();
            } else {
                obj = _callbackCaches[n - 1];
                --_callbackCaches.length;
            }
            obj.callback = callback;
            obj.time = time;
            obj.thisArg = thisArg;
            obj.args = args;
            return obj;
        }
        function _putCallbackCache(obj) {
            obj.callback = null;
            obj.time = null;
            obj.thisArg = null;
            obj.args = null;
            _callbackCaches.push(obj);
        }
        var DelayCall = {
            addCall(callback, thisArg = null, delay = 0, args = null) {
                if (callback == null) return;
                var obj = _getCallBack(callback, thisArg);
                if (delay < 0) delay = 0;
                var t = _time + delay;
                if (obj == null) {
                    obj = _getCallbackCache(callback, thisArg, t, args);
                    if (_callbacks.length > 0) {
                        var lastObj = _callbacks[_callbacks.length - 1];
                        if (t < lastObj.time) {
                            _isOrderChanged = true;
                        }
                    }
                    _callbacks.push(obj);
                } else {
                    obj.thisArg = thisArg;
                    obj.time = t;
                    obj.args = args;
                    _isOrderChanged = true;
                }
            },
            cancel(callback, thisArg) {
                if (callback == null) return;
                for (var i = 0, n = _callbacks.length; i < n; i++) {
                    var obj = _callbacks[i];
                    if (obj.callback == callback && obj.thisArg == thisArg) {
                        _putCallbackCache(obj);
                        _callbacks.splice(i, 1);
                        break;
                    }
                }
            },
            has(callback, thisArg) {
                if (callback == null) return false;
                return _getCallBack(callback, thisArg) != null;
            },
            getDelayTime(callback, thisArg) {
                if (callback == null) return 0;
                var obj = _getCallBack(callback, thisArg);
                if (obj != null) {
                    return (new Date().getTime() - obj.time) / 1e3;
                }
                return 0;
            },
            update(dt) {
                _time = _time + dt;
                var n = _callbacks.length;
                if (n == 0) return;
                if (_isOrderChanged && n > 1) {
                    _callbacks.sort(_sortCallBack);
                }
                let currentTime = 0;
                while (true) {
                    var obj = _callbacks[0];
                    if (obj && obj.time <= _time && (currentTime == 0 || obj.time <= currentTime)) {
                        currentTime = obj.time;
                        _callbacks.shift();
                        var callback = obj.callback;
                        var thisArg = obj.thisArg;
                        var args = obj.args;
                        _putCallbackCache(obj);
                        callback.apply(thisArg, args);
                    } else {
                        break;
                    }
                }
            }
        };
        if (!CC_EDITOR) {
            cc.game.once(cc.game.EVENT_ENGINE_INITED, () => {
                cc.director.getScheduler().enableForTarget(DelayCall);
                cc.director.getScheduler().scheduleUpdate(DelayCall, cc.Scheduler.PRIORITY_SYSTEM, false);
            });
        }
        module.exports = DelayCall;
        cc._RF.pop();
    }, {} ],
    172: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "55095SLKdtE4JXnh1jBG+YB", "gdk_Event");
        const PoolManager = require("../managers/gdk_PoolManager");
        const POOL_MAX = 999;
        const POOL_CLEAR_TIME = 30;
        const POOL_NAME = "__gdk_event__Event";
        var pool = {
            initlized: false,
            get(c) {
                let v = PoolManager.get(POOL_NAME);
                if (!v) {
                    v = new c();
                }
                return v;
            },
            put(v) {
                let k = POOL_NAME;
                if (!this.initlized) {
                    PoolManager.setSize(k, POOL_MAX);
                    PoolManager.setClearTime(k, POOL_CLEAR_TIME);
                }
                PoolManager.put(k, v);
            }
        };
        function Event() {
            this.unuse();
        }
        var proto = Event.prototype;
        proto.unuse = function() {
            this.type = null;
            this.data = null;
            this.code = 0;
            this._canRelease = true;
        };
        proto.release = function(alwayRelease = true) {
            if (alwayRelease || this._canRelease) {
                pool.put(this);
            }
        };
        proto.canRelease = function(value) {
            this._canRelease = value;
        };
        Event.get = function(type, data) {
            var event = pool.get(Event);
            event.type = type;
            event.data = data;
            return event;
        };
        module.exports = Event;
        cc._RF.pop();
    }, {
        "../managers/gdk_PoolManager": 219
    } ],
    173: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "721e2HdM5hDya/eUut9KhRn", "gdk_EventTrigger");
        const POOL_MAX = 999;
        const POOL_CLEAR_TIME = 30;
        var pool = {
            index: Object.create(null),
            get(c) {
                const PoolManager = require("../managers/gdk_PoolManager");
                let k = "__gdk_event_trigger_" + c.name;
                let v = PoolManager.get(k);
                if (!v) {
                    v = new c();
                }
                return v;
            },
            put(v) {
                const PoolManager = require("../managers/gdk_PoolManager");
                let k = "__gdk_event_trigger_" + v.constructor.name;
                if (!this.index[k]) {
                    this.index[k] = true;
                    PoolManager.setSize(k, POOL_MAX);
                    PoolManager.setClearTime(k, POOL_CLEAR_TIME);
                }
                PoolManager.put(k, v);
            }
        };
        function EventTrigger() {
            this._callbacks = null;
            this._isSortCallback = false;
        }
        var proto = EventTrigger.prototype;
        Object.defineProperty(proto, "count", {
            get: function() {
                return this._callbacks.length;
            },
            enumerable: true,
            configurable: true
        });
        proto.on = function(callback, thisArg = null, priority = 0, hasEventArg = true) {
            this._on(callback, false, thisArg, priority, hasEventArg);
        };
        proto.once = function(callback, thisArg = null, priority = 0, hasEventArg = true) {
            this._on(callback, true, thisArg, priority, hasEventArg);
        };
        proto.off = function(callback, thisArg) {
            var arr = this._callbacks;
            if (arr && arr.length > 0) {
                for (var i = 0, n = arr.length; i < n; i++) {
                    if (arr[i].callback == callback && arr[i].thisArg == thisArg) {
                        _remove(arr, i);
                        break;
                    }
                }
                if (arr.length == 0) {
                    this._isSortCallback = false;
                }
            }
        };
        proto.offAll = function() {
            this._isSortCallback = false;
            if (this._callbacks) {
                this._callbacks.length = 0;
            }
        };
        proto.offOnce = function() {
            var arr = this._callbacks;
            if (arr && arr.length > 0) {
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i].isOnce) {
                        _remove(arr, i);
                        --i;
                    }
                }
                if (arr.length == 0) {
                    this._isSortCallback = false;
                }
            }
        };
        proto.targetOff = function(thisArg) {
            var arr = this._callbacks;
            if (arr && arr.length > 0) {
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i].thisArg == thisArg) {
                        _remove(arr, i);
                        --i;
                    }
                }
                if (arr.length == 0) {
                    this._isSortCallback = false;
                }
            }
        };
        proto.emit = function(p1 = null, p2 = null, p3 = null, p4 = null, p5 = null) {
            if (this.__gdk_inPool__) return;
            var result = null;
            if (this._callbacks && this._callbacks.length > 0) {
                if (this._callbacks.length == 1) {
                    var listener = this._callbacks[0];
                    var arg0 = listener.hasEventArg ? p1 : p1.data;
                    if (listener.isOnce) this._callbacks.length = 0;
                    if (listener.thisArg) {
                        result = listener.callback.call(listener.thisArg, arg0, p2, p3, p4, p5);
                    } else {
                        result = listener.callback(arg0, p2, p3, p4, p5);
                    }
                } else {
                    var doCallbacks = this._callbacks.concat();
                    if (this._isSortCallback) {
                        this._callbacks.sort(_sortCallBack);
                    }
                    for (var i = 0; i < this._callbacks.length; i++) {
                        var listener = this._callbacks[i];
                        if (listener.isOnce) {
                            _remove(this._callbacks, i);
                            --i;
                        }
                    }
                    if (this._callbacks.length == 0) {
                        this._isSortCallback = false;
                    }
                    for (var i = 0, n = doCallbacks.length; i < n; i++) {
                        var listener = doCallbacks[i];
                        if (result && result.isStopped) break;
                        var arg0 = listener.hasEventArg ? p1 : p1.data;
                        var resultTemp = null;
                        if (listener.thisArg) {
                            resultTemp = listener.callback.call(listener.thisArg, arg0, p2, p3, p4, p5);
                        } else {
                            resultTemp = listener.callback(arg0, p2, p3, p4, p5);
                        }
                        if (resultTemp != null) {
                            result = resultTemp;
                        }
                    }
                }
            }
            if (result && (result.hasOwnProperty("isStopped") || result.hasOwnProperty("value"))) {
                return result.value;
            }
            return result;
        };
        proto.has = function(callback, thisArg = null) {
            if (callback == null) return false;
            return this._get(callback, thisArg) != null;
        };
        proto.release = function() {
            EventTrigger.put(this);
        };
        proto._on = function(callback, isOnce, thisArg, priority, hasEventArg = true) {
            if (callback == null || this.__gdk_inPool__) {
                return;
            }
            if (!this._callbacks) {
                this._callbacks = [];
            }
            var listener = this._get(callback, thisArg);
            if (listener == null) {
                listener = Listener.get();
                this._callbacks.push(listener);
                listener.callback = callback;
                listener.thisArg = thisArg;
            }
            listener.priority = priority;
            this._isSortCallback = priority != 0 || this._isSortCallback;
            listener.isOnce = isOnce;
            listener.hasEventArg = hasEventArg;
        };
        proto._get = function(callback, thisArg = null) {
            let callbacks = this._callbacks;
            if (callbacks && callbacks.length > 0) {
                for (var i = 0, n = callbacks.length; i < n; i++) {
                    let lis = callbacks[i];
                    if (lis.callback === callback && lis.thisArg === thisArg) {
                        return lis;
                    }
                }
            }
            return null;
        };
        function _remove(arr, i) {
            arr[i] = arr[arr.length - 1];
            --arr.length;
        }
        function _sortCallBack(o1, o2) {
            return o1.priority > o2.priority ? -1 : 1;
        }
        EventTrigger.get = function() {
            return pool.get(EventTrigger);
        };
        EventTrigger.put = function(e) {
            e.offAll();
            pool.put(e);
        };
        function Listener() {
            this.unuse();
        }
        Listener.prototype.unuse = function() {
            this.callback = null;
            this.isOnce = false;
            this.thisArg = null;
            this.priority = 0;
            this.hasEventArg = true;
        };
        Listener.get = function() {
            return pool.get(Listener);
        };
        Listener.put = function(listener) {
            pool.put(listener);
        };
        module.exports = EventTrigger;
        cc._RF.pop();
    }, {
        "../managers/gdk_PoolManager": 219
    } ],
    174: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "211f0L2NHdAZq/mYYSD7NWK", "gdk_Loader");
        const Timer = require("./gdk_Timer");
        const PoolManager = require("../managers/gdk_PoolManager");
        const POOL_NAME = "__gdk_loader__Loader";
        function Loader() {
            this.unuse();
            this._onProgress = this._onProgress.bind(this);
            this._onLoadFinished = this._onLoadFinished.bind(this);
        }
        var proto = Loader.prototype;
        Object.defineProperty(proto, "loadedRes", {
            get() {
                return this._loadedRes;
            },
            enumerable: true,
            configurable: true
        });
        proto.load = function(resources, trigger, loadCallback, isPreload) {
            this._trigger = trigger;
            this._loadCallback = loadCallback;
            this._isPreload = !!isPreload;
            if (!(resources instanceof Array)) {
                resources = [ resources ];
            }
            var toLoadRes = [];
            var toLoadCount = 0;
            for (var i = 0; i < resources.length; i++) {
                var item = resources[i];
                if (item && item.resArray && item.resArray.length > 0) {
                    toLoadRes.push(item);
                    toLoadCount += 1;
                }
            }
            this._toLoadRes = toLoadRes;
            this._needloadCount = toLoadCount;
            this._loadedRes = [];
            this._loadRes();
            return this;
        };
        proto._loadRes = function() {
            while (this._toLoadRes.length > 0) {
                var item = this._toLoadRes.shift();
                if (item.resArray && item.resArray.length > 0) {
                    var resArray = [];
                    for (var i = item.resArray.length - 1; i >= 0; i--) {
                        var m = item.resArray[i];
                        if (m && m != "") {
                            if (item.type == "uuid") {
                                resArray.push({
                                    uuid: m
                                });
                            } else if (item.type == "scene") {
                                resArray.push({
                                    scene: m
                                });
                            } else {
                                resArray.push(m);
                            }
                        }
                    }
                    if (resArray.length > 0) {
                        cc.resources.load(resArray, item.type, this._onProgress, this._onLoadFinished);
                        return;
                    }
                }
            }
            this._onLoadFinished();
        };
        proto._onProgress = function(completedCount, totalCount, item) {
            if (!item) return;
            if (!this._trigger) return;
            var a = 100 / this._needloadCount;
            var p = a * this._loadedCount;
            if (totalCount > 0) {
                p += a * completedCount / totalCount;
            } else {
                p += a;
            }
            this._trigger(p, 100);
        };
        proto._onLoadFinished = function(err, loadedRes) {
            if (err) {
                cc.error("download file error: ", err);
            }
            if (loadedRes) {
                if (loadedRes instanceof cc.Asset) {
                    this._loadedRes.push(loadedRes);
                } else if (loadedRes.length > 0) {
                    this._loadedRes.push(...loadedRes);
                }
            }
            this._loadedCount++;
            if (this._toLoadRes.length == 0) {
                this._trigger && this._trigger(100, 100);
                this._loadCallback && Timer.callLater(this, this._loadCallback, [ err, this._loadedRes ]);
                this._recover();
                return;
            }
            this._loadRes();
        };
        proto.unuse = function() {
            this._trigger = null;
            this._loadCallback = null;
            this._isPreload = false;
            this._toLoadRes = null;
            this._loadedRes = null;
            this._loadedCount = 0;
            this._needLoadCount = 0;
        };
        proto._recover = function() {
            PoolManager.put(POOL_NAME, this);
        };
        Loader.load = function(resources, trigger, loadCallback, isPreload) {
            var t = PoolManager.get(POOL_NAME);
            if (!t) {
                t = new Loader();
            }
            return t.load(resources, trigger, loadCallback, isPreload);
        };
        Loader.getRes = function(url, type) {
            return cc.resources.get(url, type);
        };
        Loader.getResBy = function(uuid) {
            let info = cc.resources.getAssetInfo(uuid);
            if (!info) return;
            return cc.resources.get(info.path, info.ctor);
        };
        Loader.loadRes = function(url, type, cb) {
            let asset = cc.resources.get(url, type);
            if (asset) {
                cb && Timer.callLater(null, cb, [ null, asset ]);
                return;
            }
            cc.resources.load(url, type, null, cb);
        };
        Loader.loadResBy = function(uuid, cb) {
            let info = cc.resources.getAssetInfo(uuid);
            if (!info) return;
            this.loadRes(info.path, info.ctor, cb);
        };
        module.exports = Loader;
        cc._RF.pop();
    }, {
        "../managers/gdk_PoolManager": 219,
        "./gdk_Timer": 177
    } ],
    175: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "38769wOAW5HXYeSMI9xu6il", "gdk_ModuleLoader");
        var Timer = require("../core/gdk_Timer");
        var DelayCall = require("../core/gdk_DelayCall");
        var Loader = require("../core/gdk_Loader");
        var ResourceId = require("../enums/gdk_ResourceId");
        function getModuleRes(res) {
            var arr = [];
            for (var k in res) {
                var item = res[k];
                if (item && item.resArray && item.resArray.length > 0) {
                    arr.push(item);
                }
            }
            return arr;
        }
        function parseDepends(uuid, parsed) {
            var arr = cc.assetManager.dependUtil.getDepsRecursively(uuid);
            for (var i = 0, n = arr.length; i < n; i++) {
                var uuid = arr[i];
                if (!parsed[uuid]) {
                    parsed[uuid] = true;
                    parseDepends(uuid, parsed);
                }
            }
        }
        function getDependsRecursively(res, parsed) {
            parsed === void 0 && (parsed = {});
            parsed[res._uuid] = true;
            parseDepends(res._uuid, parsed);
            return parsed;
        }
        function getReleaseMapByList(releaseRes, releaseMap) {
            releaseMap === void 0 && (releaseMap = Object.create(null));
            if (releaseRes) {
                for (var i = 0, len = releaseRes.length; i < len; i++) {
                    getDependsRecursively(releaseRes[i], releaseMap);
                }
            }
            return releaseMap;
        }
        var _gdkReleaseMap = null;
        var _ignoreErrorStatus = {
            403: true,
            404: true,
            undefined: true
        };
        var ModuleLoader = {
            _resLoader: Loader,
            _loading: 0,
            _loadMap: {},
            _loadingCallbacksMap: {},
            _preloading: false,
            _preloadList: [],
            _preloadedMap: {},
            loadModules(panelId, modules, pcb, cb) {
                if (!(modules instanceof Array)) {
                    modules = [ modules ];
                }
                this.removeLowPriorityModules(modules, true);
                if (modules && modules.length > 0) {
                    var toLoad = this._getResources(modules);
                    if (toLoad && toLoad.length > 0) {
                        this._load(panelId, toLoad, pcb, cb);
                        return;
                    }
                }
                pcb && pcb(100);
                cb && cb();
            },
            loadResArray(panelId, urls, pcb, cb) {
                if (!(urls instanceof Array)) {
                    urls = [ urls ];
                }
                if (urls && urls.length > 0) {
                    this._load(panelId, urls, pcb, cb);
                    return;
                }
                pcb && pcb(100);
                cb && cb();
            },
            _load(panelId, toLoad, pcb, cb, delay = 0) {
                if (delay > 3) {
                    delay = 3;
                }
                if (!this._loadMap[panelId]) {
                    this._loadMap[panelId] = [];
                }
                this._loading++;
                this._resLoader.load(toLoad, pcb, (err, loadedRes) => {
                    if (err && !_ignoreErrorStatus[err.status] && !!this._loadMap[panelId]) {
                        CC_DEBUG && console.error(err);
                        DelayCall.addCall(() => {
                            this._loading--;
                            this._load(panelId, toLoad, pcb, cb, delay + .05);
                        }, null, delay);
                        return;
                    }
                    this._loadResArrayComplete(err, loadedRes, panelId, cb);
                }, false);
            },
            _loadResArrayComplete(err, loadedRes, panelId, cb) {
                if (loadedRes && loadedRes.length > 0) {
                    if (this._loadMap[panelId]) {
                        for (let i = 0, n = loadedRes.length; i < n; i++) {
                            this.addResTo(panelId, loadedRes[i]);
                        }
                    } else {
                        for (let i = 0, n = loadedRes.length; i < n; i++) {
                            this.removeResFrom(loadedRes[i]);
                        }
                    }
                }
                try {
                    cb && cb(err, loadedRes);
                } catch (error) {
                    CC_DEBUG && console.error(error);
                    CC_DEBUG && console.trace();
                }
                this._loading--;
                this._loading == 0 && Timer.callLater(this, this._loadNextLowerModule);
            },
            loadRes(panelId, url, type, cb, isuuid, delay = 0) {
                if (delay > 3) {
                    delay = 3;
                }
                if (!this._loadMap[panelId]) {
                    this._loadMap[panelId] = [];
                }
                var map = this._loadingCallbacksMap[panelId];
                if (!map) {
                    map = this._loadingCallbacksMap[panelId] = {};
                }
                var queue = map[url];
                var loading = !!queue;
                if (!loading) {
                    queue = map[url] = [];
                }
                if (cb) {
                    queue.push(cb);
                }
                if (!loading || delay > 0) {
                    this._loading++;
                    let callback = (err, res) => {
                        if (err && !_ignoreErrorStatus[err.status] && type !== cc.AudioClip) {
                            CC_DEBUG && console.error(err);
                            let map = this._loadingCallbacksMap[panelId];
                            if (map && map[url]) {
                                DelayCall.addCall(() => {
                                    this._loading--;
                                    let map = this._loadingCallbacksMap[panelId];
                                    if (map && map[url]) {
                                        this.loadRes(panelId, url, type, null, isuuid, delay + .25);
                                    }
                                }, null, delay);
                                return;
                            }
                        }
                        this._loadResComplete(err, res, panelId, url, type);
                    };
                    if (isuuid) {
                        this._resLoader.loadResBy(url, callback);
                    } else {
                        this._resLoader.loadRes(url, type, callback);
                    }
                }
            },
            _loadResComplete(err, res, panelId, url, type) {
                let map = this._loadingCallbacksMap[panelId];
                let queue = map ? map[url] : null;
                if (!err && res) {
                    if (queue) {
                        this.addResTo(panelId, res);
                    } else {
                        this.removeResFrom(res);
                    }
                }
                if (queue) {
                    delete map[url];
                    for (let i = 0, n = queue.length; i < n; i++) {
                        let cb = queue[i];
                        try {
                            cb && cb(err, res);
                        } catch (error) {
                            CC_DEBUG && console.error(error);
                            CC_DEBUG && console.trace();
                        }
                    }
                    if (Object.keys(map).length == 0) {
                        delete this._loadingCallbacksMap[panelId];
                    }
                }
                this._loading--;
                this._loading == 0 && Timer.callLater(this, this._loadNextLowerModule);
            },
            addResTo(panelId, res) {
                if (res instanceof cc.SceneAsset) {
                    this.removeResFrom(res, panelId);
                    return;
                }
                let arr = this._loadMap[panelId];
                if (!arr) {
                    res.addRef();
                    this._loadMap[panelId] = [ res ];
                } else {
                    let index = arr.indexOf(res);
                    if (index === -1) {
                        res.addRef();
                        arr.push(res);
                    }
                }
                cc.assetManager.removeFromRelease(res);
            },
            removeResFrom(res, panelId) {
                let arr = this._loadMap[panelId];
                if (arr) {
                    let index = arr.indexOf(res);
                    if (index !== -1) {
                        res.decRef();
                        arr.splice(index, 1);
                    }
                }
                let ids = getDependsRecursively(res, {});
                for (let uuid in ids) {
                    cc.assetManager.releaseUuid(uuid);
                }
            },
            addLowPriorityModules(modules) {
                if (!modules || modules.length < 1) return;
                for (var i = 0, len = modules.length; i < len; i++) {
                    var m = modules[i];
                    if (this._preloadedMap[m]) continue;
                    if (m && this._preloadList.indexOf(m) == -1) {
                        this._preloadList.push(m);
                    }
                }
                this._loading == 0 && Timer.callLater(this, this._loadNextLowerModule);
            },
            removeLowPriorityModules(modules, flag) {
                if (!modules || modules.length < 1) return;
                flag === void 0 && (flag = false);
                for (var i = 0, len = modules.length; i < len; i++) {
                    var m = modules[i];
                    var idx = this._preloadList.indexOf(m);
                    if (idx != -1) {
                        this._preloadList.splice(idx, 1);
                        flag && (this._preloadedMap[m] = true);
                    }
                }
            },
            addLowPriorityResources(urls, type, panelId) {
                if (!urls || urls.length < 1) return;
                let module = {
                    panelId: panelId
                };
                module[panelId || "anymouse"] = {
                    resArray: urls,
                    type: type
                };
                this._preloadList.push(module);
                this._loading == 0 && Timer.callLater(this, this._loadNextLowerModule);
            },
            releaseRes(panelId) {
                var releaseRes = this._loadMap[panelId];
                if (releaseRes) {
                    for (let i = releaseRes.length - 1; i >= 0; i--) {
                        this.removeResFrom(releaseRes[i], panelId);
                    }
                    delete this._loadMap[panelId];
                    delete this._loadingCallbacksMap[panelId];
                }
                for (let i = this._preloadList.length - 1; i >= 0; i--) {
                    let item = this._preloadList[i];
                    if (!cc.js.isString(item) && item.panelId == panelId) {
                        this._preloadList.splice(i, 1);
                    }
                }
            },
            releaseOneRes(panelId, res, type) {
                if (typeof res === "string") {
                    let map = this._loadingCallbacksMap[panelId];
                    if (map && map[res]) {
                        delete map[res];
                        if (Object.keys(map).length == 0) {
                            delete this._loadingCallbacksMap[panelId];
                        }
                    }
                    res = this.getRes(res, type);
                }
                res && this.removeResFrom(res, panelId);
            },
            releaseAll() {
                for (let panelId in this._loadMap) {
                    this.releaseRes(panelId);
                }
                this._loadMap = {};
                this._loadingCallbacksMap = {};
                this._preloadList.length = 0;
            },
            getRes(url, type, isuuid) {
                if (isuuid) {
                    return this._resLoader.getResBy(url);
                }
                return this._resLoader.getRes(url, type);
            },
            _getResources(modules) {
                var toLoad = [];
                for (var i = 0, len = modules.length; i < len; i++) {
                    var m = modules[i];
                    if (!m) continue;
                    if (cc.js.isString(m)) {
                        m = ResourceId.getValue(m);
                    }
                    toLoad.push(...getModuleRes(m));
                }
                return toLoad;
            },
            _loadNextLowerModule() {
                if (this._loading > 0) return;
                if (this._preloading) return;
                if (this._preloadList.length < 1) return;
                if (require("../managers/gdk_PanelManager").hasOpening) return;
                var modu = this._preloadList.shift();
                var urls = this._getResources([ modu ]);
                if (cc.js.isString(modu)) {
                    this._preloadedMap[modu] = true;
                }
                this._preloading = true;
                this._resLoader.load(urls, null, (err, loadedRes) => {
                    if (loadedRes && loadedRes.length > 0) {
                        let isDepend = false;
                        if (!cc.js.isString(modu) && modu.panelId) {
                            isDepend = !!this._loadMap[modu.panelId];
                            if (isDepend) {
                                for (let i = 0, n = loadedRes.length; i < n; i++) {
                                    this.addResTo(modu.panelId, loadedRes[i]);
                                }
                            }
                        }
                        if (!isDepend) {
                            for (let i = loadedRes.length - 1; i >= 0; i--) {
                                this.removeResFrom(loadedRes[i]);
                            }
                        }
                    }
                    this._preloading = false;
                    this._loading == 0 && Timer.callLater(this, this._loadNextLowerModule);
                }, true);
            },
            getGdkReleaseMap() {
                if (_gdkReleaseMap == null) {
                    let GUIManager = require("../managers/gdk_GUIManager");
                    let arr = [];
                    GUIManager.waitingPrefab && arr.push(GUIManager.waitingPrefab);
                    GUIManager.alertPrefab && arr.push(GUIManager.alertPrefab);
                    GUIManager.toolTipPrefab && arr.push(GUIManager.toolTipPrefab);
                    GUIManager.messageBgPrefab && arr.push(GUIManager.messageBgPrefab);
                    GUIManager.messagePrefab && arr.push(GUIManager.messagePrefab);
                    GUIManager.maskPrefab && arr.push(GUIManager.maskPrefab);
                    _gdkReleaseMap = getReleaseMapByList(arr);
                }
                return _gdkReleaseMap;
            },
            getAllExcludeMap() {
                let excludes = Object.create(null);
                for (let panelId in this._loadMap) {
                    let arr = this._loadMap[panelId];
                    if (arr) {
                        for (let i = 0, n = arr.length; i < n; i++) {
                            excludes[arr[i]._uuid] = true;
                        }
                    }
                }
                return excludes;
            }
        };
        Object.defineProperty(ModuleLoader, "isLoading", {
            get() {
                return this._preloading || this._loading > 0;
            },
            enumerable: true,
            configurable: true
        });
        module.exports = ModuleLoader;
        cc._RF.pop();
    }, {
        "../core/gdk_DelayCall": 171,
        "../core/gdk_Loader": 174,
        "../core/gdk_Timer": 177,
        "../enums/gdk_ResourceId": 202,
        "../managers/gdk_GUIManager": 215,
        "../managers/gdk_PanelManager": 218
    } ],
    176: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "e915bMqOiNLZZopl+Ty54Ga", "gdk_Pool");
        function _destroyObj(pool, obj) {
            pool.onClear && pool.onClear(obj);
            obj.destroy && obj.destroy.call(obj);
        }
        function Pool() {
            this.onClear;
            this.onPut;
            this.onGet;
            this.createFun;
            this._size = 10;
            this._pool = [];
            this._clearTime = null;
        }
        var proto = Pool.prototype;
        proto.get = function() {
            var pool = this._pool;
            var cache = null;
            while (pool.length > 0) {
                var obj = pool.pop();
                if (cc.isValid(obj, true)) {
                    cache = obj;
                    break;
                }
            }
            if (this.onGet) {
                var result = this.onGet(cache);
                if (result != null && result == false) {
                    cache = null;
                }
            }
            if (cache) {
                if (cache.reuse) cache.reuse.call(cache);
                if (cache.__gdk_inPool__) delete cache.__gdk_inPool__;
                if (cache.__gdk_inPoolTime__) delete cache.__gdk_inPoolTime__;
                if (pool.length == 0) {
                    const Timer = require("./gdk_Timer");
                    Timer.clear(this, this.clearInactivity);
                }
            } else {
                if (this.createFun) cache = this.createFun();
            }
            return cache;
        };
        proto.isInPool = function(obj) {
            return obj.__gdk_inPool__ == true;
        };
        proto.put = function(obj) {
            if (!obj || obj.__gdk_inPool__) return;
            if (!cc.isValid(obj, true)) return;
            var pool = this._pool;
            if (this.onPut) this.onPut(obj);
            if (obj.unuse) obj.unuse.call(obj);
            if (pool.length < this._size) {
                obj.__gdk_inPool__ = true;
                obj.__gdk_inPoolTime__ = Date.now();
                pool.push(obj);
                if (pool.length === 1) {
                    let clearTime = this.clearTime;
                    if (clearTime > 0) {
                        const Timer = require("./gdk_Timer");
                        Timer.loop(clearTime / 2 * 1e3, this, this.clearInactivity);
                    }
                }
            } else {
                _destroyObj(this, obj);
            }
        };
        proto.unClear = function() {
            this.clearTime = -1;
        };
        proto.clearAll = function() {
            const Timer = require("./gdk_Timer");
            Timer.clear(this, this.clearInactivity);
            var pool = this._pool;
            var n = pool.length;
            if (n == 0) return;
            var arr = pool.splice(0, n);
            for (var i = 0; i < n; i++) {
                _destroyObj(this, arr[i]);
            }
        };
        proto.clearInactivity = function() {
            var pool = this._pool;
            var now = Date.now();
            var expire = this.clearTime * 1e3;
            for (var i = 0, n = pool.length; i < n; i++) {
                var obj = pool[i];
                if (now - obj.__gdk_inPoolTime__ < expire) {
                    break;
                }
            }
            if (i == 0) return;
            var arr = pool.splice(0, i);
            for (var i = 0, n = arr.length; i < n; i++) {
                _destroyObj(this, arr[i]);
            }
            if (pool.length == 0) {
                const Timer = require("./gdk_Timer");
                Timer.clear(this, this.clearInactivity);
            }
        };
        Object.defineProperty(proto, "size", {
            set(value) {
                if (value < 0) value = 0;
                this._size = value;
                if (this._pool.length > value) {
                    var arr = this._pool.splice(value);
                    for (var i = 0, n = arr.length; i < n; i++) {
                        _destroyObj(this, arr[i]);
                    }
                }
            },
            get() {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, "count", {
            get: function() {
                return this._pool.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, "clearTime", {
            get() {
                if (this._clearTime === null) {
                    return Pool.clearTime;
                }
                return this._clearTime;
            },
            set(value) {
                value = value < 0 ? 0 : value;
                if (this._clearTime == value) return;
                this._clearTime = value;
                if (this._pool.length > 0) {
                    const Timer = require("./gdk_Timer");
                    if (value < 1) {
                        Timer.clear(this, this.clearInactivity);
                    } else {
                        Timer.loop(value / 2 * 1e3, this, this.clearInactivity);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Pool.clearTime = 60 * 2;
        module.exports = Pool;
        cc._RF.pop();
    }, {
        "./gdk_Timer": 177
    } ],
    177: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ed53ey4vgZGRbQZ2F5Ohaft", "gdk_Timer");
        const Tool = require("./gdk_Tool");
        const PoolManager = require("../managers/gdk_PoolManager");
        const POOL_NAME = "__gdk_timer__";
        var TimerHandler = cc.Class({
            name: "TimerHandler",
            extends: null,
            properties: {
                key: 0,
                repeat: false,
                delay: 0,
                userFrame: false,
                exeTime: 0,
                caller: null,
                method: null,
                args: null,
                jumpFrame: false
            },
            clear() {
                this.key = 0;
                this.caller = null;
                this.method = null;
                this.args = null;
            },
            run(withClear) {
                var caller = this.caller;
                if (caller && caller.destroyed) return this.clear();
                var method = this.method;
                var args = this.args;
                if (withClear) this.clear();
                if (method) {
                    try {
                        args ? method.apply(caller, args) : method.call(caller);
                    } catch (e) {
                        cc.error(e);
                    }
                }
            },
            recover() {
                this.clear();
                PoolManager.put(POOL_NAME + "_TimerHandler", this);
            },
            statics: {
                _id: 1,
                get() {
                    var t = PoolManager.get(POOL_NAME + "_TimerHandler");
                    if (!t) {
                        t = new TimerHandler();
                    }
                    t.key = TimerHandler._id++;
                    return t;
                }
            }
        });
        var LaterHandler = cc.Class({
            name: "LaterHandler",
            extends: null,
            properties: {
                key: 0,
                caller: null,
                method: null,
                args: null
            },
            clear() {
                this.key = 0;
                this.caller = null;
                this.method = null;
                this.args = null;
            },
            run(withClear) {
                var caller = this.caller;
                if (caller && caller.destroyed) return this.clear();
                var method = this.method;
                var args = this.args;
                if (withClear) this.clear();
                if (method) {
                    try {
                        args ? method.apply(caller, args) : method.call(caller);
                    } catch (e) {
                        cc.error(e);
                    }
                }
            },
            recover() {
                this.clear();
                PoolManager.put(POOL_NAME + "_LaterHandler", this);
            },
            statics: {
                _id: 1,
                get() {
                    var t = PoolManager.get(POOL_NAME + "_LaterHandler");
                    if (!t) {
                        t = new LaterHandler();
                    }
                    t.key = LaterHandler._id++;
                    return t;
                }
            }
        });
        var CallLater = cc.Class({
            name: "CallLater",
            extends: null,
            properties: {
                _laters: [],
                _temp: []
            },
            _update() {
                var laters = this._laters;
                var len = laters.length;
                if (len > 0) {
                    this._laters = this._temp;
                    this._temp = laters;
                    for (var i = 0, n = len - 1; i <= n; i++) {
                        var handler = laters[i];
                        if (handler.method !== null) {
                            handler.run();
                        }
                        handler.recover();
                        i === n && (n = laters.length - 1);
                    }
                    laters.length = 0;
                }
            },
            _getHandler(caller, method) {
                var laters = this._laters;
                for (var i = 0, n = laters.length; i < n; i++) {
                    var handler = laters[i];
                    if (handler.caller == caller && handler.method == method) {
                        return handler;
                    }
                }
                return null;
            },
            callLater(caller, method, args) {
                var handler = this._getHandler(caller, method);
                if (handler) {
                    handler.args = args;
                    return;
                }
                handler = LaterHandler.get();
                handler.caller = caller;
                handler.method = method;
                handler.args = args;
                this._laters.push(handler);
            },
            runCallLater(caller, method) {
                var handler = this._getHandler(caller, method);
                if (handler && handler.method !== null) {
                    handler.run(true);
                }
            }
        });
        CallLater.I = new CallLater();
        var Timer = cc.Class({
            name: "Timer",
            extends: null,
            properties: {
                scale: 1,
                currFrame: null,
                _delta: null,
                _handlers: null,
                _temp: null,
                _count: 0,
                currTimer: 0,
                _lastTimer: 0
            },
            ctor() {
                this.scale = 1;
                this.currFrame = 0;
                this._delta = 0;
                this._handlers = [];
                this._temp = [];
                this._count = 0;
                this.currTimer = Date.now();
                this._lastTimer = Date.now();
            },
            update(dt) {
                if (this.scale <= 0) {
                    this._lastTimer = Date.now();
                    return;
                }
                var frame = this.currFrame = this.currFrame + this.scale;
                var now = Date.now();
                var delta = (now - this._lastTimer) * this.scale;
                var timer = this.currTimer = this.currTimer + delta;
                this._lastTimer = now;
                this._delta = delta;
                this._count = 0;
                var handlers = this._handlers;
                for (var i = 0, n = handlers.length; i < n; i++) {
                    var handler = handlers[i];
                    if (handler.method !== null) {
                        var t = handler.userFrame ? frame : timer;
                        if (t >= handler.exeTime) {
                            if (handler.repeat) {
                                if (!handler.jumpFrame) {
                                    handler.exeTime += handler.delay;
                                    handler.run(false);
                                    if (t > handler.exeTime) {
                                        handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay;
                                    }
                                } else {
                                    while (t >= handler.exeTime) {
                                        handler.exeTime += handler.delay;
                                        handler.run(false);
                                    }
                                }
                            } else {
                                handler.run(true);
                            }
                        }
                    } else {
                        this._count++;
                    }
                }
                CallLater.I._update();
                if (this._count > 30 || frame % 200 === 0) this._clearHandlers();
            },
            _clearHandlers() {
                var handlers = this._handlers;
                for (var i = 0, n = handlers.length; i < n; i++) {
                    var handler = handlers[i];
                    if (handler.method !== null) {
                        this._temp.push(handler);
                    } else {
                        handler.recover();
                    }
                }
                handlers.length = 0;
                this._handlers = this._temp;
                this._temp = handlers;
            },
            _create(useFrame, repeat, delay, caller, method, args, coverBefore) {
                var handler;
                if (coverBefore) {
                    handler = this._getHandler(caller, method);
                    if (handler) {
                        handler.repeat = repeat;
                        handler.userFrame = useFrame;
                        handler.delay = delay;
                        handler.caller = caller;
                        handler.method = method;
                        handler.args = args;
                        handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer);
                        return handler;
                    }
                }
                handler = TimerHandler.get();
                handler.repeat = repeat;
                handler.userFrame = useFrame;
                handler.delay = delay;
                handler.caller = caller;
                handler.method = method;
                handler.args = args;
                handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer);
                this._handlers.push(handler);
                return handler;
            },
            once(delay, caller, method, args, coverBefore) {
                coverBefore === void 0 && (coverBefore = true);
                this._create(false, false, delay, caller, method, args, coverBefore);
            },
            loop(delay, caller, method, args, coverBefore, jumpFrame) {
                coverBefore === void 0 && (coverBefore = true);
                jumpFrame === void 0 && (jumpFrame = false);
                var handler = this._create(false, true, delay, caller, method, args, coverBefore);
                if (handler) handler.jumpFrame = jumpFrame;
            },
            frameOnce(delay, caller, method, args, coverBefore) {
                coverBefore === void 0 && (coverBefore = true);
                this._create(true, false, delay, caller, method, args, coverBefore);
            },
            frameLoop(delay, caller, method, args, coverBefore) {
                coverBefore === void 0 && (coverBefore = true);
                this._create(true, true, delay, caller, method, args, coverBefore);
            },
            toString() {
                return " handlers:" + this._handlers.length;
            },
            clear(caller, method) {
                var handlers = this._handlers;
                for (var i = 0, n = handlers.length; i < n; i++) {
                    var handler = handlers[i];
                    if (handler.caller == caller && handler.method == method) {
                        handler.clear();
                    }
                }
            },
            clearAll(caller) {
                if (!caller) return;
                var handlers = this._handlers;
                for (var i = 0, n = handlers.length; i < n; i++) {
                    var handler = handlers[i];
                    if (handler.caller === caller) {
                        handler.clear();
                    }
                }
            },
            _getHandler(caller, method) {
                var handlers = this._handlers;
                for (var i = 0, n = handlers.length; i < n; i++) {
                    var handler = handlers[i];
                    if (handler.caller == caller && handler.method == method) {
                        return handler;
                    }
                }
                return null;
            },
            callLater(caller, method, args) {
                CallLater.I.callLater(caller, method, args);
            },
            runCallLater(caller, method) {
                CallLater.I.runCallLater(caller, method);
            },
            runTimer(caller, method) {
                var handler = this._getHandler(caller, method);
                if (handler) {
                    handler.run(true);
                }
            },
            pause() {
                this.scale = 0;
            },
            resume() {
                this.scale = 1;
            }
        });
        const systemTimer = Tool.getSingleton(Timer);
        if (!CC_EDITOR) {
            cc.game.once(cc.game.EVENT_ENGINE_INITED, () => {
                cc.director.getScheduler().enableForTarget(systemTimer);
                cc.director.getScheduler().scheduleUpdate(systemTimer, cc.Scheduler.PRIORITY_SYSTEM, false);
            });
        }
        module.exports = systemTimer;
        cc._RF.pop();
    }, {
        "../managers/gdk_PoolManager": 219,
        "./gdk_Tool": 178
    } ],
    178: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "4c57amk0E1CgaZz1G76eKcs", "gdk_Tool");
        let Tool = {
            getSingleton(clazz) {
                if (clazz.__gdk_instance == null) {
                    clazz.__gdk_instance = new clazz();
                }
                return clazz.__gdk_instance;
            },
            destroySingleton(clazz) {
                delete clazz.__gdk_instance;
            },
            getResIdByNode(node) {
                if (!node || node instanceof cc.Scene) {
                    return node ? "Scene#" + cc.director.getScene().name : "Common";
                }
                var panel = node.getComponent(require("../ui/gdk_BasePanel"));
                if (panel && panel.resId) {
                    return panel.resId;
                }
                return this.getResIdByNode(node.parent);
            },
            validate(...args) {
                let n = args.length - 1;
                for (let i = 0; i < n; i++) {
                    if (args[i] != null) {
                        return args[i];
                    }
                }
                return args[n];
            },
            callInNextTick(callback, p1, p2) {
                if (!callback) return;
                setTimeout(function() {
                    callback(p1, p2);
                }, 0);
            },
            execSync(fn) {
                return new Promise((resolve, reject) => {
                    if (!fn) {
                        reject("ERROR");
                        return;
                    }
                    setTimeout(function() {
                        fn();
                        resolve("OK");
                    }, 0);
                });
            }
        };
        module.exports = Tool;
        cc._RF.pop();
    }, {
        "../ui/gdk_BasePanel": 233
    } ],
    179: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "9ad39AYh3lI7JZR/w2MAmf2", "gdk_WorkerLoader");
        var WorkerLoader = function(CONSTS, formatFn) {
            const onMessageHandlerFn = `self.onmessage = evt => {\n        formatFn(evt.data.url, evt.data.options, (err, result) => {\n            let ret = {\n                flag: evt.data.flag,\n                data: {\n                    error: err,\n                    data: result,\n                },\n            };\n            if(!err) {\n                postMessage(ret, [result]);\n                return;\n            }\n            postMessage(ret);\n        });\n    };`;
            const handleResult = evt => {
                const resolve = this.flagMapping[evt.data.flag];
                if (resolve) {
                    resolve(evt.data.data);
                    delete this.flagMapping[evt.data.flag];
                }
            };
            const blob = new Blob([ `(()=>{${CONSTS}${formatFn}${onMessageHandlerFn}})()` ]);
            this.worker = new Worker(URL.createObjectURL(blob));
            this.worker.addEventListener("message", handleResult);
            this.flagMapping = {};
            this.flagId = 0;
            this.excludeFiles = {};
            this.host = document.URL.split("?")[0];
            URL.revokeObjectURL(blob);
        };
        WorkerLoader.prototype.send = function(url, options) {
            const w = this.worker;
            const flag = ++this.flagId;
            url = this.host + url;
            w.postMessage({
                flag: flag,
                url: url,
                options: options
            });
            return new Promise(res => {
                this.flagMapping[flag] = res;
            });
        };
        WorkerLoader.prototype.close = function() {
            this.worker.terminate();
        };
        module.exports = WorkerLoader;
        cc._RF.pop();
    }, {} ],
    180: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "c0be3x7p4VCeJ8UzcvOt2RA", "CCAssetManager");
        if (CC_EDITOR) {} else {
            const gdk = require("../gdk");
            const ResourceManager = require("../managers/gdk_ResourceManager");
            const PanelManager = require("../managers/gdk_PanelManager");
            const releaseFunc = cc.assetManager._releaseManager._free.bind(cc.assetManager._releaseManager);
            const dependMap = cc.assetManager.dependUtil._depends._map;
            function parseDepends(deps, len, depends, gdkdeps) {
                for (let i = 0; i < len; i++) {
                    const e = deps[i];
                    if (gdkdeps[e]) continue;
                    if (depends[e]) continue;
                    depends[e] = true;
                    let r = dependMap[e];
                    if (r) {
                        let a = r.deps;
                        let n = a.length;
                        if (n > 0) {
                            parseDepends(a, n, depends, gdkdeps);
                        }
                    }
                }
            }
            function getAssetPath(uuid) {
                let bundles = cc.assetManager.bundles;
                for (let e in bundles._map) {
                    let config = bundles._map[e]._config;
                    let info = config.assetInfos._map[uuid];
                    if (info) {
                        return config.base + info.path;
                    }
                }
                return null;
            }
            var ReleaseManager = function() {
                this._excludeKeys = Object.create(null);
                this._releasedKeys = Object.create(null);
                this._intervalID = -1;
                if (cc.sys.platform === cc.sys.WECHAT_GAME) {
                    const wx = window["wx"];
                    wx.onMemoryWarning(() => {
                        cc.warn("onMemoryWarningReceive");
                        for (var e in this._releasedKeys) {
                            this._releasedKeys[e] = 1;
                        }
                        this.stop();
                        this.start(1e3 / 30);
                    });
                }
            };
            var __proto = ReleaseManager.prototype;
            __proto.add = function(uuid) {
                var exsit = !!this._releasedKeys[uuid];
                this._releasedKeys[uuid] = cc.sys.platform === cc.sys.WECHAT_GAME ? Date.now() : 1;
                if (!exsit) {
                    let size = 0;
                    for (let _ in this._releasedKeys) {
                        size++;
                        if (size > 1) {
                            break;
                        }
                    }
                    if (size == 1) {
                        this.start();
                    }
                }
            };
            __proto.remove = function(uuid) {
                if (this._releasedKeys[uuid]) {
                    delete this._releasedKeys[uuid];
                    let size = 0;
                    for (let _ in this._releasedKeys) {
                        size++;
                        break;
                    }
                    if (size == 0) {
                        this.stop();
                    }
                }
            };
            __proto.start = function(t) {
                if (this._intervalID !== -1) {
                    return;
                }
                this._intervalID = setInterval(this.release_timer.bind(this), t === void 0 ? gdk.macro.RESOURCE_RELEASE_INTERVAL : t);
            };
            __proto.stop = function() {
                if (this._intervalID === -1) {
                    return;
                }
                clearInterval(this._intervalID);
                this._intervalID = -1;
            };
            __proto.release_timer = function() {
                let size = 0;
                for (let _ in this._releasedKeys) {
                    size++;
                    break;
                }
                if (size == 0) {
                    this.stop();
                    return;
                }
                if (ResourceManager.isLoading) return;
                if (PanelManager.hasOpening) return;
                const startTime = CC_DEBUG && CC_TEST ? Date.now() : 0;
                CC_DEBUG && CC_TEST && cc.log(`开始回收资源, ${this.info}`);
                const assets = cc.assetManager.assets;
                const gdkdeps = ResourceManager._loader.getGdkReleaseMap();
                const excludes = this._excludeKeys;
                const releasedKeys = this._releasedKeys;
                const released = Object.create(null);
                const now = Date.now();
                const timeout = gdk.macro.RESOURCE_RELEASE_TIMEOUT;
                let array = Object.keys(releasedKeys);
                let norelease = true;
                for (let i = 0, n = array.length; i < n; i++) {
                    const e = array[i];
                    if (gdkdeps[e] || excludes[e]) {
                        delete released[e];
                        delete releasedKeys[e];
                        continue;
                    }
                    if (now - releasedKeys[e] < timeout) {
                        continue;
                    }
                    norelease = false;
                    released[e] = true;
                    let r = dependMap[e];
                    if (r) {
                        let a = r.deps;
                        let n = a.length;
                        if (n > 0) {
                            parseDepends(a, n, released, gdkdeps);
                        }
                    }
                }
                if (norelease) {
                    return;
                }
                const excludeSets = ResourceManager._excludeRelease;
                const depends = Object.create(null);
                array = Object.keys(assets._map);
                for (let i = 0, n = array.length; i < n; i++) {
                    const e = array[i];
                    if (gdkdeps[e] || depends[e] || excludes[e]) {
                        delete released[e];
                        delete releasedKeys[e];
                        continue;
                    }
                    if (released[e]) {
                        let skip = true;
                        if (excludeSets) {
                            const d = getAssetPath(e);
                            if (d && excludeSets.some(p => d.startsWith(p))) {
                                skip = false;
                                excludes[e] = true;
                                delete released[e];
                                delete releasedKeys[e];
                            }
                        }
                        if (skip) continue;
                    }
                    depends[e] = true;
                    let r = dependMap[e];
                    if (r && r.deps) {
                        for (let j = r.deps.length - 1; j >= 0; j--) {
                            const e2 = r.deps[j];
                            depends[e2] = true;
                        }
                    }
                }
                let count = assets.count;
                let max = gdk.macro.RESOURCE_RELEASE_MAX;
                array = Object.keys(released);
                for (let i = 0, n = array.length; i < n; i++) {
                    const e = array[i];
                    delete released[e];
                    delete releasedKeys[e];
                    if (gdkdeps[e] || depends[e] || excludes[e]) {
                        continue;
                    }
                    const asset = assets._map[e];
                    if (asset) {
                        releaseFunc(asset);
                        if (count - assets.count > max) {
                            break;
                        }
                    }
                }
                CC_DEBUG && CC_TEST && cc.log(`结束回收资源, 耗时: ${Date.now() - startTime}(ms), 本次回收资源数：${count - assets.count}, ${this.info}`);
            };
            CC_DEBUG && Object.defineProperty(__proto, "info", {
                get() {
                    let c = cc.assetManager.assets.count;
                    let s = Object.keys(this._releasedKeys).length;
                    return `缓存的资源总数: ${c}, 待回收资源数: ${s}`;
                }
            });
            var proto = cc.assetManager._releaseManager;
            var manager = new ReleaseManager(proto);
            proto.$ReleaseManager0_tryRelease = proto.tryRelease;
            proto.tryRelease = function(asset, force) {
                if (!(asset instanceof cc.Asset)) return;
                manager.add(asset._uuid);
            };
            proto = cc.assetManager;
            proto.$AssetManager0_removeFromRelease = function(requests, options) {
                let output = this._transform(requests, options);
                if (output instanceof Array) {
                    for (let i = 0, n = output.length; i < n; i++) {
                        manager.remove(this.utils.getUuidFromURL(output[i]));
                    }
                } else if (output) {
                    manager.remove(this.utils.getUuidFromURL(output));
                }
            };
            const Task = cc.AssetManager.Task;
            const parseParameters = function(options, onProgress, onComplete) {
                if (onComplete === undefined) {
                    var isCallback = typeof options === "function";
                    if (onProgress) {
                        onComplete = onProgress;
                        if (!isCallback) {
                            onProgress = null;
                        }
                    } else if (onProgress === undefined && isCallback) {
                        onComplete = options;
                        options = null;
                        onProgress = null;
                    }
                    if (onProgress !== undefined && isCallback) {
                        onProgress = options;
                        options = null;
                    }
                }
                options = options || Object.create(null);
                return {
                    options: options,
                    onProgress: onProgress,
                    onComplete: onComplete
                };
            };
            proto.$AssetManager0_loadAny = proto.loadAny;
            proto.loadAny = function(requests, options, onProgress, onComplete) {
                this.$AssetManager0_removeFromRelease(requests, options);
                var {options: options, onProgress: onProgress, onComplete: onComplete} = parseParameters(options, onProgress, onComplete);
                options.preset = options.preset || "default";
                let task = new Task({
                    input: requests,
                    onProgress: onProgress,
                    onComplete: onComplete,
                    options: options
                });
                this.pipeline.async(task);
            };
            proto.$AssetManager0_preloadAny = proto.preloadAny;
            proto.preloadAny = function(requests, options, onProgress, onComplete) {
                this.$AssetManager0_removeFromRelease(requests, options);
                this.$AssetManager0_preloadAny(requests, options, onProgress, onComplete);
            };
            proto.releaseUuid = function(uuid) {
                manager.add(uuid);
            };
            proto.removeFromRelease = function(assets) {
                if (assets instanceof Array) {
                    for (let i = 0, n = assets.length; i < n; i++) {
                        manager.remove(assets[i]._uuid);
                    }
                    return;
                }
                if (assets instanceof cc.Asset) {
                    manager.remove(assets._uuid);
                    return;
                }
            };
        }
        cc._RF.pop();
    }, {
        "../gdk": 205,
        "../managers/gdk_PanelManager": 218,
        "../managers/gdk_ResourceManager": 221
    } ],
    181: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "5de74KCS0RBvYjoUFeXBrJp", "CCLabel");
        const Label = cc.Label;
        const proto = Label.prototype;
        Object.defineProperty(proto, "string", {
            get() {
                let str = this._string;
                if (str && str.startsWith("i18n:")) {
                    const i18n = require("../Tools/gdk_i18n");
                    let v = i18n.t(str);
                    if (v) {
                        str = v;
                    }
                }
                return str;
            }
        });
        if (CC_EDITOR) {} else {
            proto._$Label0_onLoad = proto.onLoad;
            proto.onLoad = function() {
                this._$Label0_onLoad();
                let str = this._string;
                if (str && str.startsWith("i18n:")) {
                    const i18n = require("../Tools/gdk_i18n");
                    let v = i18n.t(str);
                    if (v) {
                        this._string = v;
                    }
                }
            };
            proto._$Label0_onEnable = proto.onEnable;
            proto.onEnable = function() {
                if (!this.font && !this._isSystemFontUsed) {
                    this.useSystemFont = true;
                }
                if (this.useSystemFont) {
                    if (!this.fontFamily || this.fontFamily === "Arial") {
                        this.fontFamily = require("../gdk").fontFamily;
                    }
                }
                this._$Label0_onEnable();
            };
            proto._$Label0_onBMFontTextureLoaded = proto._onBMFontTextureLoaded;
            proto._onBMFontTextureLoaded = function() {
                let font = this.font;
                if (font instanceof cc.BitmapFont && font.spriteFrame.textureLoaded()) {
                    this._$Label0_onBMFontTextureLoaded();
                }
            };
            proto._$Label0_updateMaterialWebgl = proto._updateMaterialWebgl;
            proto._updateMaterialWebgl = function() {
                let material = this.getMaterial(0);
                if (this._nativeTTF()) {
                    if (material) this._assembler._updateTTFMaterial(this);
                    return;
                }
                if (!this._frame) return;
                material && material.setProperty("texture", this._frame.getTexture ? this._frame.getTexture() : this._frame._texture);
                cc.BlendFunc.prototype._updateMaterial.call(this);
            };
        }
        cc._RF.pop();
    }, {
        "../Tools/gdk_i18n": 142,
        "../gdk": 205
    } ],
    182: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "346c3/Z5stMIYLHQDlyPUCc", "CCMaterial");
        if (CC_EDITOR) {} else {
            var Material = cc.Material;
            var proto = Material.prototype;
            proto.setProperty = function(name, val, passIdx, directly) {
                if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) return;
                if (typeof passIdx === "string") {
                    passIdx = parseInt(passIdx);
                }
                if (val instanceof cc.Texture2D) {
                    let isAlphaAtlas = val.isAlphaAtlas();
                    let key = "CC_USE_ALPHA_ATLAS_" + name;
                    let def = this.getDefine(key, passIdx);
                    if (isAlphaAtlas || def) {
                        this.define(key, isAlphaAtlas);
                    }
                    let oldval = this._$N_val;
                    if (oldval) {
                        if (oldval.texture === val) {
                            return;
                        }
                        if (cc.isValid(oldval.texture)) {
                            oldval.texture.off("load", oldval.loaded, this);
                        }
                        delete this._$N_val;
                    }
                    if (!val.loaded) {
                        this._$N_val = {
                            texture: val,
                            loaded: () => {
                                delete this._$N_val;
                                if (this._effect) {
                                    this._effect.setProperty(name, val, passIdx, directly);
                                }
                            }
                        };
                        val.once("load", this._$N_val.loaded, this);
                        cc.assetManager.postLoadNative(val);
                        return;
                    }
                }
                this._effect.setProperty(name, val, passIdx, directly);
            };
        }
        cc._RF.pop();
    }, {} ],
    183: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "3aef5nIGiFFjJKQGToGXPUp", "CCNode");
        let NodeTool = require("../Tools/gdk_NodeTool");
        let Node = cc.Node;
        let proto = Node.prototype;
        proto.getPos = proto.getPosition;
        proto.show = function(isEffect = true, callback = null, thisArg = null) {
            NodeTool.show(this, isEffect, callback, thisArg);
        };
        proto.hide = function(isEffect = true, callback = null, thisArg = null) {
            NodeTool.hide(this, isEffect, callback, thisArg);
        };
        Object.defineProperty(proto, "isShow", {
            get: function() {
                return NodeTool.isShow(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, "onStartShow", {
            get: function() {
                return NodeTool.onStartShow(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, "onShow", {
            get: function() {
                return NodeTool.onShow(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, "onStartHide", {
            get: function() {
                return NodeTool.onStartHide(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, "onHide", {
            get: function() {
                return NodeTool.onHide(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(proto, "visible", {
            get: function() {
                return this._$N_visible !== false;
            },
            set: function(v) {
                if (v === false) {
                    this._$N_visible = false;
                }
                delete this._$N_visible;
            },
            enumerable: true,
            configurable: true
        });
        var _currNode = null;
        var _pausedNode = false;
        var _touchEvents = [ "touchstart", "touchmove" ];
        function validTouchNode() {
            if (!_pausedNode && cc.isValid(_currNode) && _currNode.activeInHierarchy) {
                for (let i = 0, n = _touchEvents.length; i < n; i++) {
                    if (_currNode.hasEventListener(_touchEvents[i])) {
                        return true;
                    }
                }
            }
            return false;
        }
        var _dispatchEvent = proto.dispatchEvent;
        proto.dispatchEvent = function(event) {
            if (require("../gdk").macro.ENABLE_MULTI_TOUCH) {
                _dispatchEvent.call(this, event);
                return;
            }
            switch (event.type) {
              case "touchstart":
              case "touchmove":
                if (!validTouchNode()) {
                    _currNode = this;
                    _pausedNode = false;
                } else if (_currNode !== this) {
                    return;
                }
                break;

              case "touchend":
              case "touchcancel":
                if (_currNode !== this) {
                    _currNode = null;
                    _pausedNode = false;
                    return;
                }
                _currNode = null;
                _pausedNode = false;
                break;
            }
            _dispatchEvent.call(this, event);
        };
        var _onPostActivated = proto._onPostActivated;
        proto._onPostActivated = function(active) {
            if (_currNode === this) {
                _currNode = null;
                _pausedNode = false;
            }
            _onPostActivated.call(this, active);
        };
        var _onPreDestroy = proto._onPreDestroy;
        proto._onPreDestroy = function() {
            if (_currNode === this) {
                _currNode = null;
                _pausedNode = false;
            }
            _onPreDestroy.call(this);
        };
        var _pauseSystemEvents = proto.pauseSystemEvents;
        proto.pauseSystemEvents = function(recursive) {
            if (recursive && _currNode) {
                let temp = _currNode;
                while (temp) {
                    if (temp === this) {
                        _pausedNode = true;
                        break;
                    }
                    temp = temp.parent;
                }
            } else if (_currNode === this) {
                _pausedNode = true;
            }
            _pauseSystemEvents.call(this, recursive);
        };
        var _resumeSystemEvents = proto.resumeSystemEvents;
        proto.resumeSystemEvents = function(recursive) {
            if (recursive && _currNode) {
                let temp = _currNode;
                while (temp) {
                    if (temp === this) {
                        _pausedNode = false;
                        break;
                    }
                    temp = temp.parent;
                }
            } else if (_currNode === this) {
                _pausedNode = false;
            }
            _resumeSystemEvents.call(this, recursive);
        };
        proto.once = function(type, callback, target, useCapture) {
            let forDispatch = this._checknSetupSysEvent(type);
            let listeners = null;
            if (forDispatch && useCapture) {
                listeners = this._capturingListeners = this._capturingListeners || new cc.EventTarget();
            } else {
                listeners = this._bubblingListeners = this._bubblingListeners || new cc.EventTarget();
            }
            listeners.once(type, callback, target);
        };
        cc._RF.pop();
    }, {
        "../Tools/gdk_NodeTool": 140,
        "../gdk": 205
    } ],
    184: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "51bbd/VcK1FH47fhKPS/rcx", "CCRichText");
        if (CC_EDITOR) {} else {
            const RichText = cc.RichText;
            const proto = RichText.prototype;
            proto._$RichText0_onEnable = proto.onEnable;
            proto.onEnable = function() {
                let str = this._string;
                if (str && str.startsWith("i18n:")) {
                    const i18n = require("../Tools/gdk_i18n");
                    let v = i18n.t(str);
                    if (v) {
                        this._string = v;
                    }
                }
                this._$RichText0_onEnable();
            };
        }
        cc._RF.pop();
    }, {
        "../Tools/gdk_i18n": 142
    } ],
    185: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "62b47OctKpJOJYCt4R/mn61", "CCSprite");
        if (CC_EDITOR) {} else {
            var Sprite = cc.Sprite;
            var proto = Sprite.prototype;
            proto.$Sprite0_onEnable = proto.onEnable;
            proto.onEnable = function() {
                if (this._spriteFrame && !cc.isValid(this._spriteFrame)) {
                    this._spriteFrame = null;
                }
                this.$Sprite0_onEnable();
            };
            proto.$Sprite0_updateMaterial = proto._updateMaterial;
            proto._updateMaterial = function() {
                let spriteFrame = this._spriteFrame;
                if (spriteFrame && cc.isValid(spriteFrame) && !spriteFrame.textureLoaded()) {
                    spriteFrame.onTextureLoaded(this._textureLoadedCallback, this);
                    return;
                }
                this.$Sprite0_updateMaterial();
            };
            proto._textureLoadedCallback = function() {
                let spriteFrame = this._spriteFrame;
                if (!this.isValid || !spriteFrame) return;
                if (!cc.isValid(spriteFrame) && !spriteFrame.textureLoaded()) return;
                this.$Sprite0_updateMaterial();
                this._applySpriteSize();
            };
            proto._applySpriteFrame = function(oldFrame) {
                if (oldFrame && cc.isValid(oldFrame)) {
                    oldFrame.off("load", this._textureLoadedCallback, this);
                }
                let spriteFrame = this._spriteFrame;
                if (spriteFrame && cc.isValid(spriteFrame)) {
                    if (spriteFrame.textureLoaded()) {
                        this._textureLoadedCallback();
                    } else {
                        this.disableRender();
                        spriteFrame.onTextureLoaded(this._textureLoadedCallback, this);
                    }
                } else {
                    this._spriteFrame = null;
                    this.disableRender();
                }
            };
        }
        cc._RF.pop();
    }, {} ],
    186: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "7fa2aTFdYtF+6zV+KoMGWfg", "CCSpriteFrame");
        if (CC_EDITOR) {} else {
            var dynamicAtlasManager = cc.dynamicAtlasManager;
            var SpriteFrame = cc.SpriteFrame;
            var __proto = SpriteFrame.prototype;
            __proto.getTexture = function() {
                if (!this._original && this._texture && this._texture.loaded) {
                    if (this._texture.isInAtals) {
                        let frame = dynamicAtlasManager.insertSpriteFrame(this);
                        let w = frame.width, h = frame.height;
                        if (!this._rect) {
                            this._rect = cc.rect(0, 0, w, h);
                        }
                        if (!this._originalSize) {
                            this.setOriginalSize(cc.size(w, h));
                        }
                        if (!this._offset) {
                            this.setOffset(cc.v2(0, 0));
                        }
                        this._setDynamicAtlasFrame(frame);
                    } else if (this._texture.packable) {
                        let frame = dynamicAtlasManager.insertSpriteFrame(this);
                        if (frame) {
                            this._setDynamicAtlasFrame(frame);
                        }
                    }
                }
                return this._texture;
            };
            __proto.textureLoaded = function() {
                if (!this._texture || !this._texture.loaded) {
                    return false;
                }
                if (!this._original && this._texture.isInAtals) {
                    return !!this.getTexture();
                }
                return true;
            };
            __proto.$SpriteFrame0_textureLoadedCallback = __proto._textureLoadedCallback;
            __proto._textureLoadedCallback = function() {
                let texture = this._texture;
                if (!texture) {
                    return;
                }
                if (texture.isInAtals) {
                    this.getTexture();
                    this.emit("load");
                    return;
                }
                if (!this._original && texture.packable) {
                    let w = texture.width, h = texture.height;
                    if (this._rect) {
                        this._checkRect(texture);
                    } else {
                        this._rect = cc.rect(0, 0, w, h);
                    }
                    if (!this._originalSize) {
                        this.setOriginalSize(cc.size(w, h));
                    }
                    if (!this._offset) {
                        this.setOffset(cc.v2(0, 0));
                    }
                    this._calculateUV();
                    let frame = dynamicAtlasManager.insertSpriteFrame(this);
                    if (frame) {
                        this._setDynamicAtlasFrame(frame);
                    }
                    this.emit("load");
                    return;
                }
                this.$SpriteFrame0_textureLoadedCallback();
            };
            __proto.$SpriteFrame0_setDynamicAtlasFrame = __proto._setDynamicAtlasFrame;
            __proto._setDynamicAtlasFrame = function(frame) {
                if (!frame) return;
                this.$SpriteFrame0_setDynamicAtlasFrame(frame);
                let texture2d = this._original._texture;
                if (texture2d) {
                    texture2d.isInAtals = true;
                    if (texture2d.nativeUrl) {
                        texture2d._texture && texture2d._texture.destroy();
                        texture2d._image && texture2d._clearImage(false);
                        texture2d._texture = null;
                        texture2d._image = null;
                    } else if (texture2d._image) {
                        texture2d._texture && texture2d._texture.destroy();
                        texture2d._texture = null;
                    }
                }
            };
            __proto._resetDynamicAtlasFrame = function(fromAtlas = false) {
                if (!this._original) return;
                if (!fromAtlas) {
                    dynamicAtlasManager.deleteAtlasSpriteFrame(this);
                } else {
                    this._rect.x = this._original._x;
                    this._rect.y = this._original._y;
                    this._texture = this._original._texture;
                    this._original = null;
                    if (this._texture.nativeUrl && !this._texture._texture && !this._texture._image) {
                        this._texture.loaded = false;
                        this._texture.isInAtals = null;
                        this._textureFilename = this._texture.nativeUrl;
                    } else if (this._texture._image) {
                        this._texture.loaded = true;
                        this._texture.isInAtals = null;
                        this._texture.initWithElement(this._texture._image);
                        this._calculateUV();
                    }
                }
            };
            __proto.$SpriteFrame0_destroy = __proto.destroy;
            __proto.destroy = function() {
                this._original && dynamicAtlasManager.deleteAtlasSpriteFrame(this);
                this.$SpriteFrame0_destroy && this.$SpriteFrame0_destroy();
            };
        }
        cc._RF.pop();
    }, {} ],
    187: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "64fa6CCZltHuaazlVZFVCTQ", "CCTexture2D");
        if (CC_EDITOR) {} else {
            var Texture2D = cc.Texture2D;
            var __proto = Texture2D.prototype;
            __proto.$Texture2D0_initWithElement = __proto.initWithElement;
            __proto.initWithElement = function(element) {
                if (!element) {
                    return;
                }
                if (!cc.isValid(this)) {
                    this._image = element;
                    this._clearImage(false);
                    return;
                }
                if (element.isInAtals) {
                    this.isInAtals = true;
                    this.width = element.width;
                    this.height = element.height;
                    this._packable = true;
                    this.loaded = true;
                    this.emit("load");
                    return;
                }
                this.$Texture2D0_initWithElement(element);
            };
            __proto.$Texture2D0_handleLoadedTexture = __proto.handleLoadedTexture;
            __proto.handleLoadedTexture = function() {
                if (!this._image || !this._image.width || !this._image.height) {
                    if (this.loaded && this.isInAtals) {
                        this._clearImage(false);
                        this.emit("load");
                    }
                    return;
                }
                if (!cc.isValid(this)) {
                    this._clearImage(false);
                    return;
                }
                this.$Texture2D0_handleLoadedTexture();
                this._clearImage();
            };
            __proto.$Texture2D0_clearImage = __proto._clearImage;
            __proto._clearImage = function(check = true) {
                if (check && this._packable) {
                    return;
                }
                if (this._image instanceof HTMLImageElement) {
                    this._image.src = "";
                } else if (cc.sys.capabilities.imageBitmap && this._image instanceof ImageBitmap) {
                    this._image.close && this._image.close();
                }
            };
            __proto.$Texture2D0_destroy = __proto.destroy;
            __proto.destroy = function() {
                this.isInAtals = null;
                this.$Texture2D0_destroy();
            };
            __proto.$Texture2D0_deserialize = __proto._deserialize;
            __proto._deserialize = function(data) {
                this.$Texture2D0_deserialize(data);
                this._$deserialize_ackable = this._packable;
            };
            __proto.$Texture2D0_checkPackable = __proto._checkPackable;
            __proto._checkPackable = function() {
                this.$Texture2D0_checkPackable();
                if (this._packable && this._packable != this._$deserialize_ackable) {
                    this._packable = false;
                }
            };
        }
        cc._RF.pop();
    }, {} ],
    188: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "fae3a8bUmZOEpLxfhzvt45+", "Skeleton");
        if (CC_EDITOR) {} else {
            var Skeleton = sp.Skeleton;
            var proto = Skeleton.prototype;
            if (CC_JSB) {
                proto._$Skeleton0_setEventListener = proto.setEventListener;
                proto.setEventListener = function(listener) {
                    if (this.isAnimationCached()) {
                        this.setAnimationCacheMode(0);
                    }
                    this._$Skeleton0_setEventListener(listener);
                };
                proto._$Skeleton0_setAnimation = proto.setAnimation;
                proto.setAnimation = function(trackIndex, name, loop) {
                    let skeletonData = this.skeletonData;
                    if (skeletonData && !cc.isValid(skeletonData)) {
                        this.skeletonData = null;
                        return;
                    }
                    if (!this.isAnimationCached()) {
                        let animation = this.animation;
                        if (!name || !animation) {
                            this.clearTrack(trackIndex);
                        }
                    }
                    return this._$Skeleton0_setAnimation(trackIndex, name, loop);
                };
            } else {
                proto._$Skeleton0_setAnimation = proto.setAnimation;
                proto.setAnimation = function(trackIndex, name, loop) {
                    this._$N_cacheEvents = null;
                    let skeletonData = this.skeletonData;
                    if (skeletonData && !cc.isValid(skeletonData)) {
                        this.skeletonData = null;
                        return;
                    }
                    return this._$Skeleton0_setAnimation(trackIndex, name, loop);
                };
                proto._$Skeleton0_updateCache = proto._updateCache;
                proto._updateCache = function(dt) {
                    if (this._frameCache == null) return;
                    if (dt <= 0) return;
                    let accTime = this._accTime;
                    if (accTime == 0) {
                        let name = this._animationName;
                        let sd = this.skeletonData;
                        this._$N_cacheEvents = null;
                        if (sd && sd._skeletonJson && sd._skeletonJson.animations && sd._skeletonJson.animations[name]) {
                            let events = sd._skeletonJson.animations[name].events;
                            if (events && events.length) {
                                this._$N_cacheEvents = events.slice();
                            }
                        }
                    }
                    if (this._$N_cacheEvents) {
                        accTime += dt;
                        while (this._$N_cacheEvents && this._$N_cacheEvents.length) {
                            let event = this._$N_cacheEvents[0];
                            if (accTime < event.time) {
                                break;
                            }
                            this._$N_cacheEvents.shift();
                            if (this._listener && this._listener.event) {
                                this._listener.event(null, {
                                    data: event
                                });
                            }
                        }
                        if (this._$N_cacheEvents && this._$N_cacheEvents.length == 0) {
                            this._$N_cacheEvents = null;
                        }
                    }
                    this._$Skeleton0_updateCache(dt);
                };
                proto._$Skeleton0_validateRender = proto._validateRender;
                proto._validateRender = function() {
                    let skeletonData = this.skeletonData;
                    if (skeletonData && !cc.isValid(skeletonData)) {
                        this.skeletonData = null;
                        return;
                    }
                    this._$Skeleton0_validateRender();
                };
            }
            proto._emitCacheCompleteEvent = function() {
                if (!this._listener) return;
                this._endEntry.animation.name = this._animationName;
                this._listener && this._listener.complete && this._listener.complete(this._endEntry);
                this._listener && this._listener.end && this._listener.end(this._endEntry);
            };
        }
        cc._RF.pop();
    }, {} ],
    189: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "d806bD3TVlF8brT0KMbJ59R", "assembler-2d");
        if (CC_EDITOR) {} else {
            const dynamicAtlasManager = cc.dynamicAtlasManager;
            var Assembler2D = cc.Assembler2D;
            var proto = Assembler2D.prototype;
            proto.packToDynamicAtlas = function(comp, frame) {
                if (CC_TEST) return;
                let material = comp._materials[0];
                if (!material) return;
                if (!frame) return;
                if (!frame._texture) return;
                if (!frame._original && frame._texture.packable && dynamicAtlasManager) {
                    let packedFrame = dynamicAtlasManager.insertSpriteFrame(frame);
                    if (packedFrame) {
                        frame._setDynamicAtlasFrame(packedFrame);
                    }
                }
                if (material.getProperty("texture") !== frame._texture._texture) {
                    comp._vertsDirty = true;
                    comp._updateMaterial();
                }
            };
        }
        cc._RF.pop();
    }, {} ],
    190: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "c8d73UjllNPZ6bXpJilBaPJ", "atlas");
        function MaxRectsBinPack(width, height) {
            this.binWidth = width;
            this.binHeight = height;
            this.usedRectangles = [];
            this.freeRectangles = [ cc.rect(0, 0, width, height) ];
        }
        var proto = MaxRectsBinPack.prototype;
        proto.insert = function(width, height) {
            let node = this._findNode(width, height);
            if (node) {
                let freeRectangles = this.freeRectangles;
                let numRectanglesToProcess = freeRectangles.length;
                for (let i = 0; i < numRectanglesToProcess; i++) {
                    if (this._splitFreeNode(freeRectangles[i], node)) {
                        freeRectangles.splice(i, 1);
                        i--;
                        numRectanglesToProcess--;
                    }
                }
                this._pruneFreeList();
                this.usedRectangles.push(node);
            }
            return node;
        };
        proto._findNode = function(width, height) {
            let bestNode;
            let bestY = Number.MAX_VALUE;
            let bestX = Number.MAX_VALUE;
            let freeRectangles = this.freeRectangles;
            for (let i = 0, n = freeRectangles.length; i < n; ++i) {
                let r = freeRectangles[i];
                if (r.width >= width && r.height >= height) {
                    let topSideY = r.y + height;
                    if (topSideY < bestY || topSideY == bestY && r.x < bestX) {
                        bestNode = r;
                        bestX = r.x;
                        bestY = topSideY;
                    }
                }
            }
            if (bestNode) {
                return cc.rect(bestNode.x, bestNode.y, width, height);
            }
            return null;
        };
        proto._splitFreeNode = function(freeRect, usedNode) {
            if (!freeRect.intersects(usedNode)) return false;
            if (usedNode.x < freeRect.x + freeRect.width && usedNode.x + usedNode.width > freeRect.x) {
                if (usedNode.y > freeRect.y && usedNode.y < freeRect.y + freeRect.height) {
                    let newNode = cc.rect(freeRect.x, freeRect.y, freeRect.width, usedNode.y - freeRect.y);
                    this.freeRectangles.push(newNode);
                }
                if (usedNode.y + usedNode.height < freeRect.y + freeRect.height) {
                    let newNode = cc.rect(freeRect.x, usedNode.y + usedNode.height, freeRect.width, freeRect.y + freeRect.height - (usedNode.y + usedNode.height));
                    this.freeRectangles.push(newNode);
                }
            }
            if (usedNode.y < freeRect.y + freeRect.height && usedNode.y + usedNode.height > freeRect.y) {
                if (usedNode.x > freeRect.x && usedNode.x < freeRect.x + freeRect.width) {
                    let newNode = cc.rect(freeRect.x, freeRect.y, usedNode.x - freeRect.x, freeRect.height);
                    this.freeRectangles.push(newNode);
                }
                if (usedNode.x + usedNode.width < freeRect.x + freeRect.width) {
                    let newNode = cc.rect(usedNode.x + usedNode.width, freeRect.y, freeRect.x + freeRect.width - (usedNode.x + usedNode.width), freeRect.height);
                    this.freeRectangles.push(newNode);
                }
            }
            return true;
        };
        proto._pruneFreeList = function() {
            let freeRectangles = this.freeRectangles;
            let i = 0;
            let len = freeRectangles.length;
            while (i < len) {
                let j = i + 1;
                let tmpRect1 = freeRectangles[i];
                while (j < len) {
                    let tmpRect2 = freeRectangles[j];
                    if (tmpRect2.containsRect(tmpRect1)) {
                        freeRectangles.splice(i, 1);
                        i--;
                        len--;
                        break;
                    }
                    if (tmpRect1.containsRect(tmpRect2)) {
                        freeRectangles.splice(j, 1);
                        j--;
                        len--;
                    }
                    j++;
                }
                i++;
            }
        };
        var dynamicAtlasManager = cc.dynamicAtlasManager;
        var Atlas = dynamicAtlasManager.Atlas;
        var __proto = Atlas.prototype;
        function getKey(spriteFrame) {
            let key = null;
            if (cc.js.isString(spriteFrame)) {
                key = cc.assetManager.utils.getUuidFromURL(spriteFrame);
            } else {
                key = spriteFrame._texture._uuid;
            }
            return key;
        }
        __proto.insertSpriteFrame = function(spriteFrame) {
            let texture = spriteFrame._texture;
            let key = getKey(spriteFrame);
            if (key && this._infoIdx) {
                this._innerTextureInfos[texture._id] = this._infoIdx[key];
            }
            let frame = null;
            let info = this._innerTextureInfos[texture._id];
            if (!info) {
                if (!this._maxRect) {
                    this._maxRect = new MaxRectsBinPack(this._width, this._height);
                }
                let rect = this._maxRect.insert(texture.width, texture.height);
                if (rect) {
                    this._texture.drawTextureAt(texture, rect.x, rect.y);
                    this._innerTextureInfos[texture._id] = info = {
                        x: rect.x,
                        y: rect.y,
                        width: texture.width,
                        height: texture.height,
                        rect: spriteFrame._rect.clone()
                    };
                    this._count++;
                    this._dirty = true;
                }
            }
            if (info) {
                if (key) {
                    if (!this._infoIdx) this._infoIdx = {};
                    if (!this._infoIdx[key]) {
                        this._infoIdx[key] = info;
                    }
                }
                this._innerSpriteFrames.push(spriteFrame);
                frame = {
                    x: spriteFrame._rect.x + info.x,
                    y: spriteFrame._rect.y + info.y,
                    width: info.width,
                    height: info.height,
                    rect: info.rect,
                    texture: this._texture
                };
            }
            return frame;
        };
        __proto.$Atlas0_deleteInnerTexture = __proto.deleteInnerTexture;
        __proto.deleteInnerTexture = function(texture) {
            if (!texture) return;
            if (!this._infoIdx) return;
            if (!this._innerTextureInfos[texture._id]) return;
            let frames = this._innerSpriteFrames;
            for (let i = frames.length - 1; i >= 0; i--) {
                let frame = frames[i];
                if (!frame._original) {
                    frames.splice(i, 1);
                    this._count--;
                } else if (frame._original._texture === texture) {
                    frames.splice(i, 1);
                    if (cc.isValid(frame, true)) {
                        frame._resetDynamicAtlasFrame(true);
                    }
                    this._count--;
                }
            }
            delete this._innerTextureInfos[texture._id];
        };
        __proto.deleteInnerSpriteFrame = function(spriteFrame) {
            if (!spriteFrame) return;
            if (!spriteFrame._original) return;
            if (!this._infoIdx) return;
            let texture = spriteFrame._original._texture;
            let frames = this._innerSpriteFrames;
            for (let i = frames.length - 1; i >= 0; i--) {
                let frame = frames[i];
                if (frame === spriteFrame) {
                    frames.splice(i, 1);
                    if (cc.isValid(frame, true)) {
                        frame._resetDynamicAtlasFrame(true);
                    }
                    this._count--;
                    break;
                }
            }
            if (!frames.some(frame => frame._original._texture === texture)) {
                delete this._innerTextureInfos[texture._id];
            }
        };
        __proto.hasInfo = function(spriteFrame) {
            let key = getKey(spriteFrame);
            return key && this._infoIdx && !!this._infoIdx[key];
        };
        __proto.getInfo = function(spriteFrame) {
            let key = getKey(spriteFrame);
            if (key && this._infoIdx) {
                return this._infoIdx[key];
            }
            return null;
        };
        __proto.isEmpty = function() {
            return this._innerSpriteFrames.length == 0;
        };
        __proto.info = CC_DEV && function() {
            cc.log("size:", this._innerSpriteFrames.length);
            cc.log("frames:", this._innerSpriteFrames);
            cc.log("inner:", this._innerTextureInfos);
            cc.log("info:", this._infoIdx);
        };
        __proto.$Atlas0_reset = __proto.reset;
        __proto.reset = function() {
            let frames = this._innerSpriteFrames;
            this._count = 0;
            this._infoIdx = null;
            this._innerTextureInfos = {};
            this._innerSpriteFrames = [];
            this._maxRect = null;
            for (let i = 0, l = frames.length; i < l; i++) {
                let frame = frames[i];
                if (cc.isValid(frame, true)) {
                    frame._resetDynamicAtlasFrame(true);
                }
            }
            this.$Atlas0_reset();
        };
        cc._RF.pop();
    }, {} ],
    191: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "df490oao19N8IGZAA9oGNUU", "downloader");
        if (CC_EDITOR) {} else {
            const Buffer = require("buffer").Buffer;
            const amf = require("ham-amf");
            const pako = require("pako");
            const xxtea = require("xxtea-node");
            const dynamicAtlasManager = cc.dynamicAtlasManager;
            const assetManager = cc.assetManager;
            const downloader = assetManager.downloader;
            const parser = assetManager.parser;
            const utils = assetManager.utils;
            const JSON_PREFIX = "AMF3#";
            const JSON_PREFIX_LEN = JSON_PREFIX.length;
            const UTF8_DECODER = window.TextDecoder ? new TextDecoder("utf-8") : null;
            let JSON_KEY = null;
            if (window._TDSettings && window._TDSettings["json-key"]) {
                JSON_KEY = xxtea.toBytes(window._TDSettings["json-key"]);
                delete window._TDSettings["json-key"];
            }
            let JsonCache = {};
            if (window._TDJsons) {
                let val = window._TDJsons;
                if (cc.js.isString(val)) {
                    cc.game.once(cc.game.EVENT_ENGINE_INITED, () => {
                        if (cc.sys.isNative) {
                            let temp = `assets/all_json.txt`;
                            let text = jsb.fileUtils.getStringFromFile(temp);
                            if (text) {
                                let buf = Buffer.from(text, "base64");
                                buf = Buffer.from(pako.inflate(buf));
                                JsonCache = amf.decodeObject(buf);
                            }
                        } else {
                            let url = `all_json.${val}.txt`;
                            if (cc.sys.platform === cc.sys.WECHAT_GAME) {
                                let remote = `${assetManager.downloader._remoteServerAddress}`;
                                if (remote) {
                                    url = `${remote}remote/${url}`;
                                }
                            }
                            assetManager.loadRemote(url, (err, asset) => {
                                if (err || !asset) return;
                                let buf = Buffer.from(asset.text, "base64");
                                buf = Buffer.from(pako.inflate(buf));
                                JsonCache = amf.decodeObject(buf);
                                assetManager.releaseAsset(asset);
                            });
                        }
                    });
                } else if (val && val.v && val.t) {
                    let buf = Buffer.from(val.v, val.t);
                    buf = Buffer.from(pako.inflate(buf));
                    JsonCache = amf.decodeObject(buf);
                }
                window._TDJsons = null;
                delete window._TDJsons;
            }
            function utf8ArrayToStr(array, i, len) {
                i === void 0 && (i = 0);
                len === void 0 && (len = array.length);
                var c;
                var char2, char3;
                var out = "";
                while (i < len) {
                    c = array[i++];
                    switch (c >> 4) {
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                        out += String.fromCharCode(c);
                        break;

                      case 12:
                      case 13:
                        char2 = array[i++];
                        out += String.fromCharCode((c & 31) << 6 | char2 & 63);
                        break;

                      case 14:
                        char2 = array[i++];
                        char3 = array[i++];
                        out += String.fromCharCode((c & 15) << 12 | (char2 & 63) << 6 | (char3 & 63) << 0);
                        break;
                    }
                }
                return out;
            }
            function isAmf(content) {
                return utf8ArrayToStr(content, 0, JSON_PREFIX_LEN) === JSON_PREFIX;
            }
            function uncompress(content) {
                let compress = content[JSON_PREFIX_LEN] != 0;
                content = content.slice(JSON_PREFIX_LEN + 1);
                if (JSON_KEY != null) {
                    content = xxtea.decrypt(content, JSON_KEY);
                }
                content = compress ? pako.inflate(content) : content;
                return Buffer.from(content);
            }
            function parseAmf(content) {
                return amf.decodeObject(content);
            }
            const decode = UTF8_DECODER ? UTF8_DECODER.decode.bind(UTF8_DECODER) : utf8ArrayToStr;
            const IMAG_TYPE = {
                ".png": true,
                ".jpg": true,
                ".png": true,
                ".jpeg": true,
                ".gif": true,
                ".ico": true,
                ".tiff": true,
                ".webp": true,
                ".image": true
            };
            const TEXTURE_TYPE = {
                ".pkm": true,
                ".pvr": true
            };
            const JSON_TYPE = {
                ".json": true,
                ".ExportJson": true
            };
            downloader.$downloader0_download = downloader.download;
            downloader.download = function(id, url, type, options, onComplete) {
                if ((IMAG_TYPE[type] || TEXTURE_TYPE[type]) && dynamicAtlasManager && dynamicAtlasManager.enabled) {
                    let info = dynamicAtlasManager.getInfo(url);
                    if (info) {
                        onComplete && onComplete(null, {
                            isInAtals: true,
                            width: info.width,
                            height: info.height
                        });
                        return;
                    }
                } else if (JSON_TYPE[type] === true) {
                    let uuid = utils.getUuidFromURL(url);
                    let data = JsonCache[uuid];
                    if (data != null) {
                        if (data instanceof Buffer) {
                            data = parseAmf(data);
                        } else if (isAmf(data)) {
                            data = JsonCache[uuid] = uncompress(data);
                            data = parseAmf(data);
                        } else {
                            data = JSON.parse(data);
                            JsonCache[uuid] = amf.encodeObject(data);
                        }
                        if (data) {
                            onComplete && onComplete(null, data);
                            return;
                        }
                        JsonCache[uuid] = null;
                        delete JsonCache[uuid];
                    }
                }
                this.$downloader0_download(id, url, type, options, onComplete);
            };
            if (cc.sys.platform === cc.sys.WECHAT_GAME) {
                cc.game.once(cc.game.EVENT_ENGINE_INITED, () => {
                    var downloadDomImage = downloader.downloadDomImage;
                    wx.__parse__json = function(content) {
                        let data = null;
                        let buff = new Uint8Array(content);
                        if (isAmf(buff)) {
                            data = parseAmf(uncompress(buff));
                        } else {
                            data = JSON.parse(decode(buff));
                        }
                        return data;
                    };
                    function parseImageNew(file, options, onComplete) {
                        if (file && typeof file === "object" && file.isInAtals === true) {
                            onComplete && onComplete(null, file);
                            return;
                        }
                        downloadDomImage(file, options, onComplete);
                    }
                    for (let type in IMAG_TYPE) {
                        parser.register(type, parseImageNew);
                    }
                });
                return;
            }
            if (cc.sys.isNative) {
                return;
            }
            cc.game.once(cc.game.EVENT_ENGINE_INITED, () => {
                const gdk = require("../gdk");
                const WorkerLoader = require("../core/gdk_WorkerLoader");
                const capabilities = cc.sys.capabilities;
                var pngWorker = null;
                var arrayBufferWorker = null;
                var downloadDomImage = downloader.downloadDomImage;
                var downloadFile = downloader.downloadFile;
                var downloadBlob = function(url, options, onComplete) {
                    options.responseType = "blob";
                    downloadFile(url, options, options.onFileProgress, onComplete);
                };
                function downloadArrayBufferNew(url, options, onComplete) {
                    if (arrayBufferWorker && !arrayBufferWorker.excludeFiles[url]) {
                        options.responseType = "arraybuffer";
                        arrayBufferWorker.send(url, options).then(data => {
                            onComplete && onComplete(data.error, data.data);
                        }).catch(err => {
                            arrayBufferWorker.excludeFiles[url] = true;
                            onComplete && onComplete(err, null);
                        });
                        return;
                    }
                    options.responseType = "arraybuffer";
                    downloadFile(url, options, onComplete);
                }
                function downloadJsonNew(url, options, onComplete) {
                    downloadArrayBufferNew(url, options, function(err, content) {
                        let data = null;
                        if (!err) {
                            if (content) {
                                content = new Uint8Array(content);
                                if (isAmf(content)) {
                                    content = uncompress(content);
                                    data = parseAmf(content);
                                } else {
                                    content = decode(content);
                                    data = JSON.parse(content);
                                }
                                if (content.length < 50 * 1024) {
                                    let uuid = utils.getUuidFromURL(url);
                                    JsonCache[uuid] = content;
                                    if (err && JsonCache[uuid]) {
                                        JsonCache[uuid] = null;
                                        delete JsonCache[uuid];
                                    }
                                }
                            } else {
                                err = new Error("download failed: " + url + "(no response)");
                            }
                        }
                        onComplete && onComplete(err, data);
                    });
                }
                function downloadImageNew(url, options, onComplete) {
                    if (pngWorker && !pngWorker.excludeFiles[url]) {
                        pngWorker.send(url, options).then(data => {
                            if (data.error) {
                                onComplete && onComplete(new Error("download failed: " + url + ", status: " + data.error), null);
                                return;
                            }
                            if (data.data) {
                                data.data.flipY = !!options.__flipY__;
                                data.data.premultiplyAlpha = !!options.__premultiplyAlpha__;
                            }
                            onComplete && onComplete(null, data.data);
                        }).catch(err => {
                            pngWorker.excludeFiles[url] = true;
                            onComplete && onComplete(err, null);
                        });
                        return;
                    }
                    var b = capabilities.imageBitmap && cc.macro.ALLOW_IMAGE_BITMAP;
                    b = b && (!parser.NoImageBitmapFiles || !parser.NoImageBitmapFiles[url]);
                    let func = b ? downloadBlob : downloadDomImage;
                    func.apply(this, arguments);
                }
                Object.defineProperty(gdk.macro, "ENABLE_ARRAYBUFFER_WORKER", {
                    get() {
                        return gdk.macro._N$_ENABLE_ARRAYBUFFER_WORKER || false;
                    },
                    set(v) {
                        if (v) {
                            if (arrayBufferWorker == null && typeof Worker !== "undefined") {
                                const formatFn = `const formatFn = (url, options, onComplete) => {\n                            let xhr = new XMLHttpRequest();\n                            xhr.open("GET", url, true);\n                            xhr.responseType = options.responseType;\n\n                            if (options.withCredentials !== undefined) xhr.withCredentials = options.withCredentials;\n                            if (options.mimeType !== undefined && xhr.overrideMimeType ) xhr.overrideMimeType(options.mimeType);\n                            if (options.timeout !== undefined) xhr.timeout = options.timeout;\n                            if (options.header) {\n                                for (let header in options.header) {\n                                    xhr.setRequestHeader(header, options.header[header]);\n                                }\n                            }\n                            \n                            xhr.onload = function () {\n                                if ( xhr.status === 200 || xhr.status === 0 ) {\n                                    // 转换为二进制数据\n                                    onComplete(null, xhr.response);\n                                } else {\n                                    // 网络错误\n                                    onComplete(xhr.status + '(no response)', null);\n                                }\n                            };\n                            xhr.ontimeout = function () {\n                                // 加载超时\n                                onComplete(xhr.status + '(time out)', null);\n                            };\n                            xhr.onerror = function () {\n                                // 加载失败\n                                onComplete(xhr.status + '(error)', null);\n                            };\n                            xhr.send(null);\n                            return xhr;\n                        };`;
                                arrayBufferWorker = new WorkerLoader("", formatFn);
                            }
                        } else if (arrayBufferWorker) {
                            arrayBufferWorker.close();
                            arrayBufferWorker = null;
                        }
                        gdk.macro._N$_ENABLE_ARRAYBUFFER_WORKER = v;
                    },
                    enumerable: true,
                    configurable: false
                });
                Object.defineProperty(gdk.macro, "ENABLE_PNG_WORKER", {
                    get() {
                        return gdk.macro._N$_ENABLE_PNG_WORKER || false;
                    },
                    set(v) {
                        if (v) {
                            if (pngWorker == null && capabilities.imageBitmap && cc.macro.ALLOW_IMAGE_BITMAP && typeof Worker !== "undefined") {
                                const formatFn = `const formatFn = (url, options, onComplete) => {\n                            let xhr = new XMLHttpRequest();\n                            xhr.open("GET", url, true);\n                            xhr.responseType = "blob";\n\n                            if (options.withCredentials !== undefined) xhr.withCredentials = options.withCredentials;\n                            if (options.mimeType !== undefined && xhr.overrideMimeType ) xhr.overrideMimeType(options.mimeType);\n                            if (options.timeout !== undefined) xhr.timeout = options.timeout;\n                            if (options.header) {\n                                for (let header in options.header) {\n                                    xhr.setRequestHeader(header, options.header[header]);\n                                }\n                            }\n                            \n                            xhr.onload = function () {\n                                if ( xhr.status === 200 || xhr.status === 0 ) {\n                                    // 转换图片\n                                    try {\n                                        let blob = xhr.response;\n                                        let imageOptions = {};\n                                        imageOptions.imageOrientation = options.__flipY__ ? 'flipY' : 'none';\n                                        imageOptions.premultiplyAlpha = options.__premultiplyAlpha__ ? 'premultiply' : 'none';\n                                        self.createImageBitmap(blob, imageOptions)\n                                            .then(result => {\n                                                // 解码成功\n                                                onComplete(null, result);\n                                                blob.close && blob.close();\n                                            })\n                                            .catch(err => {\n                                                // 解码错误\n                                                onComplete(xhr.status + '(' + err + ')', null);\n                                            });\n                                    } catch(e) {\n                                        // 解码异常\n                                        onComplete(xhr.status + '(' + e + ')', null);\n                                    }\n                                } else {\n                                    // 网络错误\n                                    onComplete(xhr.status + '(no response)', null);\n                                }\n                            };\n                            xhr.ontimeout = function () {\n                                // 加载超时\n                                onComplete(xhr.status + '(time out)', null);\n                            };\n                            xhr.onerror = function () {\n                                // 加载失败\n                                onComplete(xhr.status + '(error)', null);\n                            };\n                            xhr.send(null);\n                            return xhr;\n                        };`;
                                pngWorker = new WorkerLoader("", formatFn);
                            }
                        } else if (pngWorker) {
                            pngWorker.close();
                            pngWorker = null;
                        }
                        gdk.macro._N$_ENABLE_PNG_WORKER = v;
                    },
                    enumerable: true,
                    configurable: false
                });
                for (let type in JSON_TYPE) {
                    downloader.register(type, downloadJsonNew);
                }
                for (let type in IMAG_TYPE) {
                    downloader.register(type, downloadImageNew);
                }
                downloader.register(".pkm", downloadArrayBufferNew);
                downloader.register(".pvr", downloadArrayBufferNew);
                let audioSupport = cc.sys.__audioSupport;
                if (audioSupport && audioSupport.WEB_AUDIO && audioSupport.format && audioSupport.format.length > 0) {
                    let downloadDomAudio = downloader.downloadDomAudio;
                    let downloadAudioNew = function(url, options, onComplete) {
                        if (options.audioLoadMode !== cc.AudioClip.LoadMode.DOM_AUDIO) {
                            downloadArrayBufferNew(url, options, onComplete);
                        } else {
                            downloadDomAudio(url, options, onComplete);
                        }
                    };
                    downloader.register(".mp3", downloadAudioNew);
                    downloader.register(".ogg", downloadAudioNew);
                    downloader.register(".wav", downloadAudioNew);
                    downloader.register(".m4a", downloadAudioNew);
                }
            });
        }
        cc._RF.pop();
    }, {
        "../core/gdk_WorkerLoader": 179,
        "../gdk": 205,
        buffer: 44,
        "ham-amf": 49,
        pako: 117,
        "xxtea-node": 137
    } ],
    192: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "7f713FQaspBXLuM2T6itBhR", "index");
        cc.game.once(cc.game.EVENT_ENGINE_INITED, () => {
            require("./CCLabel");
            require("./CCRichText");
            require("./CCAssetManager");
            require("./CCNode");
            const dynamicAtlasManager = cc.dynamicAtlasManager;
            if (dynamicAtlasManager && dynamicAtlasManager.enabled) {
                require("./CCSprite");
                require("./CCSpriteFrame");
                require("./CCTexture2D");
                require("./CCMaterial");
                require("./atlas");
                require("./manager");
                require("./assembler-2d");
            }
            require("./vec2");
            require("./Skeleton");
            require("./render-flow");
        });
        require("./downloader");
        cc._RF.pop();
    }, {
        "./CCAssetManager": 180,
        "./CCLabel": 181,
        "./CCMaterial": 182,
        "./CCNode": 183,
        "./CCRichText": 184,
        "./CCSprite": 185,
        "./CCSpriteFrame": 186,
        "./CCTexture2D": 187,
        "./Skeleton": 188,
        "./assembler-2d": 189,
        "./atlas": 190,
        "./downloader": 191,
        "./manager": 193,
        "./render-flow": 194,
        "./vec2": 195
    } ],
    193: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "1c9d9q/wjVElr0ms20h2qVG", "manager");
        const Atlas = cc.dynamicAtlasManager.Atlas;
        let _atlases = [];
        let _atlasIndex = -1;
        let _debugNode = null;
        function newAtlas() {
            let atlas = _atlases[++_atlasIndex];
            if (!atlas) {
                let size = cc.dynamicAtlasManager.textureSize;
                atlas = new Atlas(size, size);
                _atlases.push(atlas);
            }
            return atlas;
        }
        let dynamicAtlasManager = {
            hasInfo(url) {
                for (let i = _atlases.length - 1; i >= 0; i--) {
                    let atlas = _atlases[i];
                    if (atlas && atlas.hasInfo(url)) {
                        return true;
                    }
                }
                return false;
            },
            getInfo(url) {
                for (let i = _atlases.length - 1; i >= 0; i--) {
                    let atlas = _atlases[i];
                    if (atlas) {
                        let info = atlas.getInfo(url);
                        if (info) {
                            return info;
                        }
                    }
                }
                return null;
            },
            insertSpriteFrame(spriteFrame) {
                if (CC_EDITOR) return null;
                if (!this.enabled) return null;
                if (!spriteFrame || !spriteFrame._texture || spriteFrame._original) return null;
                if (!spriteFrame._texture.packable) return null;
                for (let i = _atlases.length - 1; i >= 0; i--) {
                    if (_atlases[i].hasInfo(spriteFrame)) {
                        let atlas = _atlases[i];
                        return atlas.insertSpriteFrame(spriteFrame);
                    }
                }
                for (let i = _atlases.length - 1; i >= 0; i--) {
                    let atlas = _atlases[i];
                    let frame = atlas.insertSpriteFrame(spriteFrame);
                    if (frame) {
                        return frame;
                    }
                }
                if (_atlasIndex < this.maxAtlasCount) {
                    let atlas = newAtlas();
                    return atlas.insertSpriteFrame(spriteFrame);
                }
                return null;
            },
            reset() {
                let arr = _atlases;
                _atlasIndex = -1;
                _atlases = [];
                for (let i = 0, l = arr.length; i < l; i++) {
                    arr[i].destroy();
                }
            },
            deleteAtlasSpriteFrame(spriteFrame) {
                if (!spriteFrame._original) return;
                for (let i = _atlases.length - 1; i >= 0; i--) {
                    _atlases[i].deleteInnerSpriteFrame(spriteFrame);
                    if (_atlases[i].isEmpty()) {
                        _atlases[i].destroy();
                        _atlases.splice(i, 1);
                        _atlasIndex--;
                    }
                }
            },
            deleteAtlasTexture(texture) {
                if (!texture) return;
                for (let i = _atlases.length - 1; i >= 0; i--) {
                    _atlases[i].deleteInnerTexture(texture);
                    if (_atlases[i].isEmpty()) {
                        _atlases[i].destroy();
                        _atlases.splice(i, 1);
                        _atlasIndex--;
                    }
                }
            },
            showDebug: CC_DEBUG && function(show) {
                if (show) {
                    if (!_debugNode || !_debugNode.isValid) {
                        let width = cc.visibleRect.width;
                        let height = cc.visibleRect.height;
                        _debugNode = new cc.Node("DYNAMIC_ATLAS_DEBUG_NODE");
                        _debugNode.zIndex = cc.macro.MAX_ZINDEX;
                        _debugNode.setPosition(0, 0);
                        _debugNode.setContentSize(width, height);
                        let scrollNode = new cc.Node("SCROLLVIEW");
                        scrollNode.anchorX = 0;
                        scrollNode.anchorY = 1;
                        scrollNode.setPosition(-width / 2, height / 2);
                        scrollNode.setContentSize(width, height);
                        scrollNode.parent = _debugNode;
                        let content = new cc.Node("CONTENT");
                        let layout = content.addComponent(cc.Layout);
                        layout.type = cc.Layout.Type.VERTICAL;
                        layout.resizeMode = cc.Layout.ResizeMode.CONTAINER;
                        layout.spacingY = 5;
                        content.anchorX = 0;
                        content.anchorY = 1;
                        content.setPosition(0, 0);
                        content.setContentSize(this.textureSize, 100);
                        content.parent = scrollNode;
                        let scroll = scrollNode.addComponent(cc.ScrollView);
                        scroll.content = content;
                        for (let i = 0; i <= _atlasIndex; i++) {
                            let node = new cc.Node("ATLAS");
                            node.anchorX = 0;
                            node.anchorY = 1;
                            node.parent = content;
                            let spriteFrame = new cc.SpriteFrame();
                            spriteFrame.setTexture(_atlases[i]._texture);
                            let sprite = node.addComponent(cc.Sprite);
                            sprite.spriteFrame = spriteFrame;
                        }
                        gdk.gui.addPopup(_debugNode, true, null, pop => {
                            pop.isTouchMaskClose = true;
                        });
                    }
                } else {
                    if (_debugNode) {
                        _debugNode.parent = null;
                        _debugNode = null;
                    }
                }
            },
            update() {
                if (!this.enabled) return;
                for (let i = 0; i <= _atlasIndex; i++) {
                    _atlases[i].update();
                }
            },
            size: function() {
                return _atlases.length;
            },
            info: CC_DEBUG && function() {
                cc.log("atlas size:", _atlases.length);
                for (let i = _atlases.length - 1; i >= 0; i--) {
                    _atlases[i].info();
                }
            }
        };
        for (let key in dynamicAtlasManager) {
            cc.dynamicAtlasManager[key] = dynamicAtlasManager[key];
        }
        cc._RF.pop();
    }, {} ],
    194: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "37c2bxWOLFAU5aJMx44VSY+", "render-flow");
        if (CC_EDITOR) {} else {
            let RenderFlow = cc.RenderFlow;
            let flows = RenderFlow.flows;
            let proto = RenderFlow.prototype;
            let _batcher = RenderFlow.getBachther();
            let _cullingMask = 0;
            const WORLD_TRANSFORM = RenderFlow.FLAG_WORLD_TRANSFORM;
            const OPACITY_COLOR = RenderFlow.FLAG_OPACITY_COLOR;
            function parseChildren(ret, node) {
                let a = node._children;
                let n = a.length;
                node.___skip_children___ = true;
                node.___z___ = ret.length;
                ret.push(node);
                if (node.getComponent(cc.Mask)) {
                    delete node.___skip_children___;
                    return;
                }
                for (let i = 0; i < n; i++) {
                    parseChildren(ret, a[i]);
                }
            }
            function parseNode(node) {
                let a = [];
                let c = node._children;
                let n = c.length;
                let t = [];
                for (let i = 0; i < n; i++) {
                    parseChildren(t, c[i]);
                    a.push(...t);
                    t.length = 0;
                }
                a.sort((n1, n2) => {
                    return n1.___z___ - n2.___z___;
                });
                return a;
            }
            proto._children = function(node) {
                if (node.___skip_children___ === true) {
                    return this._next._func(node);
                }
                let cullingMask = _cullingMask;
                let batcher = _batcher;
                let parentOpacity = batcher.parentOpacity;
                let opacity = batcher.parentOpacity *= node._opacity / 255;
                let worldTransformFlag = batcher.worldMatDirty ? WORLD_TRANSFORM : 0;
                let worldOpacityFlag = batcher.parentOpacityDirty ? OPACITY_COLOR : 0;
                let worldDirtyFlag = worldTransformFlag | worldOpacityFlag;
                if (node.___batch_children_render___ === true) {
                    let children = parseNode(node);
                    for (let i = 0, l = children.length; i < l; i++) {
                        let c = children[i];
                        delete c.___z___;
                        c._renderFlag |= worldDirtyFlag;
                        if (!c._activeInHierarchy || c._opacity === 0 || c._$N_visible === false) continue;
                        _cullingMask = c._cullingMask = c.groupIndex === 0 ? cullingMask : 1 << c.groupIndex;
                        let colorVal = c._color._val;
                        c._color._fastSetA(c._opacity * opacity);
                        flows[c._renderFlag]._func(c);
                        c._color._val = colorVal;
                        delete c.___skip_children___;
                    }
                } else {
                    let children = node._children;
                    for (let i = 0, l = children.length; i < l; i++) {
                        let c = children[i];
                        c._renderFlag |= worldDirtyFlag;
                        if (!c._activeInHierarchy || c._opacity === 0 || c._$N_visible === false) continue;
                        _cullingMask = c._cullingMask = c.groupIndex === 0 ? cullingMask : 1 << c.groupIndex;
                        let colorVal = c._color._val;
                        c._color._fastSetA(c._opacity * opacity);
                        flows[c._renderFlag]._func(c);
                        c._color._val = colorVal;
                    }
                }
                batcher.parentOpacity = parentOpacity;
                this._next._func(node);
            };
            RenderFlow.visitRootNode = function(rootNode) {
                RenderFlow.validateRenderers();
                let preCullingMask = _cullingMask;
                _cullingMask = rootNode._cullingMask;
                if (rootNode._renderFlag & WORLD_TRANSFORM) {
                    _batcher.worldMatDirty++;
                    rootNode._calculWorldMatrix();
                    rootNode._renderFlag &= ~WORLD_TRANSFORM;
                    flows[rootNode._renderFlag]._func(rootNode);
                    _batcher.worldMatDirty--;
                } else {
                    flows[rootNode._renderFlag]._func(rootNode);
                }
                _cullingMask = preCullingMask;
            };
        }
        cc._RF.pop();
    }, {} ],
    195: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "87e2ek2q9hEzZlt4+rQSxM8", "vec2");
        if (CC_EDITOR) {} else {
            let _TEMP = new cc.Vec2(0, 0);
            cc.js.get(cc.Vec2, "TEMP", function() {
                return _TEMP;
            });
        }
        cc._RF.pop();
    }, {} ],
    196: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "1a8839K/IBNWKMJxIkZbCs5", "gdk_ButtonSoundId");
        const Enum = require("./gdk_Enum");
        var ButtonSoundId = Enum({
            None: -1
        });
        module.exports = ButtonSoundId;
        cc._RF.pop();
    }, {
        "./gdk_Enum": 197
    } ],
    197: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "6f6d69ItCxMFZDTvwiK29Px", "gdk_Enum");
        let mixins = function(obj) {
            var lastIndex = 0;
            var keys = Object.keys(this);
            lastIndex = keys.length;
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (Number.isInteger(parseFloat(key))) {
                    continue;
                }
                var index = this[key] = lastIndex++;
                var reverseKey = "" + index;
                if (key !== reverseKey) {
                    cc.js.value(this, reverseKey, key);
                }
            }
            if (CC_EDITOR && this.__enums__) {
                var enums = this.__enums__;
                for (var name in this) {
                    var value = this[name];
                    if (Number.isInteger(value)) {
                        enums[value] = {
                            name: name,
                            value: value
                        };
                    }
                }
                enums.sort(function(a, b) {
                    return a.value - b.value;
                });
            }
            this.__value__ = this.__value__ || {};
            this.__value__ = Object.assign(this.__value__, obj);
        };
        let getValue = function(v) {
            if (this.__value__) {
                if (v == "") {
                    return this.__value__[this[0]];
                }
                let o = this.__value__[v];
                if (o == null) {
                    v = this[v];
                    if (v) {
                        o = this.__value__[v];
                    }
                }
                return o;
            }
            return null;
        };
        let Enum = function(obj) {
            let en = cc.Enum(obj);
            cc.js.value(en, "mixins", mixins, true);
            cc.js.value(en, "getValue", getValue, true);
            cc.js.value(en, "__value__", null, true);
            return en;
        };
        module.exports = Enum;
        cc._RF.pop();
    }, {} ],
    198: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "8de7dxOk3dKnZxY0GktNKig", "gdk_EventId");
        const Enum = require("./gdk_Enum");
        let EventId = Enum({
            None: -1
        });
        module.exports = EventId;
        cc._RF.pop();
    }, {
        "./gdk_Enum": 197
    } ],
    199: [ function(require, module, exports) {
        const Enum = require("./gdk_Enum");
        let LanguageId = Enum({
            None: -1
        });
        module.exports = LanguageId;
    }, {
        "./gdk_Enum": 197
    } ],
    200: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "c7e5fTMcYtGXoznmda+8P2R", "gdk_MusicId");
        const Enum = require("./gdk_Enum");
        var MusicId = Enum({
            None: -1
        });
        module.exports = MusicId;
        cc._RF.pop();
    }, {
        "./gdk_Enum": 197
    } ],
    201: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "321d77muP5Jb6pUIZSWZMtl", "gdk_PanelId");
        const Enum = require("./gdk_Enum");
        let PanelId = Enum({
            None: -1
        });
        PanelId.__value__ = {};
        PanelId.__enums__ = [];
        let $mixins = PanelId.mixins;
        let mixins = function(obj) {
            for (let key in obj) {
                let o = obj[key];
                if (typeof o === "object" && !o.__id__) {
                    o.__id__ = key;
                }
            }
            $mixins.call(this, obj);
        };
        cc.js.value(PanelId, "mixins", mixins, true);
        module.exports = PanelId;
        cc._RF.pop();
    }, {
        "./gdk_Enum": 197
    } ],
    202: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "021e4EdAF5HL6C97Y9tQ/Fj", "gdk_ResourceId");
        const Enum = require("./gdk_Enum");
        let ResourceId = Enum({
            None: -1
        });
        ResourceId.__value__ = {};
        module.exports = ResourceId;
        cc._RF.pop();
    }, {
        "./gdk_Enum": 197
    } ],
    203: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "665f2V3DShBXqku1+9uNY3o", "gdk_SceneId");
        const Enum = require("./gdk_Enum");
        var SceneId = Enum({
            None: -1
        });
        SceneId.__value__ = {};
        module.exports = SceneId;
        cc._RF.pop();
    }, {
        "./gdk_Enum": 197
    } ],
    204: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "c762b06k+ZB0JRvh0B6OWj8", "gdk_SoundId");
        const Enum = require("./gdk_Enum");
        var SoundId = Enum({
            None: -1
        });
        module.exports = SoundId;
        cc._RF.pop();
    }, {
        "./gdk_Enum": 197
    } ],
    205: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ea7d3KBRCdGsomsAt+4eU2b", "gdk");
        var gdk = {
            version: require("./gdk_Version"),
            fontFamily: "SimHei",
            HideMode: require("./const/gdk_HideMode"),
            MessageMode: require("./const/gdk_MessageMode"),
            SlideEffectMode: require("./const/gdk_SlideEffectMode"),
            EaseType: require("./const/gdk_EaseType"),
            SizeType: require("./const/gdk_SizeType"),
            DelayCall: require("./core/gdk_DelayCall"),
            Timer: require("./core/gdk_Timer"),
            Tool: require("./core/gdk_Tool"),
            Pool: require("./core/gdk_Pool"),
            Event: require("./core/gdk_Event"),
            EventTrigger: require("./core/gdk_EventTrigger"),
            Cache: require("./core/gdk_Cache"),
            Binding: require("./Tools/gdk_Binding"),
            NodeTool: require("./Tools/gdk_NodeTool"),
            LanguageId: require("./enums/gdk_LanguageId"),
            LanguageData: require("./i18/LanguageData"),
            i18n: require("./Tools/gdk_i18n"),
            Log: require("./Tools/gdk_Log"),
            LogLevel: require("./const/gdk_LogLevel"),
            SizeTool: require("./Tools/gdk_SizeTool"),
            Enum: require("./enums/gdk_Enum"),
            PanelId: require("./enums/gdk_PanelId"),
            SoundId: require("./enums/gdk_SoundId"),
            ButtonSoundId: require("./enums/gdk_ButtonSoundId"),
            MusicId: require("./enums/gdk_MusicId"),
            SceneId: require("./enums/gdk_SceneId"),
            ResourceId: require("./enums/gdk_ResourceId"),
            EventId: require("./enums/gdk_EventId"),
            GUIManager: require("./managers/gdk_GUIManager"),
            PanelManager: require("./managers/gdk_PanelManager"),
            EventManager: require("./managers/gdk_EventManager"),
            PoolManager: require("./managers/gdk_PoolManager"),
            PopupManager: require("./managers/gdk_PopupManager"),
            MusicManager: require("./managers/gdk_MusicManager"),
            SoundManager: require("./managers/gdk_SoundManager"),
            ModuleManager: require("./managers/gdk_ModuleManager"),
            SceneManager: require("./managers/gdk_SceneManager"),
            ResourceManager: require("./managers/gdk_ResourceManager"),
            TextUI: require("./ui/gdk_TextUI"),
            BasePanel: require("./ui/gdk_BasePanel"),
            Alert: require("./ui/gdk_Alert"),
            MessageUI: require("./ui/gdk_MessageUI"),
            LoadingUI: require("./ui/gdk_LoadingUI"),
            WaitingUI: require("./ui/gdk_WaitingUI"),
            ToolTip: require("./ui/gdk_ToolTip"),
            BaseList: require("./ui/list/gdk_BaseList"),
            List: require("./ui/list/gdk_List"),
            ItemRenderer: require("./ui/list/gdk_ItemRenderer"),
            TextItemRenderer: require("./ui/list/gdk_TextItemRenderer"),
            ScrollList: require("./ui/gdk_ScrollList"),
            Switcher: require("./ui/gdk_Switcher"),
            PageViewTab: require("./ui/gdk_PageViewTabBar"),
            AddPopupButton: require("./ui/buttons/gdk_AddPopupButton"),
            CloseButton: require("./ui/buttons/gdk_CloseButton"),
            OpenPanelButton: require("./ui/buttons/gdk_OpenPanelButton"),
            SoundButton: require("./ui/buttons/gdk_SoundButton"),
            ShowHideComponent: require("./components/gdk_ShowHideComponent"),
            BaseShowHideEffect: require("./components/effects/gdk_BaseShowHideEffect"),
            FadeShowHideEffect: require("./components/effects/gdk_FadeShowHideEffect"),
            SlideShowHideEffect: require("./components/effects/gdk_SlideShowHideEffect"),
            AlertLayout: require("./components/layout/gdk_AlertLayout"),
            TextSizeLayout: require("./components/layout/gdk_TextSizeLayout"),
            BaseTween: require("./components/tweens/gdk_BaseTween"),
            RotateTween: require("./components/tweens/gdk_RotateTween"),
            PopupComponent: require("./components/gdk_PopupComponent"),
            Music: require("./components/gdk_Music"),
            Sound: require("./components/gdk_Sound"),
            CameraChildrenRender: require("./components/gdk_CameraChildrenRender"),
            BaseModule: require("./module/gdk_BaseModule"),
            Module: require("./module/gdk_Module"),
            View: require("./module/gdk_View"),
            _buildInfo: window && window.buildInfo || {},
            get buildInfo() {
                return this._buildInfo;
            },
            set buildInfo(value) {
                this._buildInfo = value;
                if (window && window.buildInfo) {
                    for (let i in value) {
                        if (window.buildInfo && window.buildInfo.hasOwnProperty(i)) {
                            value[i] = window.buildInfo[i];
                        }
                    }
                }
            },
            setBuildInfo(value) {
                this.buildInfo = value;
            }
        };
        gdk.gui = gdk.GUIManager;
        gdk.panel = gdk.PanelManager;
        gdk.e = gdk.EventManager;
        gdk.pool = gdk.PoolManager;
        gdk.popup = gdk.PopupManager;
        gdk.music = gdk.MusicManager;
        gdk.sound = gdk.SoundManager;
        gdk.m = gdk.ModuleManager;
        gdk.scene = gdk.SceneManager;
        gdk.rm = gdk.ResourceManager;
        gdk.binding = gdk.Binding.bindDescriptor;
        let mathjsUtils = require("mathjs/lib/utils/customs.js");
        mathjsUtils.getSafeProperty = function(object, prop) {
            if (typeof object === "object" && object) {
                return object[prop];
            }
            throw new Error('No access to property "' + prop + '"');
        };
        mathjsUtils.setSafeProperty = function(object, prop, value) {
            if (typeof object === "object" && object) {
                object[prop] = value;
                return value;
            }
            throw new Error('No access to property "' + prop + '"');
        };
        gdk.math = require("mathjs-expression-parser");
        delete gdk.math.matrix;
        delete gdk.math.and;
        delete gdk.math.or;
        gdk.math.import({
            matrix: function(a) {
                return a;
            },
            get: function(a, b) {
                return a[b];
            },
            rate: function(r, v1, v2) {
                return Math.random() <= r ? v1 : v2;
            },
            array: function(...args) {
                return [ ...args ];
            },
            and: function() {
                let a = arguments;
                for (let i = 0, n = a.length; i < n; i++) {
                    if (!a[i]) {
                        return false;
                    }
                }
                return true;
            },
            or: function() {
                let a = arguments;
                for (let i = 0, n = a.length; i < n; i++) {
                    if (!!a[i]) {
                        return true;
                    }
                }
                return false;
            }
        });
        gdk.MobileDeviceDetect = require("mobile-device-detect");
        gdk.mdd = gdk.MobileDeviceDetect;
        gdk.amf = require("ham-amf");
        gdk.pako = require("pako");
        gdk.Buffer = require("buffer").Buffer;
        gdk.SmartBuffer = require("smart-buffer").SmartBuffer;
        gdk.md5 = require("md5");
        gdk.macro = {
            ENABLE_MULTI_TOUCH: true,
            ENABLE_PNG_WORKER: false,
            ENABLE_ARRAYBUFFER_WORKER: false,
            RESOURCE_RELEASE_INTERVAL: 1e3,
            RESOURCE_RELEASE_MAX: 50,
            RESOURCE_RELEASE_TIMEOUT: 3 * 60 * 1e3
        };
        window.gdk = window.gdk || {};
        window.gdk = Object.assign(window.gdk, gdk);
        require("./gdk_Engine");
        require("./components");
        require("./ui");
        require("./i18");
        require("./engine");
        module.exports = window.gdk;
        cc._RF.pop();
    }, {
        "./Tools/gdk_Binding": 138,
        "./Tools/gdk_Log": 139,
        "./Tools/gdk_NodeTool": 140,
        "./Tools/gdk_SizeTool": 141,
        "./Tools/gdk_i18n": 142,
        "./components": 158,
        "./components/effects/gdk_BaseShowHideEffect": 143,
        "./components/effects/gdk_FadeShowHideEffect": 145,
        "./components/effects/gdk_SlideShowHideEffect": 147,
        "./components/gdk_CameraChildrenRender": 149,
        "./components/gdk_Music": 151,
        "./components/gdk_PopupComponent": 152,
        "./components/gdk_ShowHideComponent": 155,
        "./components/gdk_Sound": 156,
        "./components/layout/gdk_AlertLayout": 159,
        "./components/layout/gdk_TextSizeLayout": 160,
        "./components/tweens/gdk_BaseTween": 161,
        "./components/tweens/gdk_RotateTween": 162,
        "./const/gdk_EaseType": 164,
        "./const/gdk_HideMode": 165,
        "./const/gdk_LogLevel": 166,
        "./const/gdk_MessageMode": 167,
        "./const/gdk_SizeType": 168,
        "./const/gdk_SlideEffectMode": 169,
        "./core/gdk_Cache": 170,
        "./core/gdk_DelayCall": 171,
        "./core/gdk_Event": 172,
        "./core/gdk_EventTrigger": 173,
        "./core/gdk_Pool": 176,
        "./core/gdk_Timer": 177,
        "./core/gdk_Tool": 178,
        "./engine": 192,
        "./enums/gdk_ButtonSoundId": 196,
        "./enums/gdk_Enum": 197,
        "./enums/gdk_EventId": 198,
        "./enums/gdk_LanguageId": 199,
        "./enums/gdk_MusicId": 200,
        "./enums/gdk_PanelId": 201,
        "./enums/gdk_ResourceId": 202,
        "./enums/gdk_SceneId": 203,
        "./enums/gdk_SoundId": 204,
        "./gdk_Engine": 206,
        "./gdk_Version": 207,
        "./i18": 212,
        "./i18/LanguageData": 208,
        "./managers/gdk_EventManager": 214,
        "./managers/gdk_GUIManager": 215,
        "./managers/gdk_ModuleManager": 216,
        "./managers/gdk_MusicManager": 217,
        "./managers/gdk_PanelManager": 218,
        "./managers/gdk_PoolManager": 219,
        "./managers/gdk_PopupManager": 220,
        "./managers/gdk_ResourceManager": 221,
        "./managers/gdk_SceneManager": 222,
        "./managers/gdk_SoundManager": 223,
        "./module/gdk_BaseModule": 224,
        "./module/gdk_Module": 225,
        "./module/gdk_View": 226,
        "./ui": 242,
        "./ui/buttons/gdk_AddPopupButton": 227,
        "./ui/buttons/gdk_CloseButton": 228,
        "./ui/buttons/gdk_OpenPanelButton": 230,
        "./ui/buttons/gdk_SoundButton": 231,
        "./ui/gdk_Alert": 232,
        "./ui/gdk_BasePanel": 233,
        "./ui/gdk_LoadingUI": 234,
        "./ui/gdk_MessageUI": 235,
        "./ui/gdk_PageViewTabBar": 236,
        "./ui/gdk_ScrollList": 237,
        "./ui/gdk_Switcher": 238,
        "./ui/gdk_TextUI": 239,
        "./ui/gdk_ToolTip": 240,
        "./ui/gdk_WaitingUI": 241,
        "./ui/list/gdk_BaseList": 243,
        "./ui/list/gdk_ItemRenderer": 244,
        "./ui/list/gdk_List": 245,
        "./ui/list/gdk_TextItemRenderer": 246,
        buffer: 44,
        "ham-amf": 49,
        "mathjs-expression-parser": 59,
        "mathjs/lib/utils/customs.js": 108,
        md5: 115,
        "mobile-device-detect": 116,
        pako: 117,
        "smart-buffer": 133
    } ],
    206: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "fb701Ymh5FEtrw/9933kL6s", "gdk_Engine");
        const GUIManager = require("./managers/gdk_GUIManager");
        const Pool = require("./core/gdk_Pool");
        const MessageMode = require("./const/gdk_MessageMode");
        const Timer = require("./core/gdk_Timer");
        let gdk_Engine = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Core)/gdk_Engine",
                disallowMultiple: true
            },
            properties: {
                waitingPrefab: {
                    default: null,
                    type: cc.Prefab,
                    tooltip: CC_DEV && "信息提示"
                },
                alertPrefab: {
                    default: null,
                    type: cc.Prefab,
                    tooltip: CC_DEV && "信息提示"
                },
                messageBgPrefab: {
                    default: null,
                    type: cc.Prefab,
                    tooltip: CC_DEV && "信息提示背景"
                },
                messagePrefab: {
                    default: null,
                    type: cc.Prefab,
                    tooltip: CC_DEV && "信息提示"
                },
                toolTipPrefab: {
                    default: null,
                    type: cc.Prefab,
                    tooltip: CC_DEV && "信息提示"
                },
                maskPrefab: {
                    default: null,
                    type: cc.Prefab,
                    tooltip: CC_DEV && "窗口遮照"
                },
                popupMaskColor: {
                    default: new cc.Color(0, 0, 0, 255 * .3),
                    tooltip: CC_DEV && "弹出窗模态时的遮罩颜色"
                },
                waitingMaskColor: {
                    default: new cc.Color(0, 0, 0, 0),
                    tooltip: CC_DEV && "等待组件模态遮罩颜色"
                },
                alertMaskColor: {
                    default: new cc.Color(0, 0, 0, 255 * .3),
                    tooltip: CC_DEV && "警告面板模态遮罩颜色"
                },
                alertTitle: {
                    default: "",
                    tooltip: CC_DEV && "警告面板默认标题"
                },
                alertOk: {
                    default: "OK",
                    tooltip: CC_DEV && "警告面板默认确定文字"
                },
                alertCancel: {
                    default: "Cancel",
                    tooltip: CC_DEV && "警告面板默认取消文字"
                },
                messageAutoCloseTime: {
                    default: 2,
                    type: cc.Float,
                    tooltip: CC_DEV && "提示信息多少秒后自己消失.\n单位:秒"
                },
                messageMode: {
                    default: 0,
                    type: MessageMode,
                    tooltip: CC_DEV && "多条提示信息时的显示模式"
                },
                poolClearTime: {
                    default: 5 * 60,
                    tooltip: CC_DEV && "对象池回收时间间隔.\n单位:秒"
                },
                debugLayer: true,
                systemPopLayer: true,
                loadingLayer: true,
                waitingLayer: true,
                toolTipLayer: true,
                guideLayer: true,
                messageLayer: true,
                popMenuLayer: true,
                popupLayer: true,
                menuLayer: true,
                viewLayer: true,
                floorLayer: true,
                showFsmLog: false
            },
            onLoad() {
                var gdk = require("./gdk");
                var layers = GUIManager.layers;
                layers.length = 0;
                this.floorLayer && layers.push("floorLayer");
                this.viewLayer && layers.push("viewLayer");
                this.menuLayer && layers.push("menuLayer");
                this.popupLayer && layers.push("popupLayer");
                this.popMenuLayer && layers.push("popMenuLayer");
                this.messageLayer && layers.push("messageLayer");
                this.guideLayer && layers.push("guideLayer");
                this.toolTipLayer && layers.push("toolTipLayer");
                this.waitingLayer && layers.push("waitingLayer");
                this.loadingLayer && layers.push("loadingLayer");
                this.systemPopLayer && layers.push("systemPopLayer");
                this.debugLayer && layers.push("debugLayer");
                GUIManager.init(this.node);
                GUIManager.waitingPrefab = this.waitingPrefab;
                GUIManager.alertPrefab = this.alertPrefab;
                GUIManager.toolTipPrefab = this.toolTipPrefab;
                GUIManager.messageBgPrefab = this.messageBgPrefab;
                GUIManager.messagePrefab = this.messagePrefab;
                GUIManager.maskPrefab = this.maskPrefab;
                GUIManager.popupMaskColor = this.popupMaskColor;
                GUIManager.waitingMaskColor = this.waitingMaskColor;
                GUIManager.alertMaskColor = this.alertMaskColor;
                GUIManager.alertTitle = this.alertTitle;
                GUIManager.alertOk = this.alertOk;
                GUIManager.alertCancel = this.alertCancel;
                GUIManager.messageAutoCloseTime = this.messageAutoCloseTime;
                GUIManager.messageMode = this.messageMode;
                Pool.clearTime = this.poolClearTime;
                if (gdk.fsm) {
                    gdk.fsm.Fsm.isShowLog = CC_DEBUG && this.showFsmLog;
                }
                cc.game.addPersistRootNode(this.node);
                if (gdk.engine) {
                    cc.error("gdk_Engine组件只能有一个实例");
                }
                gdk.engine = this;
            },
            onEnable() {
                var canvas = cc.Canvas.instance;
                if (canvas && canvas.node) {
                    canvas.node.on("size-changed", this.updateSize, this);
                }
                this.updateSize();
            },
            onDisable() {
                var canvas = cc.Canvas.instance;
                if (canvas && canvas.node) {
                    canvas.node.off("size-changed", this.updateSize, this);
                }
            },
            updateSize() {
                Timer.callLater(GUIManager, GUIManager.updateSize);
            }
        });
        module.exports = gdk_Engine;
        cc._RF.pop();
    }, {
        "./const/gdk_MessageMode": 167,
        "./core/gdk_Pool": 176,
        "./core/gdk_Timer": 177,
        "./gdk": 205,
        "./managers/gdk_GUIManager": 215
    } ],
    207: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "15906wXKINLfoKx1oXtsRE5", "gdk_Version");
        module.exports = "1.0.0.1523";
        cc._RF.pop();
    }, {} ],
    208: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "61de062n4dJ7ZM9/Xdumozn", "LanguageData");
        const Polyglot = require("./polyglot.min");
        let polyInst = null;
        let i18n = window.i18n;
        if (!i18n) {
            window.i18n = i18n = {
                languages: {},
                curLang: ""
            };
        }
        module.exports = {
            init(language) {
                language === void 0 && (language = "zh_CN");
                if (language === i18n.curLang) {
                    return;
                }
                i18n.curLang = language;
                polyInst = null;
            },
            t(key, opt) {
                if (!polyInst) {
                    if (!i18n.curLang) {
                        this.init();
                    }
                    let data = i18n.languages[i18n.curLang];
                    if (data) {
                        polyInst = new Polyglot({
                            phrases: data,
                            allowMissing: true
                        });
                    }
                }
                if (polyInst) {
                    return polyInst.t(key, opt);
                }
            },
            updateSceneRenderers() {
                let rootNodes = cc.director.getScene().children;
                let allLocalizedLabels = [];
                for (let i = 0; i < rootNodes.length; ++i) {
                    let labels = rootNodes[i].getComponentsInChildren("LocalizedLabel");
                    Array.prototype.push.apply(allLocalizedLabels, labels);
                }
                for (let i = 0; i < allLocalizedLabels.length; ++i) {
                    let label = allLocalizedLabels[i];
                    label.updateLabel();
                }
                let allLocalizedSprites = [];
                for (let i = 0; i < rootNodes.length; ++i) {
                    let sprites = rootNodes[i].getComponentsInChildren("LocalizedSprite");
                    Array.prototype.push.apply(allLocalizedSprites, sprites);
                }
                for (let i = 0; i < allLocalizedSprites.length; ++i) {
                    let sprite = allLocalizedSprites[i];
                    sprite.updateSprite(i18n.curLang);
                }
            }
        };
        cc._RF.pop();
    }, {
        "./polyglot.min": 213
    } ],
    209: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "744dcs4DCdNprNhG0xwq6FK", "LocalizedLabel");
        const i18n = require("./LanguageData");
        function debounce(func, wait, immediate) {
            var timeout;
            return function() {
                var context = this, args = arguments;
                var later = function() {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        }
        cc.Class({
            extends: cc.Component,
            editor: {
                executeInEditMode: true,
                menu: "i18n/LocalizedLabel"
            },
            properties: {
                dataID: {
                    get() {
                        return this._dataID;
                    },
                    set(val) {
                        if (this._dataID !== val) {
                            this._dataID = val;
                            if (CC_EDITOR) {
                                this._debouncedUpdateLabel();
                            } else {
                                this.updateLabel();
                            }
                        }
                    }
                },
                _dataID: ""
            },
            onLoad() {
                if (CC_EDITOR) {
                    this._debouncedUpdateLabel = debounce(this.updateLabel, 200);
                }
                if (!i18n.inst) {
                    i18n.init();
                }
                this.fetchRender();
            },
            fetchRender() {
                let label = this.getComponent(cc.Label);
                if (label) {
                    this.label = label;
                    this.updateLabel();
                    return;
                }
            },
            updateLabel() {
                if (!this.label) {
                    cc.error("Failed to update localized label, label component is invalid!");
                    return;
                }
                let localizedString = i18n.t(this.dataID);
                if (localizedString) {
                    this.label.string = i18n.t(this.dataID);
                }
            }
        });
        cc._RF.pop();
    }, {
        "./LanguageData": 208
    } ],
    210: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "f34ac2GGiVOBbG6XlfvgYP4", "LocalizedSprite");
        const SpriteFrameSet = require("./SpriteFrameSet");
        cc.Class({
            extends: cc.Component,
            editor: {
                executeInEditMode: true,
                inspector: "packages://i18n/inspector/localized-sprite.js",
                menu: "i18n/LocalizedSprite"
            },
            properties: {
                spriteFrameSet: {
                    default: [],
                    type: SpriteFrameSet
                }
            },
            onLoad() {
                this.fetchRender();
            },
            fetchRender() {
                let sprite = this.getComponent(cc.Sprite);
                if (sprite) {
                    this.sprite = sprite;
                    this.updateSprite(window.i18n.curLang);
                    return;
                }
            },
            getSpriteFrameByLang(lang) {
                for (let i = 0; i < this.spriteFrameSet.length; ++i) {
                    if (this.spriteFrameSet[i].language === lang) {
                        return this.spriteFrameSet[i].spriteFrame;
                    }
                }
            },
            updateSprite(language) {
                if (!this.sprite) {
                    cc.error("Failed to update localized sprite, sprite component is invalid!");
                    return;
                }
                let spriteFrame = this.getSpriteFrameByLang(language);
                if (!spriteFrame && this.spriteFrameSet[0]) {
                    spriteFrame = this.spriteFrameSet[0].spriteFrame;
                }
                this.sprite.spriteFrame = spriteFrame;
            }
        });
        cc._RF.pop();
    }, {
        "./SpriteFrameSet": 211
    } ],
    211: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "97019Q80jpE2Yfz4zbuCZBq", "SpriteFrameSet");
        const SpriteFrameSet = cc.Class({
            name: "SpriteFrameSet",
            properties: {
                language: "",
                spriteFrame: cc.SpriteFrame
            }
        });
        module.exports = SpriteFrameSet;
        cc._RF.pop();
    }, {} ],
    212: [ function(require, module, exports) {
        require("./LanguageData");
        require("./LocalizedLabel");
        require("./LocalizedSprite");
        require("./SpriteFrameSet");
    }, {
        "./LanguageData": 208,
        "./LocalizedLabel": 209,
        "./LocalizedSprite": 210,
        "./SpriteFrameSet": 211
    } ],
    213: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "e26fd9yy65A4q3/JkpVnFYg", "polyglot.min");
        (function(e, t) {
            typeof define == "function" && define.amd ? define([], function() {
                return t(e);
            }) : typeof exports == "object" ? module.exports = t(e) : e.Polyglot = t(e);
        })(this, function(e) {
            "use strict";
            function t(e) {
                e = e || {}, this.phrases = {}, this.extend(e.phrases || {}), this.currentLocale = e.locale || "en", 
                this.allowMissing = !!e.allowMissing, this.warn = e.warn || c;
            }
            function s(e) {
                var t, n, r, i = {};
                for (t in e) if (e.hasOwnProperty(t)) {
                    n = e[t];
                    for (r in n) i[n[r]] = t;
                }
                return i;
            }
            function o(e) {
                var t = /^\s+|\s+$/g;
                return e.replace(t, "");
            }
            function u(e, t, r) {
                var i, s, u;
                return r != null && e ? (s = e.split(n), u = s[f(t, r)] || s[0], i = o(u)) : i = e, 
                i;
            }
            function a(e) {
                var t = s(i);
                return t[e] || t.en;
            }
            function f(e, t) {
                return r[a(e)](t);
            }
            function l(e, t) {
                for (var n in t) n !== "_" && t.hasOwnProperty(n) && (e = e.replace(new RegExp("%\\{" + n + "\\}", "g"), t[n]));
                return e;
            }
            function c(t) {
                e.console && e.console.warn && e.console.warn("WARNING: " + t);
            }
            function h(e) {
                var t = {};
                for (var n in e) t[n] = e[n];
                return t;
            }
            t.VERSION = "0.4.3", t.prototype.locale = function(e) {
                return e && (this.currentLocale = e), this.currentLocale;
            }, t.prototype.extend = function(e, t) {
                var n;
                for (var r in e) e.hasOwnProperty(r) && (n = e[r], t && (r = t + "." + r), typeof n == "object" ? this.extend(n, r) : this.phrases[r] = n);
            }, t.prototype.clear = function() {
                this.phrases = {};
            }, t.prototype.replace = function(e) {
                this.clear(), this.extend(e);
            }, t.prototype.t = function(e, t) {
                var n, r;
                return t = t == null ? {} : t, typeof t == "number" && (t = {
                    smart_count: t
                }), typeof this.phrases[e] == "string" ? n = this.phrases[e] : typeof t._ == "string" ? n = t._ : this.allowMissing ? n = e : (this.warn('Missing translation for key: "' + e + '"'), 
                r = e), typeof n == "string" && (t = h(t), r = u(n, this.currentLocale, t.smart_count), 
                r = l(r, t)), r;
            }, t.prototype.has = function(e) {
                return e in this.phrases;
            };
            var n = "||||", r = {
                chinese: function(e) {
                    return 0;
                },
                german: function(e) {
                    return e !== 1 ? 1 : 0;
                },
                french: function(e) {
                    return e > 1 ? 1 : 0;
                },
                russian: function(e) {
                    return e % 10 === 1 && e % 100 !== 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
                },
                czech: function(e) {
                    return e === 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2;
                },
                polish: function(e) {
                    return e === 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
                },
                icelandic: function(e) {
                    return e % 10 !== 1 || e % 100 === 11 ? 1 : 0;
                }
            }, i = {
                chinese: [ "fa", "id", "ja", "ko", "lo", "ms", "th", "tr", "zh" ],
                german: [ "da", "de", "en", "es", "fi", "el", "he", "hu", "it", "nl", "no", "pt", "sv" ],
                french: [ "fr", "tl", "pt-br" ],
                russian: [ "hr", "ru" ],
                czech: [ "cs" ],
                polish: [ "pl" ],
                icelandic: [ "is" ]
            };
            return t;
        });
        cc._RF.pop();
    }, {} ],
    214: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "137bcsnoRZFQqTJB3vaYpL6", "gdk_EventManager");
        var Event = require("../core/gdk_Event");
        var EventTrigger = require("../core/gdk_EventTrigger");
        var _eventTriggerDic = {};
        var EventManager = {
            on(eventType, callback, thisArg = null, priority = 0, hasEventArg = true) {
                var trigger = EventManager._getEventTrigger(eventType, true);
                trigger && trigger.on(callback, thisArg, priority, hasEventArg);
            },
            once(eventType, callback, thisArg = null, priority = 0, hasEventArg = true) {
                var trigger = EventManager._getEventTrigger(eventType, true);
                trigger && trigger.once(callback, thisArg, priority, hasEventArg);
            },
            off(eventType, callback, thisArg = null) {
                var trigger = EventManager._getEventTrigger(eventType, false);
                if (trigger) {
                    trigger.off(callback, thisArg);
                    if (trigger.count < 1) {
                        EventManager._putEventTrigger(eventType);
                    }
                }
            },
            offAll(eventType) {
                var trigger = EventManager._getEventTrigger(eventType, false);
                if (trigger) {
                    trigger.offAll();
                    EventManager._putEventTrigger(eventType);
                }
            },
            targetOff(thisArg) {
                var trigger;
                for (var eventType in _eventTriggerDic) {
                    trigger = _eventTriggerDic[eventType];
                    trigger.targetOff(thisArg);
                    if (trigger.count < 1) {
                        EventManager._putEventTrigger(eventType);
                    }
                }
            },
            has(eventType, callback, thisArg = null) {
                var trigger = EventManager._getEventTrigger(eventType, false);
                if (trigger) {
                    if (callback) {
                        return trigger.has(callback, thisArg);
                    }
                    return trigger.count > 0;
                }
                return false;
            },
            _getEventTrigger(eventType, autoCreate = false) {
                if (eventType == null || eventType == "") {
                    return null;
                }
                var trigger = _eventTriggerDic[eventType];
                if (trigger == null && autoCreate) {
                    trigger = _eventTriggerDic[eventType] = EventTrigger.get();
                }
                return trigger;
            },
            _putEventTrigger(eventType) {
                var trigger = _eventTriggerDic[eventType];
                if (trigger) {
                    delete _eventTriggerDic[eventType];
                    EventTrigger.put(trigger);
                }
            },
            emit(eventType, data = null, code = 0) {
                var trigger = EventManager._getEventTrigger(eventType, false);
                if (trigger) {
                    var event = Event.get(eventType, data);
                    event.code = code;
                    var returnData = trigger.emit(event);
                    event.release(false);
                    return returnData;
                }
            },
            getEventCount(eventType) {
                if (eventType) {
                    let trigger = EventManager._getEventTrigger(eventType, false);
                    if (trigger) {
                        return trigger.count;
                    }
                    return 0;
                } else {
                    let count = 0;
                    for (let eventType in _eventTriggerDic) {
                        let trigger = _eventTriggerDic[eventType];
                        count += trigger.count;
                    }
                    return count;
                }
            }
        };
        cc.js.get(EventManager, "__all__", function() {
            return _eventTriggerDic;
        });
        module.exports = EventManager;
        cc._RF.pop();
    }, {
        "../core/gdk_Event": 172,
        "../core/gdk_EventTrigger": 173
    } ],
    215: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "69cedJCRiVOl6J5QtbwYUJQ", "gdk_GUIManager");
        var Tool = require("../core/gdk_Tool");
        var NodeTool = require("../Tools/gdk_NodeTool");
        var PoolManager = require("./gdk_PoolManager");
        var PopupManager = require("./gdk_PopupManager");
        var LoadingUI = require("../ui/gdk_LoadingUI");
        var Alert = require("../ui/gdk_Alert");
        var MessaageUI = require("../ui/gdk_MessageUI");
        var WaitingUI = require("../ui/gdk_WaitingUI");
        var PopupComponent = require("../components/gdk_PopupComponent");
        var EventTrigger = require("../core/gdk_EventTrigger");
        var DelayCall = require("../core/gdk_DelayCall");
        var HideMode = require("../const/gdk_HideMode");
        var MessageMode = require("../const/gdk_MessageMode");
        var ToolTip = require("../ui/gdk_ToolTip");
        var EventManager = require("./gdk_EventManager");
        var GUIManager = function() {
            this.layers = [ "floorLayer", "viewLayer", "menuLayer", "popupLayer", "popMenuLayer", "messageLayer", "guideLayer", "toolTipLayer", "waitingLayer", "loadingLayer", "systemPopLayer", "debugLayer" ];
            this.messageBgPrefab = null;
            this.messagePrefab = null;
            this.messageAutoCloseTime = 2;
            this.messageMode = MessageMode.FLOAT;
            this.messageMax = Number.MAX_VALUE;
            this.waitingPrefab = null;
            this.waitingMaskColor = new cc.color(0, 0, 0, 0);
            this.alertPrefab = null;
            this.alertMaskColor = new cc.color(0, 0, 0, 255 * .5);
            this.alertTitle = "";
            this.alertOk = "OK";
            this.alertCancel = "Cancel";
            this.popupMaskColor = new cc.color(0, 0, 0, 255 * .5);
            this.popupMenuPrefab = null;
            this.toolTipPrefab = null;
            this.maskPrefab = null;
            this.onLoadingShow = new EventTrigger();
            this.onLoadingHide = new EventTrigger();
            this.onViewChanged = new EventTrigger();
            this.onPopupChanged = new EventTrigger();
            this.onLockScreenClick = new EventTrigger();
            this.guiLayer;
            this.guiWidgetSize = {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0
            };
            this._loadingUI = null;
            this._waitingUI = null;
            this._waitingTagMap = new Map();
            this._waitingTimeoutMap = new Map();
            this._waitingDelayMap = new Map();
            this._popUpMenu = null;
            this._toolTipUI = null;
            this._navViews = [];
            this._lockScreen = null;
            this._isInit = false;
            this._popupOneByOnes = [];
        };
        GUIManager.prototype = {
            init(guiLayer) {
                if (this._isInit) return;
                this.guiLayer = guiLayer;
                if (this.guiLayer == null) {
                    this.guiLayer = new cc.Node("guiLayer");
                    var curScene = cc.director.getScene();
                    this.guiLayer.parent = curScene;
                    this.guiLayer.zIndex = 1e3;
                }
                var layersTemp = {};
                for (var i = 0; i < this.layers.length; i++) {
                    var layer = new cc.Node(this.layers[i]);
                    layer.parent = this.guiLayer;
                    layersTemp[this.layers[i]] = layer;
                }
                this.layers = layersTemp;
                this._isInit = true;
            },
            updateSize() {
                let instance = cc.Canvas.instance;
                if (instance && cc.isValid(instance.node)) {
                    this.guiWidgetSize = {
                        top: 45,
                        bottom: 38,
                        left: 0,
                        right: 0
                    };
                    if (cc.sys.platform === cc.sys.WECHAT_GAME) {
                        const wx = window["wx"];
                        const info = wx ? wx.getSystemInfoSync() : null;
                        const widget = this.guiWidgetSize;
                        if (info && (info.system.startsWith("Windows") || info.system.startsWith("macOS"))) {
                            widget.top = 0;
                            widget.bottom = 0;
                        } else if (info && info.safeArea) {
                            let windowHeight = info.windowHeight;
                            let gameSize = cc.view.getVisibleSize();
                            let gameHeight = gameSize.height;
                            let ratio = gameHeight / windowHeight;
                            let rect = wx.getMenuButtonBoundingClientRect();
                            rect.height *= ratio;
                            rect.top *= ratio;
                            widget.top = Math.max(80, rect.top + rect.height) >> 0;
                            widget.bottom = Math.max(0, info.screenHeight - info.safeArea.bottom) >> 0;
                        } else {
                            widget.top = 128;
                            widget.bottom = 38;
                        }
                    } else if (cc.sys.isBrowser && !cc.sys.isNative) {
                        const gdk = require("../gdk");
                        const widget = this.guiWidgetSize;
                        if (gdk.mdd.isIOS) {
                            widget.top = 0;
                        } else if (gdk.mdd.isAndroid) {
                            widget.top = 45;
                            widget.bottom = 0;
                        } else {
                            const view = cc.view;
                            const scale = view.getScaleX();
                            widget.top = 0;
                            widget.bottom = 0;
                            widget.left = widget.right = Math.max(0, (view.getCanvasSize().width - view.getDesignResolutionSize().width * scale) / 2 / scale) >> 0;
                        }
                    }
                    var ws = cc.view.getCanvasSize();
                    var n = instance.node;
                    var w = n.width;
                    var h = n.height;
                    var gws = this.guiWidgetSize;
                    if (gws && (!cc.sys.isMobile || cc.sys.platform === cc.sys.WECHAT_GAME || ws.height / ws.width > 2)) {
                        var comp = this.guiLayer.getComponent(cc.Widget);
                        if (!comp) {
                            comp = this.guiLayer.addComponent(cc.Widget);
                            comp.isAlignTop = true;
                            comp.isAlignBottom = true;
                            comp.isAlignLeft = true;
                            comp.isAlignRight = true;
                            comp.alignMode = 2;
                        }
                        comp.top = gws.top;
                        comp.bottom = gws.bottom;
                        comp.left = gws.left;
                        comp.right = gws.right;
                        h -= gws.top + gws.bottom;
                        w -= gws.left + gws.right;
                        this.guiLayer.children.forEach(n => {
                            var c = n.getComponent(cc.Widget);
                            if (c) {
                                c.verticalCenter = (gws.top - gws.bottom) / 2;
                            }
                        });
                    }
                    var layerSize = cc.size(w, h);
                    for (var i in this.layers) {
                        var layer = this.layers[i];
                        layer.setContentSize(layerSize);
                    }
                }
            },
            getCurrentLoading(prefab) {
                if (prefab && this._loadingUI == null) {
                    if (prefab instanceof cc.Node) {
                        this._loadingUI = prefab;
                    } else {
                        let key = prefab.name + "#" + prefab.data._prefab.fileId;
                        this._loadingUI = PoolManager.getCacheOrPool(key);
                        if (this._loadingUI == null) {
                            this._loadingUI = cc.instantiate(prefab);
                        }
                    }
                }
                return this._loadingUI;
            },
            showLoading(info, loaded, total) {
                if (typeof info == "number") {
                    total = loaded;
                    loaded = info;
                    info = null;
                }
                return this._showLoading(info, loaded, total);
            },
            _showLoading(info, loaded, total) {
                if (this._loadingUI) {
                    var isShow = this._loadingUI.active;
                    if (this._loadingUI.parent == null) {
                        this._loadingUI.parent = this.layers.loadingLayer;
                        this._loadingUI.setPosition(0, 0);
                    }
                    if (isShow == false) {
                        NodeTool.show(this._loadingUI);
                        this.onLoadingShow.emit();
                    }
                    var ui = this._loadingUI.getComponent(LoadingUI);
                    if (ui) {
                        if (info != null) ui.info = info;
                        if (loaded != null) ui.loaded = loaded;
                        if (total != null) ui.total = total;
                    }
                }
                return this._loadingUI;
            },
            hideLoading() {
                if (this._loadingUI && cc.isValid(this._loadingUI) && this._loadingUI.parent) {
                    var isShow = NodeTool.isShow(this._loadingUI);
                    if (isShow) {
                        this._loadingUI = NodeTool.hide(this._loadingUI);
                        this.onLoadingHide.emit();
                    }
                }
                this._loadingUI = null;
            },
            showAlert(text, title = null, tag = null, callback = null, thisArg = null, buttons = null) {
                var args = this._getAlertArgs(title, tag, callback, thisArg, buttons);
                return this._showAlert(text, args.title, args.tag, args.callback, args.thisArg, args.buttons);
            },
            _showAlert(text, title, tag, callback, thisArg, buttons) {
                var alert = null;
                if (tag != null && tag != "") alert = Alert.getByTag(tag);
                if (alert == null) {
                    if (this.alertPrefab) {
                        var node = this._createPrefabOrNode(this.alertPrefab);
                        var popup = PopupManager.addPopup(node, this.layers.systemPopLayer, true);
                        NodeTool.center(popup.node);
                        popup.maskColor = this.alertMaskColor.clone();
                        NodeTool.show(popup.node);
                        alert = popup.node.getComponent(Alert);
                    }
                }
                if (alert) {
                    if (buttons == null) {
                        var ok = this.alertOk;
                        buttons = [ ok ];
                    }
                    alert.buttons = buttons;
                    if (text) alert.text = text;
                    if (title == null) {
                        title = this.alertTitle;
                    }
                    alert.title = title;
                    alert.onClose.offAll();
                    if (callback) alert.onClose.once(callback, thisArg);
                    if (tag) alert.tag = tag;
                    alert.defaultButtonIndex = 0;
                }
                return alert;
            },
            showAskAlert(text, title = null, tag = null, callback = null, thisArg = null, opt = null) {
                var args = this._getAlertArgs(title, tag, callback, thisArg);
                var ok = this.alertOk;
                var cancel = this.alertCancel;
                if (opt) {
                    ok = opt.ok || ok;
                    cancel = opt.cancel || cancel;
                }
                return this._showAlert(text, args.title || this.alertTitle, args.tag, args.callback, args.thisArg, [ ok, cancel ]);
            },
            _getAlertArgs(title, tag, callback, thisArg, buttons) {
                if (typeof title == "function") {
                    buttons = callback;
                    thisArg = tag;
                    callback = title;
                    title = null;
                    tag = null;
                } else if (typeof tag == "function") {
                    buttons = thisArg;
                    thisArg = callback;
                    callback = tag;
                    tag = null;
                }
                return {
                    title: title,
                    tag: tag,
                    callback: callback,
                    thisArg: thisArg,
                    buttons: buttons
                };
            },
            hideAlert(alertOrTag) {
                var node;
                if (alertOrTag instanceof cc.Node) node = alertOrTag; else if (alertOrTag instanceof Alert) node = alertOrTag.node; else if (typeof alertOrTag == "string") {
                    var alert = Alert.getByTag(alertOrTag);
                    if (alert) node = alert.node;
                }
                if (node) NodeTool.hide(node);
            },
            getAlert(alertOrTag) {
                var alert;
                if (alertOrTag instanceof cc.Node) alert = alertOrTag.getComponent(Alert); else if (alertOrTag instanceof Alert) alert = alertOrTag; else if (typeof alertOrTag == "string") {
                    alert = Alert.getByTag(alertOrTag);
                }
                return alert;
            },
            hideAllAlert() {
                if (this.layers.systemPopLayer.childrenCount > 0) {
                    var arr = this.layers.systemPopLayer.getComponentsInChildren(Alert);
                    if (arr) {
                        for (var i = 0; i < arr.length; i++) {
                            NodeTool.hide(arr[i].node);
                        }
                    }
                }
            },
            showMessage(text, type = null, mode = "add", offsetY = 0) {
                if (this.messagePrefab) {
                    let messageUI;
                    if (this.messageMode == MessageMode.FLOAT) {
                        let childrens = this.layers.messageLayer.getComponentsInChildren(MessaageUI);
                        if (mode === "update") {
                            if (childrens.length > 0) {
                                let children = childrens[childrens.length - 1];
                                if (children.text == text && text.type == type && children.node.isShow && DelayCall.has(this._hideMessage, children)) {
                                    DelayCall.addCall(this._hideMessage, children, this.messageAutoCloseTime);
                                    return;
                                }
                            }
                        }
                        let len = childrens.length;
                        if (len >= this.messageMax) {
                            let num = len - this.messageMax + 1;
                            let removes = childrens.slice(0, num);
                            for (let i = 0; i < num; i++) {
                                DelayCall.cancel(this._hideMessage, removes[i]);
                                NodeTool.hide(removes[i].node, false);
                            }
                            childrens = this.layers.messageLayer.getComponentsInChildren(MessaageUI);
                        }
                        len = childrens.length;
                        for (let i = 0; i < len; i++) {
                            let children = childrens[i];
                            children.node.runAction(cc.moveBy(.3, 0, children.node.height));
                        }
                        let node = this._createPrefabOrNode(this.messagePrefab);
                        node.parent = this.layers.messageLayer;
                        NodeTool.center(node);
                        messageUI = node.getComponent(MessaageUI);
                        node.y = node.y - node.height;
                        node.runAction(cc.moveBy(.3, 0, node.height + offsetY));
                    } else {
                        messageUI = this.layers.messageLayer.getComponentInChildren(MessaageUI);
                        if (messageUI == null) {
                            let node = this._createPrefabOrNode(this.messagePrefab);
                            node.parent = this.layers.messageLayer;
                            NodeTool.center(node);
                            messageUI = node.getComponent(MessaageUI);
                        }
                    }
                    if (this.messageBgPrefab) {
                        let name = "___gdk__message_bg___";
                        let messageBg = this.layers.messageLayer.getChildByName(name);
                        if (!messageBg) {
                            messageBg = this._createPrefabOrNode(this.messageBgPrefab);
                            messageBg.name = name;
                            messageBg.zIndex = -999;
                            messageBg.parent = this.layers.messageLayer;
                        }
                        NodeTool.show(messageBg);
                    }
                    messageUI.type = type;
                    messageUI.text = text;
                    NodeTool.show(messageUI.node);
                    DelayCall.addCall(this._hideMessage, messageUI, this.messageAutoCloseTime);
                }
            },
            hideAllMessage() {
                let childrens = this.layers.messageLayer.getComponentsInChildren(MessaageUI);
                for (let i = 0; i < childrens.length; i++) {
                    DelayCall.cancel(this._hideMessage, childrens[i]);
                    NodeTool.hide(childrens[i].node);
                }
                var name = "___gdk__message_bg___";
                var messageBg = this.layers.messageLayer.getChildByName(name);
                if (cc.isValid(messageBg)) {
                    NodeTool.hide(messageBg);
                }
            },
            _hideMessage() {
                this.node && NodeTool.hide(this.node, true, () => {
                    let gui = Tool.getSingleton(GUIManager);
                    let childrens = gui.layers.messageLayer.getComponentsInChildren(MessaageUI);
                    if (childrens.length == 1) {
                        let name = "___gdk__message_bg___";
                        let messageBg = gui.layers.messageLayer.getChildByName(name);
                        if (messageBg) {
                            NodeTool.hide(messageBg);
                        }
                    }
                });
            },
            getCurrentWaiting() {
                return this._waitingUI;
            },
            showWaiting(text = null, tag = null, timeout = 0, timeoutFun = null, thisArg = null, delay = 0) {
                if (typeof arguments[1] == "number") {
                    timeout = arguments[1];
                    timeoutFun = arguments[2];
                    thisArg = arguments[3];
                    delay = 0;
                    tag = null;
                } else if (typeof arguments[0] == "number") {
                    timeout = arguments[0];
                    timeoutFun = arguments[1];
                    thisArg = arguments[2];
                    delay = 0;
                    tag = null;
                    text = null;
                }
                this.hideWaiting(tag);
                if (delay > 0) {
                    let timeId = setTimeout(() => {
                        this._showWaitingLater(text, tag, timeout, timeoutFun, thisArg);
                    }, delay * 1e3);
                    this._waitingDelayMap.set(tag, timeId);
                } else {
                    this._showWaitingLater(text, tag, timeout, timeoutFun, thisArg);
                }
            },
            _showWaitingLater(text = null, tag = null, timeout = 0, timeoutFun = null, thisArg = null) {
                if (!cc.isValid(this._waitingUI)) {
                    let prefab = this.waitingPrefab;
                    if (prefab) {
                        let key = prefab.name + "#" + prefab.data._prefab.fileId;
                        this._waitingUI = PoolManager.getCacheOrPool(key);
                        if (!this._waitingUI) {
                            let pop = PopupManager.addPopupOne(prefab, this.layers.waitingLayer, true);
                            NodeTool.center(pop.node);
                            pop.maskColor = this.waitingMaskColor.clone();
                            this._waitingUI = pop.node;
                        } else if (!this._waitingUI.parent) {
                            PopupManager.addPopup(this._waitingUI, this.layers.waitingLayer, true);
                        }
                    }
                }
                if (cc.isValid(this._waitingUI)) {
                    this._waitingTagMap.set(tag, text);
                    NodeTool.show(this._waitingUI);
                    let ui = this._waitingUI.getComponent(WaitingUI);
                    if (ui) {
                        ui.text = text;
                    }
                    if (timeout > 0) {
                        if (this._waitingTimeoutMap.has(tag)) {
                            let callBack = this._waitingTimeoutMap.get(tag);
                            DelayCall.cancel(callBack, this);
                            this._waitingTimeoutMap.delete(tag);
                        }
                        let callBack = function() {
                            this.hideWaiting(tag);
                            if (timeoutFun) {
                                timeoutFun.call(thisArg);
                            }
                        };
                        DelayCall.addCall(callBack, this, timeout);
                        this._waitingTimeoutMap.set(tag, callBack);
                    }
                    if (this._waitingDelayMap.has(tag)) {
                        let timeId = this._waitingDelayMap.get(tag);
                        clearTimeout(timeId);
                        this._waitingDelayMap.delete(tag);
                    }
                }
                return this._waitingUI;
            },
            hideWaiting(tag = null) {
                if (this._waitingTagMap.has(tag)) {
                    let callBack = this._waitingTimeoutMap.get(tag);
                    if (callBack) {
                        this._waitingTimeoutMap.delete(tag);
                        DelayCall.cancel(callBack, this);
                    }
                    this._waitingTagMap.delete(tag);
                    if (this._waitingTagMap.size == 0) {
                        if (this._waitingUI) {
                            this._waitingUI = NodeTool.hide(this._waitingUI);
                        }
                    } else if (this._waitingUI) {
                        let ui = this._waitingUI.getComponent(WaitingUI);
                        if (ui) {
                            let values = this._waitingTagMap.values();
                            for (let value of values) {
                                ui.text = value;
                                break;
                            }
                        }
                    }
                }
                if (this._waitingDelayMap.has(tag)) {
                    let timeId = this._waitingDelayMap.get(tag);
                    clearTimeout(timeId);
                    this._waitingDelayMap.delete(tag);
                }
            },
            hideAllWaiting() {
                this._waitingTagMap.clear();
                this._waitingTimeoutMap.clear();
                this._waitingDelayMap.forEach(clearTimeout);
                this._waitingDelayMap.clear();
                if (this._waitingUI) {
                    this._waitingUI = NodeTool.hide(this._waitingUI);
                }
            },
            showPopupMenu(items, isMask = false, onClose = null, thisArg = null) {},
            hidePopupMenu() {},
            addPopupOneByOne(prefabOrNode, isMask = true, callBack = null, thisArg = null) {
                this._popupOneByOnes.push({
                    prefabOrNode: prefabOrNode,
                    isMask: isMask,
                    callBack: callBack,
                    thisArg: thisArg
                });
                if (this._popupOneByOnes.length == 1) this._checkNextPopup();
            },
            _checkNextPopup() {
                if (this._popupOneByOnes.length > 0) {
                    var obj = this._popupOneByOnes[0];
                    let popup = this.addPopup(obj.prefabOrNode, obj.isMask);
                    NodeTool.onHide(popup.node).once(() => {
                        this._popupOneByOnes.shift();
                        this._checkNextPopup();
                    }, this);
                    if (obj.callBack) {
                        obj.callBack.call(obj.thisArg, popup);
                    }
                }
            },
            addPopup(prefabOrNode, isMask = true, precb, cb, parentNode) {
                if (prefabOrNode == null) {
                    return;
                }
                let pop = null;
                let node = null;
                Tool.execSync(() => {
                    pop = PopupManager.get(prefabOrNode);
                    if (pop) {
                        node = pop.node;
                    } else {
                        node = this._createPrefabOrNode(prefabOrNode);
                        node.active = false;
                    }
                }).then(() => {
                    if (!cc.isValid(node)) return;
                    let parent = parentNode || this.layers.popupLayer;
                    if (pop && node) {
                        if (node.parent !== parent) {
                            pop = PopupManager.addPopupOne(node, parent, isMask);
                        }
                    } else {
                        pop = PopupManager.addPopupOne(node, parent, isMask);
                        if (pop && isMask) {
                            pop.maskColor = this.popupMaskColor.clone();
                            pop.maskAlpha = 0;
                        }
                    }
                    precb && pop && precb(pop);
                }).then(() => {
                    if (!pop) return;
                    if (!cc.isValid(pop.node)) return;
                    NodeTool.show(pop.node, true, e => {
                        if (cc.js.isString(e) && e.indexOf("error:") == 0) {
                            CC_DEBUG && cc.error(e);
                            try {
                                pop.node.destroy();
                            } catch (e) {}
                            pop.node = null;
                            return;
                        }
                        cb && Tool.callInNextTick(cb, pop);
                        cb = null;
                    });
                    if (pop && cc.isValid(pop.node)) {
                        let resId = Tool.getResIdByNode(pop.node);
                        let onHide = NodeTool.onHide(pop.node);
                        let thisArg = {};
                        onHide.on(() => {
                            onHide.targetOff(thisArg);
                            EventManager.emit("popup#" + resId + "#close");
                            EventManager.emit("popupclose", resId);
                            cb && cb(null);
                        }, thisArg);
                        EventManager.emit("popup#" + resId + "#open");
                        EventManager.emit("popupopen", resId);
                        this.onPopupChanged.emit(pop.node);
                    }
                });
            },
            pinTop(nodeOrPopup) {
                var node = nodeOrPopup;
                if (typeof node == "string") node = this.layers.popupLayer.getChildByName(node); else if (nodeOrPopup instanceof cc.Component) node = nodeOrPopup.node;
                if (node) {
                    node.zIndex = cc.macro.MAX_ZINDEX;
                }
            },
            unPinTop(nodeOrPopup) {
                var node = nodeOrPopup;
                if (typeof node == "string") node = this.layers.popupLayer.getChildByName(node); else if (nodeOrPopup instanceof cc.Component) node = nodeOrPopup.node;
                if (node) {
                    node.zIndex = 0;
                }
            },
            removePopup(nodeOrPopup) {
                if (typeof nodeOrPopup == "string") nodeOrPopup = this.getPopupByName(nodeOrPopup);
                if (nodeOrPopup) PopupManager.removePopup(nodeOrPopup);
            },
            getPopupByName(name) {
                var node = this.layers.popupLayer.getChildByName(name);
                if (node) node = node.getComponent(PopupComponent);
                return node;
            },
            getPopups() {
                let popups = this.layers.popupLayer.getComponentsInChildren(PopupComponent);
                return popups;
            },
            hasPopup() {
                return !!this.layers.popupLayer.getComponentInChildren(PopupComponent);
            },
            getPopup(nodeOrPrefab) {
                return PopupManager.get(nodeOrPrefab);
            },
            removeAllPopup() {
                if (this.layers.popupLayer.childrenCount > 0) {
                    let arr = this.layers.popupLayer.getComponentsInChildren(PopupComponent);
                    for (let i = 0; i < arr.length; i++) {
                        PopupManager.removePopup(arr[i]);
                    }
                }
            },
            addMenu(prefabOrNode) {
                if (prefabOrNode == null) return;
                var node = this._createPrefabOrNode(prefabOrNode);
                if (node) {
                    node.parent = this.layers.menuLayer;
                }
            },
            removeMenu(node) {
                if (node == null) return;
                NodeTool.hide(node);
            },
            removeAllMenu() {
                var menus = this.layers.popupLayer.children;
                for (let i = 0; i < menus.length; i++) {
                    NodeTool.hide(menus[i]);
                }
            },
            getCurrentView() {
                while (this._navViews.length > 0) {
                    var node = this._navViews[this._navViews.length - 1];
                    if (node && !node.__gdk_inPool__ && cc.isValid(node)) {
                        return node;
                    } else {
                        this._navViews.length--;
                    }
                }
                return null;
            },
            showView(prefabOrNode, precb, cb) {
                if (prefabOrNode == null) {
                    return;
                }
                let node = null;
                let current = null;
                Tool.execSync(() => {
                    node = this.getView(prefabOrNode.name);
                    if (node == null) {
                        node = this._createPrefabOrNode(prefabOrNode);
                        node.active = false;
                    }
                }).then(() => {
                    current = this.getCurrentView();
                    if (node && (current !== node || !node.active)) {
                        precb && precb(node);
                    } else {
                        node = null;
                        current = null;
                    }
                }).then(() => {
                    if (!cc.isValid(node)) return;
                    if (current) {
                        let hideMode = HideMode.DESTROY;
                        let config = current.config;
                        if (config) {
                            hideMode = Tool.validate(config.tempHidemode, config.hideMode, hideMode);
                        }
                        NodeTool.onHide(current).off(this._onHideView, this);
                        NodeTool.hide(current, false, hideMode);
                    }
                }).then(() => {
                    if (!cc.isValid(node)) return;
                    let i = this._navViews.indexOf(node);
                    if (i != -1) {
                        this._navViews.splice(i, 1);
                    }
                    this._navViews.push(node);
                    if (node.parent !== this.layers.viewLayer) {
                        node.parent = this.layers.viewLayer;
                    }
                }).then(() => {
                    if (!cc.isValid(node)) return;
                    NodeTool.show(node, true, e => {
                        if (cc.js.isString(e) && e.indexOf("error:") == 0) {
                            CC_DEBUG && cc.error(e);
                            let i = this._navViews.indexOf(node);
                            if (i != -1) {
                                this._navViews.splice(i, 1);
                            }
                            node.destroy();
                            node = null;
                            return;
                        }
                        cb && Tool.callInNextTick(cb, node);
                    });
                }).then(() => {
                    if (!cc.isValid(node)) return;
                    NodeTool.onHide(node).once(this._onHideView, this);
                    this._onViewChanged(node, current);
                });
            },
            _onViewChanged(node, old) {
                if (old) {
                    let resId = Tool.getResIdByNode(old);
                    EventManager.emit("view#" + resId + "#close");
                    EventManager.emit("viewclose", resId);
                }
                if (node) {
                    let resId = Tool.getResIdByNode(node);
                    EventManager.emit("view#" + resId + "#open");
                    EventManager.emit("viewopen", resId);
                }
                this.onViewChanged.emit(node, old);
            },
            hideView(prefabOrNode = null) {
                if (this._navViews.length == 0) return;
                if (prefabOrNode == null) prefabOrNode = this.getCurrentView();
                if (prefabOrNode == null) return;
                var node = this.getView(prefabOrNode.name);
                if (node == null) return;
                NodeTool.hide(node);
                this._onHideView(node);
            },
            _onHideView(node) {
                node instanceof cc.Component && (node = node.node);
                if (this._navViews.length == 0) return;
                if (node == null) return;
                let index = this._navViews.indexOf(node);
                if (index == -1) return;
                let current = this.getCurrentView();
                if (index < this._navViews.length - 1) {
                    this._navViews.splice(index, 1);
                } else {
                    this._navViews.length--;
                    current = this.getCurrentView();
                    if (current) {
                        const PanelManager = require("./gdk_PanelManager");
                        if (!PanelManager.hasDisableView) {
                            NodeTool.show(current);
                            NodeTool.onHide(current).once(this._onHideView, this);
                        }
                    }
                }
                this._onViewChanged(current, node);
            },
            backView() {
                this.hideView();
            },
            hideAllView(...exclude) {
                if (this._navViews.length > 0) {
                    var arr = [ ...this._navViews ];
                    this._navViews.length = 0;
                    if (exclude && exclude.length > 0) {
                        for (let i = exclude.length - 1; i >= 0; i--) {
                            let node = exclude[i];
                            if (arr.indexOf(node) < 0) {
                                exclude.splice(i, 1);
                            }
                        }
                    }
                    for (let i = arr.length - 1; i >= 0; i--) {
                        let node = arr[i];
                        let bool = !exclude || exclude.length < 1 || exclude.indexOf(node) < 0;
                        if (bool) {
                            if (node.active) {
                                NodeTool.hide(node, false, HideMode.DESTROY);
                            } else {
                                node.destroy();
                            }
                        }
                    }
                    if (exclude && exclude.length > 0) {
                        this._navViews.push(...exclude);
                        this.showView(this._navViews[this._navViews.length - 1]);
                    } else {
                        this._onViewChanged();
                    }
                }
            },
            getView(name) {
                for (var i = this._navViews.length - 1; i >= 0; i--) {
                    var node = this._navViews[i];
                    if (node == null || cc.isValid(node) == false || node.__gdk_inPool__) {
                        this._navViews.splice(i, 1);
                        continue;
                    }
                    if (node.name == name) {
                        return node;
                    }
                }
                return null;
            },
            showNodeToolTip(text, node, gap = 20, isUpFrist = true) {
                var pos = node.convertToWorldSpaceAR(cc.v2(0, 0));
                pos = this.layers.toolTipLayer.convertToNodeSpaceAR(pos);
                return this.showToolTip(text, pos.x, pos.y, gap, isUpFrist);
            },
            showToolTip(text, x, y, gap = 20, isUpFrist = true) {
                if (this.hasToolTip() == false) {
                    var node = this._createPrefabOrNode(this.toolTipPrefab);
                    if (node) this._toolTipUI = node.getComponent(ToolTip);
                }
                if (this._toolTipUI) {
                    if (this._toolTipUI.node.parent != this.layers.toolTipLayer) {
                        this._toolTipUI.node.parent = this.layers.toolTipLayer;
                        NodeTool.show(this._toolTipUI.node);
                        this.layers.toolTipLayer.on("touchstart", this._toolTipLayerTouch, this);
                    }
                    this._toolTipUI.text = text;
                    this._toolTipUI.node.setPosition(NodeTool.getPosInBox(this._toolTipUI.node, x, y, gap, isUpFrist));
                }
                return this._toolTipUI;
            },
            hideToolTip() {
                if (this.hasToolTip()) {
                    if (NodeTool.hide(this._toolTipUI.node) == null) this._toolTipUI = null;
                    this.layers.toolTipLayer.off("touchstart", this._toolTipLayerTouch, this);
                }
            },
            hasToolTip() {
                if (this._toolTipUI == null || cc.isValid(this._toolTipUI.node) == false || this._toolTipUI.__gdk_inPool__) return false;
                return true;
            },
            _toolTipLayerTouch(e) {
                if (this.hasToolTip()) {
                    if (e.target != this._toolTipUI.node && e.target.isChildOf(this._toolTipUI.node) == false) this.hideToolTip();
                } else this.layers.toolTipLayer.off("touchstart", this._toolTipLayerTouch, this);
            },
            addGuide(prefabOrNode) {
                var node = this._createPrefabOrNode(prefabOrNode);
                if (node) {
                    node.parent = this.layers.guideLayer;
                }
            },
            addDebug(prefabOrNode) {
                var node = this._createPrefabOrNode(prefabOrNode);
                if (node) {
                    node.parent = this.layers.debugLayer;
                }
            },
            lockScreen(timeout = 0) {
                if (this._lockScreen == null) {
                    this._lockScreen = new cc.Node();
                    this._lockScreen.addComponent(cc.BlockInputEvents);
                    var size = cc.director.getWinSize();
                    this._lockScreen.width = size.width * 2;
                    this._lockScreen.height = size.height * 2;
                    this._lockScreen.on("click", function() {
                        this.onLockScreenClick.emit();
                    }, this);
                }
                if (this._lockScreen.parent != this.layers.systemPopLayer) this._lockScreen.parent = this.layers.systemPopLayer;
                NodeTool.bringTop(this._lockScreen);
                if (timeout > 0) {
                    DelayCall.addCall(this.unLockScreen, this, timeout);
                }
            },
            unLockScreen() {
                if (this._lockScreen && this._lockScreen.parent) {
                    this._lockScreen.removeFromParent(false);
                }
            },
            isScreenLock() {
                return this._lockScreen && this._lockScreen.active;
            },
            _createPrefabOrNode(prefabOrNode) {
                if (prefabOrNode == null) {
                    return null;
                }
                var node;
                if (prefabOrNode instanceof cc.Node) {
                    if (cc.isValid(prefabOrNode)) {
                        node = prefabOrNode;
                    }
                } else {
                    let key = prefabOrNode.name + "#" + prefabOrNode.data._prefab.fileId;
                    node = PoolManager.getCacheOrPool(key);
                    if (node == null) {
                        node = cc.instantiate(prefabOrNode);
                        node.name = prefabOrNode.name;
                    }
                }
                return node;
            }
        };
        module.exports = Tool.getSingleton(GUIManager);
        cc._RF.pop();
    }, {
        "../Tools/gdk_NodeTool": 140,
        "../components/gdk_PopupComponent": 152,
        "../const/gdk_HideMode": 165,
        "../const/gdk_MessageMode": 167,
        "../core/gdk_DelayCall": 171,
        "../core/gdk_EventTrigger": 173,
        "../core/gdk_Tool": 178,
        "../gdk": 205,
        "../ui/gdk_Alert": 232,
        "../ui/gdk_LoadingUI": 234,
        "../ui/gdk_MessageUI": 235,
        "../ui/gdk_ToolTip": 240,
        "../ui/gdk_WaitingUI": 241,
        "./gdk_EventManager": 214,
        "./gdk_PanelManager": 218,
        "./gdk_PoolManager": 219,
        "./gdk_PopupManager": 220
    } ],
    216: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ff725cNNBlFzpak8b4epvBY", "gdk_ModuleManager");
        var Log = require("../Tools/gdk_Log");
        function ModuleManager(m) {
            return ModuleManager.get(m);
        }
        ModuleManager._moduleMap = new Map();
        ModuleManager._moduleDic = {};
        Object.defineProperty(ModuleManager, "count", {
            get: function() {
                return this._moduleMap.size;
            },
            enumerable: true,
            configurable: true
        });
        ModuleManager.add = function(modules, active = true) {
            if (modules instanceof Array) {
                var arr = [];
                for (let i = 0; i < modules.length; i++) {
                    arr.push(this._add(modules[i], active));
                }
                return arr;
            } else return this._add(modules, active);
        };
        ModuleManager.remove = function(modules) {
            if (modules instanceof Array) {
                for (let i = 0; i < modules.length; i++) {
                    this._remove(modules[i]);
                }
            } else this._remove(modules);
        };
        ModuleManager.setActive = function(m, active) {
            var o = this.get(m);
            if (o) {
                o.active = active;
            }
        };
        ModuleManager.isActive = function(m) {
            var o = this.get(m);
            return o && o.active;
        };
        ModuleManager.has = function(m) {
            if (m instanceof Function) return this._moduleMap.has(m);
            return this._moduleDic[m] != null;
        };
        ModuleManager.get = function(m) {
            let o;
            if (m instanceof Function) {
                o = this._moduleMap.get(m);
                if (o == null) {
                    o = this._add(m, true);
                }
            } else o = this._moduleDic[m];
            return o;
        };
        ModuleManager.reset = function(m) {
            var o = this.get(m);
            if (o) o.reset();
        };
        ModuleManager.resetAll = function() {
            for (const iterator of this._moduleMap.values) {
                iterator.reset();
            }
        };
        ModuleManager._add = function(mo, active = true) {
            if (this._moduleMap.has(mo) == false) {
                var m = new mo();
                if (active) m.active = active;
                return m;
            } else {
                Log.errorEnable && Log.error(`ModuleManager: ${mo.name} is exist`);
            }
            return this._moduleMap.get(mo);
        };
        ModuleManager._register = function(m) {
            var mo = m.constructor;
            var moduleName = m.moduleName;
            if (!moduleName) {
                Log.errorEnable && Log.error(`ModuleManager.register: moduleName is null`);
                return;
            }
            Log.logEnable && Log.log("ModuleManager._register moudle:" + moduleName);
            if (this._moduleMap.has(mo) == false && !this._moduleDic[moduleName]) {
                if (!m.moduleName) m.moduleName = moduleName;
                this._moduleMap.set(mo, m);
                this._moduleDic[moduleName] = m;
            } else {
                Log.errorEnable && Log.error(`ModuleManager: ${moduleName} is exist`);
            }
        };
        ModuleManager._remove = function(m) {
            var o = this.get(m);
            if (o) {
                o.destroy();
            }
        };
        ModuleManager._unregister = function(m) {
            var mo = m.constructor;
            if (this._moduleMap.has(mo)) {
                this._moduleMap.delete(mo);
                var moduleName = m.moduleName || m.name;
                delete this._moduleDic[moduleName];
                Log.logEnable && Log.log("ModuleManager._unregister moudle:" + moduleName);
            }
        };
        var EventTrigger = require("../core/gdk_EventTrigger");
        ModuleManager._eventTriggerDic = {};
        ModuleManager._eventTrggerCount = 0;
        ModuleManager.on = function(moduleName, eventType, callback, thisArg = null, priority = 0) {
            var trigger = this._getEventTrigger(moduleName, eventType, true);
            if (trigger) trigger.on(callback, thisArg, priority);
        };
        ModuleManager.once = function(moduleName, eventType, callback, thisArg = null, priority = 0) {
            var trigger = this._getEventTrigger(moduleName, eventType, true);
            if (trigger) trigger.once(callback, thisArg, priority);
        };
        ModuleManager.off = function(moduleName, eventType, callback, thisArg = null) {
            var trigger = this._getEventTrigger(moduleName, eventType, false);
            if (trigger) {
                trigger.off(callback, thisArg);
                if (trigger.count == 0) this._removeEventTrigger(moduleName, eventType);
            }
        };
        ModuleManager.targetOff = function(thisArg) {
            for (var key in this._eventTriggerDic) {
                var triggerDic = this._eventTriggerDic[key];
                if (triggerDic) {
                    for (var k in triggerDic) {
                        var trigger = triggerDic[k];
                        trigger.targetOff(thisArg);
                    }
                }
            }
        };
        ModuleManager._getEventTrigger = function(moduleName, eventType, autoCreate = false) {
            if (!moduleName || !eventType) return null;
            var trigger = null;
            if (moduleName instanceof Function) moduleName = moduleName.moduleName || moduleName.name;
            var triggerDic = this._eventTriggerDic[moduleName];
            if (triggerDic == null) {
                if (autoCreate) triggerDic = this._eventTriggerDic[moduleName] = {};
            } else trigger = triggerDic[eventType];
            if (trigger == null && autoCreate) {
                this._eventTrggerCount++;
                trigger = triggerDic[eventType] = EventTrigger.get();
            }
            return trigger;
        };
        ModuleManager._removeEventTrigger = function(moduleName, eventType) {
            if (!moduleName || !eventType) return null;
            var trigger = null;
            if (moduleName instanceof Function) moduleName = moduleName.moduleName || moduleName.name;
            var triggerDic = this._eventTriggerDic[moduleName];
            if (triggerDic) {
                trigger = triggerDic[eventType];
                if (trigger) {
                    delete triggerDic[eventType];
                    this._eventTrggerCount--;
                    trigger.release();
                }
            }
        };
        ModuleManager.emit = function(moduleName, eventType, p1 = null, p2 = null, p3 = null, p4 = null, p5 = null) {
            var trigger = this._getEventTrigger(moduleName, eventType, false);
            if (trigger) {
                var returnData = trigger.emit(p1, p2, p3, p4, p5);
                return returnData;
            }
        };
        ModuleManager.hasEvent = function(moduleName, eventType, callBack, thisArgs) {
            var trigger = this._getEventTrigger(eventType, false);
            if (trigger) {
                return trigger.has(callBack, thisArgs);
            }
            return false;
        };
        module.exports = ModuleManager;
        cc._RF.pop();
    }, {
        "../Tools/gdk_Log": 139,
        "../core/gdk_EventTrigger": 173
    } ],
    217: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "5f721bwuCJOYoRCy0WWqNKW", "gdk_MusicManager");
        const MusicId = require("../enums/gdk_MusicId");
        const DelayCall = require("../core/gdk_DelayCall");
        const ResourManager = require("./gdk_ResourceManager");
        const PanelManager = require("./gdk_PanelManager");
        const Tools = require("../core/gdk_Tool");
        var MusicManager = {
            _musices: [],
            _isOn: true,
            _isPause: false,
            _url: null,
            _volume: 1,
            prefix: "music",
            get isOn() {
                return this._isOn && cc.audioEngine.getMusicVolume() > 0;
            },
            set isOn(value) {
                if (value) {
                    this.on();
                } else {
                    this.off();
                }
            },
            get volume() {
                return this.getVolume();
            },
            set volume(value) {
                this.setVolume(value);
            },
            getVolume() {
                return this._volume;
            },
            setVolume(value) {
                if (this._volume == value) {
                    return;
                }
                this._volume = value;
                if (this.isPaused) {
                    value = 0;
                }
                cc.audioEngine.setMusicVolume(value);
            },
            on() {
                this._isOn = true;
                this.isOn && this._updateMusic();
            },
            off() {
                this._isOn = false;
                this._url = null;
                cc.audioEngine.stopMusic();
            },
            getCurrent() {
                let n = this._musices.length;
                if (n > 0) {
                    return this._musices[n - 1];
                }
                return null;
            },
            stop() {
                this._url = null;
                cc.audioEngine.stopMusic();
            },
            _addMusic(m) {
                let index = this._musices.indexOf(m);
                if (index != -1) {
                    this._musices.splice(index, 1);
                }
                this._musices.push(m);
                DelayCall.addCall(this._updateMusic, this);
            },
            _removeMusic(m) {
                let index = this._musices.indexOf(m);
                if (index != -1) {
                    if (index == this._musices.length - 1) {
                        this._musices.length--;
                    } else {
                        this._musices.splice(index, 1);
                    }
                    DelayCall.addCall(this._updateMusic, this);
                }
            },
            _updateMusic() {
                if (cc.game.isPaused()) {
                    return;
                }
                let music = this.getCurrent();
                if (this.isOn && music) {
                    if (music._audioClip) {
                        if (this._url != music._audioClip.nativeUrl) {
                            this._url = music._audioClip.nativeUrl;
                            cc.audioEngine.playMusic(music._audioClip, true);
                        }
                    } else {
                        let name = MusicId.getValue(music._musicName) || music._musicName;
                        if (name) {
                            let url = this.prefix + name;
                            let resId = Tools.getResIdByNode(music.node);
                            if (this._url != name) {
                                this._url = name;
                                ResourManager.loadRes(resId, url, cc.AudioClip, clip => {
                                    if (!cc.isValid(music.node)) return;
                                    if (!music.enabled) return;
                                    if (!this.isOn || this._isPause) return;
                                    if (this._url == name) {
                                        if (resId == "Scene#" + cc.director.getScene().name || PanelManager.isOpenOrOpening(resId)) {
                                            cc.audioEngine.playMusic(clip, true);
                                        }
                                    }
                                });
                            } else {
                                ResourManager.loadRes(resId, url, cc.AudioClip);
                            }
                        } else {
                            this._url = null;
                            cc.audioEngine.stopMusic();
                        }
                    }
                } else {
                    this._url = null;
                    cc.audioEngine.stopMusic();
                }
            },
            _pausedCallback() {
                this._isPause = true;
                cc.audioEngine.setMusicVolume(0);
                cc.audioEngine.pauseMusic();
            },
            _restoreCallback() {
                this._isPause = false;
                cc.audioEngine.setMusicVolume(this._volume);
                if (this.isOn && this._url) {
                    cc.audioEngine.resumeMusic();
                }
            }
        };
        module.exports = MusicManager;
        cc._RF.pop();
    }, {
        "../core/gdk_DelayCall": 171,
        "../core/gdk_Tool": 178,
        "../enums/gdk_MusicId": 200,
        "./gdk_PanelManager": 218,
        "./gdk_ResourceManager": 221
    } ],
    218: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "05a317b5RNG3rZ4/EB3k1b3", "gdk_PanelManager");
        const GUIManager = require("./gdk_GUIManager");
        const Log = require("../Tools/gdk_Log");
        const BasePanel = require("../ui/gdk_BasePanel");
        const NodeTool = require("../Tools/gdk_NodeTool");
        const PanelId = require("../enums/gdk_PanelId");
        const ResourceManager = require("./gdk_ResourceManager");
        const DelayCall = require("../core/gdk_DelayCall");
        const Tool = require("../core/gdk_Tool");
        const HideMode = require("../const/gdk_HideMode");
        const PanelManager = {
            isShowWaiting: true,
            loadingString: "正在加载..",
            loadErrorMessage: "您的网络不稳定,请稍后再试.",
            loadWaitingDelay: .5,
            loadTimeout: 10,
            _openingDic: {},
            _panelArgsDic: {},
            _openOneByOnes: [],
            preload(panelId, autoRelease) {
                autoRelease === void 0 && (autoRelease = true);
                let config = this.getConfig(panelId);
                if (config) {
                    panelId = config.__id__ || panelId;
                    ResourceManager.addPanelInBackground(panelId, autoRelease);
                } else {
                    return Log.error(`PanelManager.preLoad Error:panelId= ${panelId} is not config`);
                }
            },
            openOneByOne(panelId, callback, thisArg, opt) {
                this._openOneByOnes.push({
                    panelId: panelId,
                    callback: callback,
                    thisArg: thisArg,
                    opt: opt
                });
                if (this._openOneByOnes.length == 1) {
                    this._checkNextOpen();
                }
            },
            _checkNextOpen() {
                if (this._openOneByOnes.length > 0) {
                    var obj = this._openOneByOnes[0];
                    this.open(obj.panelId, p => {
                        var node = p;
                        if (p instanceof cc.Component) {
                            node = p.node;
                        }
                        NodeTool.onHide(node).once(() => {
                            this._openOneByOnes.shift();
                            this._checkNextOpen();
                        }, this);
                        if (obj.callBack) {
                            obj.callBack.call(obj.thisArg, p);
                        }
                    }, this, obj.opt);
                }
            },
            _prefabPrecallback(node, config) {
                let panelId = config.__id__;
                if (!cc.isValid(node)) {
                    delete this._openingDic[panelId];
                    this._closeWaiting(config);
                    return;
                }
                if (!this._openingDic[panelId]) {
                    node.destroy();
                    return;
                }
                node.config = config;
                node.__gdk_panelId__ = panelId;
                if (panelId) {
                    let panel = node.getComponent(BasePanel);
                    if (!panel) {
                        panel = node.addComponent(BasePanel);
                    }
                    panel.resId = panelId;
                }
                return true;
            },
            _prefabCallback(node, config, created) {
                let panelId = config.__id__;
                if (!cc.isValid(node)) {
                    delete this._openingDic[panelId];
                    this._closeWaiting(config);
                    return;
                }
                let callbacks = this._openingDic[panelId];
                if (!callbacks) {
                    node.destroy();
                    return;
                }
                created && created();
                delete this._openingDic[panelId];
                this._closeWaiting(config);
                for (let i = 0, n = callbacks.length; i < n; i++) {
                    let arr = callbacks[i];
                    let panel = node;
                    if (arr[2]) {
                        panel = node.getComponent(arr[2]);
                    }
                    arr[0].call(arr[1], panel);
                }
                return true;
            },
            open(panelId, callback, thisArg, opt) {
                let config = this.getConfig(panelId);
                if (config) {
                    panelId = config.__id__ || panelId;
                    if (!config.isNoExclusive) {
                        let arr = Object.keys(this._openingDic);
                        for (let i = 0, n = arr.length; i < n; i++) {
                            const id = arr[i];
                            if (id == panelId) continue;
                            if (this.get(id)) continue;
                            let cfg = this.getConfig(id);
                            if (cfg && !cfg.isKeep && cfg.isPopup == config.isPopup) {
                                this._closeOpening(cfg.__id__);
                            }
                        }
                    }
                    let path = config.prefab;
                    let classType = opt && opt.classType ? opt.classType : null;
                    if (this.isOpenOrOpening(panelId)) {
                        if (this._openingDic[panelId]) {
                            callback && this._openingDic[panelId].push([ callback, thisArg, classType ]);
                        } else {
                            let panel = this.get(panelId);
                            if (classType) {
                                panel = panel.getComponent(panel);
                            }
                            callback && callback.call(thisArg, panel);
                        }
                        return;
                    }
                    this._openingDic[panelId] = callback ? [ [ callback, thisArg, classType ] ] : [];
                    let onTimeoutCallback = opt && opt.onTimeoutCallback ? opt.onTimeoutCallback : null;
                    if (opt && opt.args) this.setArgs(panelId, opt.args);
                    if (this.isShowWaiting && config.isShowWaiting !== false) {
                        const tag = "__gdk_PanelManager__";
                        GUIManager.hideWaiting(tag);
                        GUIManager.showWaiting(this.loadingString, tag, config.isKeep ? 0 : this.loadTimeout, () => {
                            this.hide(panelId);
                            GUIManager.showMessage(this.loadErrorMessage);
                            onTimeoutCallback && onTimeoutCallback.call(thisArg);
                        }, this, this.loadWaitingDelay);
                    }
                    ResourceManager.loadResByPanel(panelId, null, null, err => {
                        if (!this._openingDic[panelId]) {
                            ResourceManager.releaseResByPanel(panelId);
                            return;
                        }
                        let prefab = ResourceManager.getResByUrl(path, cc.Prefab);
                        if (prefab) {
                            if (config.isPopup === true) {
                                if (opt && opt.parent) {
                                    if (!cc.isValid(opt.parent) || !opt.parent.activeInHierarchy) {
                                        if (config.parent) {
                                            config.parent = null;
                                            delete config.parent;
                                        }
                                        delete this._openingDic[panelId];
                                        this._closeWaiting(config);
                                        return;
                                    }
                                    config.parent = opt.parent;
                                } else if (config.parent) {
                                    config.parent = null;
                                    delete config.parent;
                                }
                                GUIManager.addPopup(prefab, config.isMask === true, pop => {
                                    if (!pop || !cc.isValid(pop.node)) {
                                        delete this._openingDic[panelId];
                                        this._closeWaiting(config);
                                        return;
                                    }
                                    config.isTouchMaskClose != null && (pop.isTouchMaskClose = config.isTouchMaskClose);
                                    config.maskAlpha != null && (pop.maskAlpha = config.maskAlpha);
                                    config.maskAlpha == null && (pop.maskAlpha = 180);
                                    config.maskColor != null && (pop.maskColor = config.maskColor);
                                    config.zIndex != null && (pop.node.zIndex = config.zIndex);
                                    opt && opt.pos && pop.node.setPosition(opt.pos);
                                    this._prefabPrecallback(pop.node, config);
                                }, pop => this._prefabCallback(pop ? pop.node : null, config, () => {
                                    if (!pop || !cc.isValid(pop.node)) {
                                        delete this._openingDic[panelId];
                                        this._closeWaiting(config);
                                        return;
                                    }
                                    config.isTouchMaskClose != null && (pop.isTouchMaskClose = config.isTouchMaskClose);
                                    config.maskAlpha != null && (pop.maskAlpha = config.maskAlpha);
                                    config.maskAlpha == null && (pop.maskAlpha = 180);
                                    config.maskColor != null && (pop.maskColor = config.maskColor);
                                    config.zIndex != null && (pop.node.zIndex = config.zIndex);
                                    opt && opt.pos && pop.node.setPosition(opt.pos);
                                    if (config.isDisableView) {
                                        let view = GUIManager.getCurrentView();
                                        if (cc.isValid(view)) {
                                            view.active = false;
                                            NodeTool.onHide(pop.node).once(() => {
                                                DelayCall.addCall(this._onHidePopup, this, 0);
                                            });
                                        }
                                    }
                                }), config.parent);
                            } else {
                                GUIManager.showView(prefab, node => {
                                    config.zIndex != null && (node.zIndex = config.zIndex);
                                    opt && opt.pos && node.setPosition(opt.pos);
                                    this._prefabPrecallback(node, config);
                                }, node => this._prefabCallback(node, config, () => {
                                    if (!cc.isValid(node)) return;
                                    config.zIndex != null && (node.zIndex = config.zIndex);
                                    opt && opt.pos && node.setPosition(opt.pos);
                                }));
                            }
                        } else {
                            GUIManager.showMessage(this.loadErrorMessage);
                            Log.errorEnable && Log.error(err);
                            delete this._openingDic[panelId];
                            this._closeWaiting(config);
                        }
                    });
                } else {
                    return Log.error(`PanelManager.open Error:panelId= ${panelId} is not config`);
                }
            },
            get hasDisableView() {
                for (let key in this._openingDic) {
                    let cfg = this.getConfig(key);
                    if (cfg && cfg.isDisableView) {
                        return true;
                    }
                }
                let popups = GUIManager.getPopups();
                for (let i = 0, n = popups.length; i < n; i++) {
                    let node = popups[i].node;
                    if (cc.isValid(node) && node.active && node.config && node.config.isDisableView) {
                        return true;
                    }
                }
                return false;
            },
            _onHidePopup() {
                if (this.hasDisableView) return;
                let current = GUIManager.getCurrentView();
                if (current) {
                    NodeTool.show(current, true, () => {
                        GUIManager._onViewChanged(current, null);
                    });
                    NodeTool.onHide(current).once(GUIManager._onHideView, GUIManager);
                }
            },
            _closeOpening(panelId) {
                let config = this.getConfig(panelId);
                if (config) {
                    panelId = config.__id__ || panelId;
                    if (this._openingDic[panelId]) {
                        ResourceManager.releaseResByPanel(panelId);
                        delete this._openingDic[panelId];
                        this._closeWaiting(config, panelId);
                    }
                }
            },
            _closeWaiting(config, panelId) {
                let isShowWaiting = this.isShowWaiting && config.isShowWaiting !== false;
                if (isShowWaiting) {
                    let has = true;
                    for (let key in this._openingDic) {
                        if (key == panelId) continue;
                        let cfg = this.getConfig(key);
                        if (cfg && cfg.isShowWaiting !== false) {
                            has = false;
                            break;
                        }
                    }
                    has && GUIManager.hideWaiting("__gdk_PanelManager__");
                }
            },
            getConfig(panelId) {
                let config = null;
                if (typeof panelId == "object" && panelId.prefab) {
                    config = panelId;
                } else {
                    config = PanelId.getValue(panelId);
                }
                return config;
            },
            get hasOpening() {
                for (let _ in this._openingDic) {
                    return true;
                }
                return false;
            },
            isOpening(panelId) {
                let node = this.get(panelId);
                if (node && NodeTool.isShow(node)) {
                    return false;
                } else {
                    let config = this.getConfig(panelId);
                    if (config) {
                        panelId = config.__id__ || panelId;
                        return !!this._openingDic[panelId];
                    }
                }
                return false;
            },
            isOpenOrOpening(panelId) {
                let node = this.get(panelId);
                if (node && NodeTool.isShow(node)) {
                    return true;
                } else {
                    let config = this.getConfig(panelId);
                    if (config) {
                        panelId = config.__id__ || panelId;
                        return !!this._openingDic[panelId];
                    }
                }
                return false;
            },
            get(panelId) {
                let config = this.getConfig(panelId);
                if (config) {
                    panelId = config.__id__ || panelId;
                    if (config.isPopup == null || config.isPopup) {
                        let parent = cc.isValid(config.parent) ? config.parent : GUIManager.layers.popupLayer;
                        return parent && this._get(panelId, parent);
                    } else if (GUIManager.layers.viewLayer) {
                        return this._get(panelId, GUIManager.layers.viewLayer);
                    }
                }
                return null;
            },
            _get(panelId, layer) {
                let children = layer.children;
                let panel;
                let n = children.length;
                if (n > 0) {
                    for (let i = 0; i < n; ++i) {
                        let node = children[i];
                        if (node.__gdk_panelId__ == panelId) {
                            panel = node;
                            break;
                        }
                    }
                }
                return panel;
            },
            hide(id) {
                var panel = this.get(id);
                if (panel) {
                    let hideMode = HideMode.DESTROY;
                    let config = panel.config;
                    if (config) {
                        hideMode = Tool.validate(config.tempHidemode, config.hideMode, hideMode);
                    }
                    NodeTool.hide(panel, true, hideMode);
                    let panelId = config.__id__;
                    if (this._openingDic[panelId]) {
                        delete this._openingDic[panelId];
                        this._closeWaiting(config);
                    }
                } else if (this.isOpening(id)) {
                    this._closeOpening(id);
                }
            },
            setArgs(panelId, ...args) {
                let config = this.getConfig(panelId);
                if (config) {
                    panelId = config.__id__ || panelId;
                    if (!args || args.length == 0) {
                        delete this._panelArgsDic[panelId];
                        return;
                    }
                    this._panelArgsDic[panelId] = args;
                }
            },
            getArgs(panelId, remove = true) {
                let config = this.getConfig(panelId);
                if (config) {
                    panelId = config.__id__ || panelId;
                    let args = this._panelArgsDic[panelId];
                    if (remove) {
                        delete this._panelArgsDic[panelId];
                    }
                    return args;
                }
            }
        };
        module.exports = PanelManager;
        cc._RF.pop();
    }, {
        "../Tools/gdk_Log": 139,
        "../Tools/gdk_NodeTool": 140,
        "../const/gdk_HideMode": 165,
        "../core/gdk_DelayCall": 171,
        "../core/gdk_Tool": 178,
        "../enums/gdk_PanelId": 201,
        "../ui/gdk_BasePanel": 233,
        "./gdk_GUIManager": 215,
        "./gdk_ResourceManager": 221
    } ],
    219: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "bf7a6Tvr0pNQ6XBiGzbnF6y", "gdk_PoolManager");
        const Pool = require("../core/gdk_Pool");
        const Cache = require("../core/gdk_Cache");
        const EventTrigger = require("../core/gdk_EventTrigger");
        const Log = require("../Tools/gdk_Log");
        var PoolManager = {
            onPut: new EventTrigger(),
            onGet: new EventTrigger(),
            onClear: new EventTrigger(),
            setCreateFun(key, fun) {
                var pool = _getPool(key, true);
                pool.createFun = fun;
            },
            getCreateFun(key) {
                var pool = _getPool(key, false);
                if (pool) {
                    return pool.createFun;
                }
                return null;
            },
            put(key, obj) {
                var pool = _getPool(key, true);
                pool.put(obj);
            },
            get(key) {
                var pool = _getPool(key, false);
                var obj = null;
                if (pool) {
                    obj = pool.get(obj);
                }
                return obj;
            },
            clear(key) {
                var pool = _getPool(key, false);
                if (pool) {
                    _putPool(key);
                }
            },
            clearAll() {
                for (var key in _poolDic) {
                    _putPool(key);
                }
            },
            clearInactivity(key) {
                var pool = _getPool(key, false);
                if (pool) {
                    pool.clearInactivity();
                }
            },
            clearAllInactivity() {
                for (var key in _poolDic) {
                    var pool = _poolDic[key];
                    pool.clearInactivity();
                }
            },
            getSize(key) {
                var pool = _getPool(key, false);
                if (pool) {
                    return pool.size;
                }
                return 0;
            },
            setSize(key, size) {
                var pool = _getPool(key, true);
                pool.size = size;
                return pool;
            },
            getCount(key) {
                var pool = _getPool(key, false);
                if (pool) {
                    return pool.count;
                }
                return 0;
            },
            getClearTime(key) {
                var pool = _getPool(key, false);
                if (pool) {
                    return pool.clearTime;
                }
                return 0;
            },
            setClearTime(key, time) {
                var pool = _getPool(key, true);
                pool.clearTime = time;
                return pool;
            },
            cache(key, obj, clearTime = 120, clearFun = null) {
                if (Cache.has(key)) {
                    Log.errorEnable && Log.error(`PoolManager.cache Error: ${key} has exist!! destroy this one`);
                    var node = null;
                    if (obj instanceof cc.Node) {
                        node = obj;
                    } else if (obj instanceof cc.Component) {
                        node = obj.node;
                    }
                    if (node) {
                        return node.destroy();
                    }
                    return;
                }
                if (obj != null) {
                    _unuseNodeOrComponent(obj);
                }
                if (obj instanceof cc.Component) {
                    var clearFunTemp = clearFun;
                    clearFun = function() {
                        if (clearFunTemp) clearFunTemp();
                        obj.node.destroy();
                    };
                }
                Cache.put(key, obj, clearTime, clearFun);
            },
            getCache(key) {
                var obj = Cache.get(key);
                if (obj != null) {
                    if (_isValid(obj)) {
                        _reuseNodeOrComponent(obj);
                    } else {
                        obj = null;
                    }
                }
                return obj;
            },
            unCache(key) {
                Cache.clear(key);
            },
            unCacheAll() {
                Cache.clearAll();
            },
            getCacheCount(key) {
                return Cache.count;
            },
            getCacheOrPool(key) {
                return PoolManager.getCache(key) || PoolManager.get(key);
            },
            isInCacheOrPool(obj) {
                return obj.__gdk_inPool__ == true;
            },
            __getPoolDic() {
                return _poolDic;
            }
        };
        var _poolDic = Object.create(null);
        function _getPool(key, autoCreate) {
            var pool = _poolDic[key];
            if (pool == null && autoCreate) {
                _poolDic[key] = pool = new Pool();
                pool.onGet = _onGet(key);
                pool.onPut = _onPut(key);
                pool.onClear = _onClear(key);
            }
            return pool;
        }
        function _putPool(key) {
            var pool = _poolDic[key];
            if (pool) {
                pool.clearAll();
                delete pool.onGet;
                delete pool.onPut;
                delete pool.onClear;
                delete _poolDic[key];
            }
        }
        function _onGet(key) {
            return function(obj) {
                if (_isValid(obj)) {
                    _reuseNodeOrComponent(obj);
                    PoolManager.onGet.emit(key, obj);
                }
            };
        }
        function _onPut(key) {
            return function(obj) {
                _unuseNodeOrComponent(obj);
                PoolManager.onPut.emit(key, obj);
            };
        }
        function _onClear(key) {
            return function(obj) {
                _destroyNodeOrComponent(obj);
                PoolManager.onClear.emit(key, obj);
            };
        }
        function _isValid(obj) {
            var node = null;
            if (obj instanceof cc.Node) {
                node = obj;
            } else if (obj instanceof cc.Component) {
                node = obj.node;
            }
            if (node) {
                return cc.isValid(obj, true);
            }
            return true;
        }
        function _reuseNodeOrComponent(obj) {
            var node = null;
            if (obj instanceof cc.Node) {
                node = obj;
            } else if (obj instanceof cc.Component) {
                node = obj.node;
            }
            if (node) {
                for (let i = 0, n = node._components.length; i < n; ++i) {
                    let comp = node._components[i];
                    if (comp.reuse) {
                        comp.reuse.call(comp);
                    }
                }
            }
        }
        function _unuseNodeOrComponent(obj) {
            var node = null;
            if (obj instanceof cc.Node) {
                node = obj;
            } else if (obj instanceof cc.Component) {
                node = obj.node;
            }
            if (node && node.parent) {
                node.removeFromParent(false);
                for (let i = 0, n = node._components.length; i < n; ++i) {
                    let comp = node._components[i];
                    if (comp.unuse) {
                        comp.unuse.call(comp);
                    }
                }
            }
        }
        function _destroyNodeOrComponent(obj) {
            var node = null;
            if (obj instanceof cc.Node) {
                node = obj;
            } else if (obj instanceof cc.Component) {
                node = obj.node;
            }
            if (node) {
                node.destroy();
            }
        }
        module.exports = PoolManager;
        cc._RF.pop();
    }, {
        "../Tools/gdk_Log": 139,
        "../core/gdk_Cache": 170,
        "../core/gdk_EventTrigger": 173,
        "../core/gdk_Pool": 176
    } ],
    220: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "babf1rGrK9JUpMFbR8BuZtL", "gdk_PopupManager");
        var PopupComponent;
        var NodeTool = require("../Tools/gdk_NodeTool");
        var PopupManager = {
            addPopup(nodeOrPrefab, parent, isMask = true) {
                if (nodeOrPrefab == null || parent == null) {
                    return null;
                }
                if (PopupComponent == null) {
                    PopupComponent = require("../components/gdk_PopupComponent");
                }
                var node = nodeOrPrefab;
                if (nodeOrPrefab instanceof cc.Prefab) {
                    node = cc.instantiate(nodeOrPrefab);
                    node.name = nodeOrPrefab.name;
                }
                if (node.parent != parent) {
                    node.parent = parent;
                }
                var pop = node.getComponent(PopupComponent);
                if (pop == null) {
                    pop = node.addComponent(PopupComponent);
                }
                pop.enabled = true;
                pop.isMask = isMask;
                return pop;
            },
            addPopupOne(nodeOrPrefab, parent, isMask = true) {
                if (nodeOrPrefab == null || parent == null) {
                    return null;
                }
                if (PopupComponent == null) {
                    PopupComponent = require("../components/gdk_PopupComponent");
                }
                var node = nodeOrPrefab;
                if (nodeOrPrefab instanceof cc.Prefab) {
                    var pop = PopupComponent._popupDic[node.name];
                    if (pop) {
                        if (pop.node.parent != parent) {
                            pop.node.parent = parent;
                        }
                        pop.enabled = true;
                        pop.isMask = isMask;
                        return pop;
                    } else {
                        node = cc.instantiate(nodeOrPrefab);
                        node.name = nodeOrPrefab.name;
                    }
                }
                return PopupManager.addPopup(node, parent, isMask);
            },
            has(nodeOrPrefabOrName) {
                return this.get(nodeOrPrefabOrName) != null;
            },
            get(nodeOrPrefabOrName) {
                if (nodeOrPrefabOrName == null || parent == null) {
                    return false;
                }
                if (PopupComponent == null) {
                    PopupComponent = require("../components/gdk_PopupComponent");
                }
                var pop = null;
                if (nodeOrPrefabOrName instanceof cc.Prefab) {
                    pop = PopupComponent._popupDic[nodeOrPrefabOrName.name];
                    return pop;
                } else if (nodeOrPrefabOrName instanceof cc.Node) {
                    for (var d in PopupComponent._popupDic) {
                        pop = PopupComponent._popupDic[d];
                        if (pop.node == nodeOrPrefabOrName) {
                            return pop;
                        }
                    }
                } else if (typeof nodeOrPrefabOrName == "string") {
                    pop = PopupComponent._popupDic[nodeOrPrefabOrName];
                    return pop;
                }
                return null;
            },
            removePopup(nodeOrPopup) {
                if (nodeOrPopup == null) {
                    return;
                }
                if (nodeOrPopup instanceof cc.Component) {
                    nodeOrPopup = nodeOrPopup.node;
                }
                var pop = nodeOrPopup.getComponent(PopupComponent);
                if (pop) {
                    pop.enabled = false;
                }
                NodeTool.hide(nodeOrPopup);
            }
        };
        module.exports = PopupManager;
        cc._RF.pop();
    }, {
        "../Tools/gdk_NodeTool": 140,
        "../components/gdk_PopupComponent": 152
    } ],
    221: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "46af7FpAk5FxokULeohFBpe", "gdk_ResourceManager");
        const PanelId = require("../enums/gdk_PanelId");
        const ModuleLoader = require("../core/gdk_ModuleLoader");
        const ResourceManager = {
            _loader: ModuleLoader,
            _lastLoadConfig: null,
            _loadingInBgEnabled: true,
            _excludeRelease: null,
            loadResByModule(panelId, modules, param, pcb, cb) {
                panelId === null && (panelId = 0);
                if (cb === void 0) {
                    cb = pcb;
                    pcb = void 0;
                }
                this._loader.loadModules(panelId, modules, pcb, (err, modules) => {
                    if (err) {
                        CC_DEBUG && cc.error(err);
                    } else {
                        cb && cb(err, param);
                    }
                });
            },
            loadResByPanel(panelId, param, pcb, cb) {
                var modules = this.getModuleByPanelName(panelId);
                if (cb === void 0) {
                    cb = pcb;
                    pcb = void 0;
                }
                this.loadResByModule(panelId, modules, param, pcb, (err, param) => {
                    if (err) {
                        CC_DEBUG && cc.error(err);
                    } else {
                        param = param || {};
                        param.panelName = panelId;
                        cb && cb(err, param);
                    }
                });
            },
            loadResArray(panelId, urls, pcb, cb) {
                panelId === null && (panelId = 0);
                if (cb === void 0) {
                    cb = pcb;
                    pcb = void 0;
                }
                this._loader.loadResArray(panelId, urls, pcb, (err, loadedRes) => {
                    if (err) {
                        CC_DEBUG && cc.error(err);
                    } else {
                        cb && cb(err, loadedRes);
                    }
                });
            },
            releaseRes(panelId, asset, type) {
                panelId == null && (panelId = 0);
                this._loader.releaseOneRes(panelId, asset, type);
            },
            releaseResByPanel(panelId) {
                panelId === null && (panelId = 0);
                this._loader.releaseRes(panelId);
            },
            releaseAll() {
                this._loader.releaseAll();
            },
            addModuleInBackground(modules, panelId) {
                if (!modules || modules.length < 1) return;
                if (!this._loadingInBgEnabled) return;
                if (panelId) {
                    this.loadResByModule(panelId, modules);
                } else {
                    this._loader.addLowPriorityModules(modules);
                }
            },
            addPanelInBackground(panelId, autoRelease) {
                var modules = this.getModuleByPanelName(panelId);
                this.addModuleInBackground(modules, autoRelease ? null : panelId);
            },
            addResInBackground(resArray, type, panelId) {
                if (!resArray || resArray.length < 1) return;
                this._loader.addLowPriorityResources(resArray, type, panelId);
            },
            getModuleByPanelName(panelId) {
                var modules;
                var info = PanelId.getValue(panelId);
                if (!info || !info.module) {
                    modules = [];
                } else {
                    modules = info.module instanceof Array ? info.module : [ info.module ];
                }
                if (info && info.prefab) {
                    let b = true;
                    for (let i = modules.length - 1; i >= 0; i--) {
                        let e = modules[i];
                        if (e && e.prefabs && e.prefabs.resArray && e.prefabs.resArray.indexOf(info.prefab) >= 0) {
                            b = false;
                            break;
                        }
                    }
                    if (b) {
                        modules.push({
                            prefabs: {
                                type: cc.Prefab,
                                resArray: [ info.prefab ]
                            }
                        });
                    }
                }
                return modules;
            },
            getResByUrl(url, type, panelId) {
                if (panelId !== void 0) {
                    panelId == null && (panelId = 0);
                    let res = this._loader.getRes(url, type);
                    if (res) {
                        this._loader.addResTo(panelId, res);
                    }
                    return res;
                }
                return this._loader.getRes(url, type);
            },
            loadRes(panelId, url, type, cb, ecb, isuuid) {
                panelId == null && (panelId = 0);
                if (cb === void 0 && ecb === void 0) {
                    let res = this._loader.getRes(url, type, isuuid);
                    if (res) {
                        this._loader.addResTo(panelId, res);
                        return;
                    }
                }
                this._loader.loadRes(panelId, url, type, (err, prefab) => {
                    if (err) {
                        CC_DEBUG && cc.error(err);
                        ecb && ecb(err);
                    } else {
                        cb && cb(prefab);
                    }
                }, isuuid);
            },
            loadResBy(panelId, uuid, type, cb, ecb) {
                this.loadRes(panelId, uuid, type, cb, ecb, true);
            },
            getInfoWithPath(url, type) {
                return cc.resources.getInfoWithPath(url, type);
            },
            addUnreleaseRes(url) {
                if (!this._excludeRelease) {
                    this._excludeRelease = [ url ];
                    return;
                }
                this._excludeRelease.push(url);
            }
        };
        Object.defineProperty(ResourceManager, "isLoading", {
            get() {
                return this._loader && this._loader.isLoading;
            },
            enumerable: true,
            configurable: true
        });
        module.exports = ResourceManager;
        cc._RF.pop();
    }, {
        "../core/gdk_ModuleLoader": 175,
        "../enums/gdk_PanelId": 201
    } ],
    222: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "a699b/RtVNDHptTDiUe059A", "gdk_SceneManager");
        const GUIManager = require("./gdk_GUIManager");
        const PanelManager = require("./gdk_PanelManager");
        const ResouceManager = require("./gdk_ResourceManager");
        const PoolManager = require("./gdk_PoolManager");
        const Log = require("../Tools/gdk_Log");
        var SceneManager = {
            loadingText: "正在加载场景...{2}%",
            loadingErrorText: "加载场景失败",
            destroyPopup: true,
            destroyView: true,
            load(scene, callback, thisArg = null) {
                if (scene) {
                    if (this.getScene().name != scene.name) {
                        for (let name in GUIManager.layers) {
                            let layer = GUIManager.layers[name];
                            let arr = layer.children;
                            for (let i = arr.length - 1; i >= 0; i--) {
                                let node = arr[i];
                                if (!node.__gdk__persistNode__) {
                                    node.destroy();
                                }
                            }
                        }
                        for (let key in PanelManager._openingDic) {
                            PanelManager.hide(key);
                        }
                        GUIManager._navViews.length = 0;
                        PoolManager.clearAll();
                        ResouceManager.releaseAll();
                        if (GUIManager.getCurrentLoading()) {
                            GUIManager.showLoading(this.loadingText, 0, 100);
                        }
                        let cacheLoaded = 0;
                        ResouceManager.loadResByModule("Scene#" + scene.name, this._getSceneModules(scene), null, (loaded, total) => {
                            if (!GUIManager.getCurrentLoading()) return;
                            if (loaded / total < cacheLoaded) return;
                            cacheLoaded = loaded / total;
                            GUIManager.showLoading(this.loadingText, loaded, total);
                        }, err => {
                            if (err) {
                                GUIManager.showLoading(this.loadingErrorText);
                                Log.error("SceneManager.preload Error! ", err);
                            } else {
                                cc.director.loadScene(scene.name, (err, res) => {
                                    if (err) {
                                        GUIManager.showLoading(this.loadingErrorText);
                                        Log.error("SceneManager.load Error! ", err);
                                    }
                                    if (callback) {
                                        callback.call(thisArg, err, res);
                                    }
                                });
                            }
                        });
                    } else {
                        if (callback) {
                            callback.call(thisArg, null, this.getScene());
                        }
                    }
                } else {
                    Log.error("SceneManager load Error,scene is null");
                }
            },
            preload(scene, autoRelease) {
                if (scene) {
                    ResouceManager.addModuleInBackground(this._getSceneModules(scene), autoRelease ? null : "Scene#" + scene.name);
                }
            },
            getScene() {
                return cc.director.getScene();
            },
            getSceneName() {
                var scene = this.getScene();
                return !!scene ? scene.name : null;
            },
            getCanvasNode: function() {
                var scene = this.getScene();
                var canvas = !!scene ? scene.getChildByName("Canvas") : null;
                return !!canvas ? canvas : null;
            },
            _getSceneModules(scene) {
                var modules = scene.resArr instanceof Array ? scene.resArr : [ scene.resArr ];
                modules.push({
                    scenes: {
                        type: "scene",
                        resArray: [ scene.name ]
                    }
                });
                return modules;
            }
        };
        module.exports = SceneManager;
        cc._RF.pop();
    }, {
        "../Tools/gdk_Log": 139,
        "./gdk_GUIManager": 215,
        "./gdk_PanelManager": 218,
        "./gdk_PoolManager": 219,
        "./gdk_ResourceManager": 221
    } ],
    223: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "7c102QhhA5MYoBQptP+hlf7", "gdk_SoundManager");
        var SoundId = require("../enums/gdk_SoundId");
        var ResourManager = require("./gdk_ResourceManager");
        var PanelManager = require("./gdk_PanelManager");
        var DelayCall = require("../core/gdk_DelayCall");
        var SoundManager = {
            _volume: 1,
            _isOn: true,
            _isPause: false,
            _stopQueue: [],
            prefix: "sound",
            get maxAudioCount() {
                return this._maxAudioCount;
            },
            set maxAudioCount(value) {
                this._maxAudioCount = value;
            },
            get isOn() {
                return this._isOn && cc.audioEngine.getEffectsVolume() > 0;
            },
            set isOn(value) {
                if (value) {
                    this.on();
                } else {
                    this.off();
                }
            },
            get volume() {
                return this._volume;
            },
            set volume(value) {
                this.setVolume(value);
            },
            getVolume() {
                return this._volume;
            },
            setVolume(value) {
                if (this._volume == value) {
                    return;
                }
                this._volume = value;
                if (this.isPaused) {
                    value = 0;
                }
                cc.audioEngine.setEffectsVolume(value);
            },
            on() {
                this._isOn = true;
            },
            off() {
                this._isOn = false;
                this.stop();
            },
            stop() {
                cc.audioEngine.stopAllEffects();
            },
            play(panelId, name, release) {
                if (!this.isOn || this._isPause) return;
                if (name instanceof cc.AudioClip) {
                    this.playAudio(name, release, panelId);
                    return;
                }
                if (typeof name == "number") {
                    name = SoundId.getValue(SoundId[name]);
                }
                if (!name) {
                    return;
                }
                let url = `${this.prefix}${name}`;
                let clip = ResourManager.getResByUrl(url, cc.AudioClip);
                if (clip) {
                    this.playAudio(clip, release, panelId);
                } else {
                    ResourManager.loadRes(panelId, url, cc.AudioClip, clip => {
                        if (panelId == "Scene#" + cc.director.getScene().name || PanelManager.isOpenOrOpening(panelId)) {
                            this.playAudio(clip, release, panelId);
                        } else if (release) {
                            ResourManager.releaseRes(panelId, clip);
                        }
                    });
                }
            },
            playAudio(audioClip, release, panelId) {
                if (!this.isOn || this._isPause) {
                    if (release && panelId) {
                        ResourManager.releaseRes(panelId, audioClip);
                    }
                    return;
                }
                let audioId = cc.audioEngine.playEffect(audioClip, false);
                cc.audioEngine.setFinishCallback(audioId, () => {
                    if (release && panelId) {
                        ResourManager.releaseRes(panelId, audioClip);
                        return;
                    }
                    this._stopQueue.push(audioId);
                    DelayCall.addCall(this._stopAudioProc, this, 0);
                });
            },
            _pausedCallback() {
                this._isPause = true;
                cc.audioEngine.setEffectsVolume(0);
                this.stop();
            },
            _restoreCallback() {
                this._isPause = false;
                cc.audioEngine.setEffectsVolume(this._volume);
            },
            _stopAudioProc() {
                let len = this._stopQueue.length;
                if (len > 0) {
                    for (let i = 0; i < len; i++) {
                        cc.audioEngine.stopEffect(this._stopQueue[i]);
                    }
                    this._stopQueue.length = 0;
                }
            }
        };
        module.exports = SoundManager;
        cc._RF.pop();
    }, {
        "../core/gdk_DelayCall": 171,
        "../enums/gdk_SoundId": 204,
        "./gdk_PanelManager": 218,
        "./gdk_ResourceManager": 221
    } ],
    224: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "fd6eeMYgqVMe6MXwgL/s+Mq", "gdk_BaseModule");
        var ModuleManager = require("../managers/gdk_ModuleManager");
        var BaseModuld = cc.Class({
            ctor() {
                this._events = {};
                this._onceEvents = {};
                this._active = false;
                var listener = this.constructor.__listener__;
                if (listener == null && this.listener) {
                    listener = this.constructor.__listener__ = [];
                    var obj = this.listener();
                    for (var i in obj) {
                        var arr = i.split(":");
                        var moduleName = arr[0];
                        var eventName = arr[1];
                        listener.push([ moduleName, eventName, obj[i] ]);
                    }
                }
                if (listener) {
                    for (var i = 0; i < listener.length; i++) {
                        var item = listener[i];
                        this.on(item[0], item[1], item[2]);
                    }
                }
            },
            properties: {
                moduleName: {
                    get() {
                        return this.constructor.moduleName || this.constructor.name;
                    },
                    visible: false
                }
            },
            _setActive(value) {
                if (this._active == value) return;
                this._active = value;
                for (const key in this._events) {
                    var dic = this._events[key];
                    for (const k in dic) {
                        if (value) {
                            ModuleManager.on(key, k, dic[k], this);
                        } else {
                            ModuleManager.off(key, k, dic[k], this);
                        }
                    }
                }
                for (const key in this._onceEvents) {
                    var dic = this._onceEvents[key];
                    for (const k in dic) {
                        if (dic[k]) {
                            if (value) ModuleManager.once(key, k, dic[k], this); else {
                                if (ModuleManager.hasEvent(key, k, dic[k], this) == false) {
                                    this._onceEvents[k] = null;
                                } else {
                                    ModuleManager.off(key, k, dic[k], this);
                                }
                            }
                        }
                    }
                }
            },
            on(moduleName, eventType, callback, thisArg = null) {
                if (eventType instanceof Function) {
                    callback = eventType;
                    eventType = moduleName;
                    moduleName = this.moduleName;
                } else {
                    moduleName = this._getModuleName(moduleName);
                }
                var dic = this._events[moduleName];
                if (dic == null) {
                    dic = this._events[moduleName] = {};
                }
                if (dic[eventType] == null) {
                    dic[eventType] = callback;
                    if (this._active) {
                        ModuleManager.on(moduleName, eventType, callback, thisArg || this);
                    }
                }
            },
            once(moduleName, eventType, callback, thisArg = null) {
                if (eventType instanceof Function) {
                    callback = eventType;
                    eventType = moduleName;
                    moduleName = this.moduleName;
                } else {
                    moduleName = this._getModuleName(moduleName);
                }
                var dic = this._onceEvents[moduleName];
                if (dic == null) {
                    dic = this._onceEvents[moduleName] = {};
                }
                if (dic[eventType] == null) {
                    dic[eventType] = callback;
                    if (this._active) {
                        ModuleManager.once(moduleName, eventType, callback, thisArg || this);
                    }
                }
            },
            off(moduleName, eventType, thisArg = null) {
                if (eventType == null) {
                    eventType = moduleName;
                    moduleName = this.moduleName;
                } else {
                    moduleName = this._getModuleName(moduleName);
                }
                var callback;
                var dic = this._events[moduleName];
                if (dic) {
                    callback = dic[eventType];
                    if (callback) {
                        delete dic[eventType];
                        if (this._active) {
                            ModuleManager.off(moduleName, eventType, callback, this);
                        }
                    }
                }
                dic = this._onceEvents[moduleName];
                if (dic) {
                    callback = dic[eventType];
                    if (callback) {
                        delete dic[eventType];
                        if (this._active) {
                            ModuleManager.off(moduleName, eventType, callback, thisArg || this);
                        }
                    }
                }
            },
            emit(eventType, p1, p2, p3, p4, p5) {
                if (this._active) {
                    ModuleManager.emit(this.moduleName, eventType, p1, p2, p3, p4, p5);
                }
            },
            sendEvent(moduleName, eventType, p1, p2, p3, p4, p5) {
                if (this._active) {
                    ModuleManager.emit(moduleName, eventType, p1, p2, p3, p4, p5);
                }
            },
            reset() {
                if (this.onReset) {
                    this.onReset();
                }
            },
            _getModuleName(moduleName) {
                if (moduleName instanceof Function) {
                    moduleName = moduleName.moduleName || moduleName.name;
                }
                return moduleName;
            }
        });
        module.exports = BaseModuld;
        cc._RF.pop();
    }, {
        "../managers/gdk_ModuleManager": 216
    } ],
    225: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "09b93prkt1BQbeH/sPgiZ3u", "gdk_Module");
        var ModuleManager = require("../managers/gdk_ModuleManager");
        var Module = cc.Class({
            extends: require("./gdk_BaseModule"),
            properties: {
                active: {
                    get() {
                        return this._active;
                    },
                    set(value) {
                        this._setActive(value);
                        if (this.update) {
                            if (value) {
                                cc.director.getScheduler().enableForTarget(this);
                                cc.director.getScheduler().scheduleUpdate(this, cc.Scheduler.PRIORITY_SYSTEM, false);
                            } else if (!value) {
                                cc.director.getScheduler().unscheduleUpdate(this);
                            }
                        }
                        if (value && this.onEnable) {
                            this.onEnable();
                        } else if (!value && this.onDisable) {
                            this.onDisable();
                        }
                    }
                }
            },
            ctor() {
                ModuleManager._register(this);
            },
            destroy() {
                this.active = false;
                ModuleManager._unregister(this);
                if (this.onDestroy) {
                    this.onDestroy();
                }
            }
        });
        module.exports = Module;
        cc._RF.pop();
    }, {
        "../managers/gdk_ModuleManager": 216,
        "./gdk_BaseModule": 224
    } ],
    226: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "77c60NFOAtLyaUpvX3DQP2N", "gdk_View");
        var View = cc.Class({
            extends: cc.Component,
            mixins: [ require("./gdk_BaseModule") ],
            ctor() {
                this.__onEnable = this.onEnable;
                this.onEnable = this._onEnable;
                this.__onDisable = this.onDisable;
                this.onDisable = this._onDisable;
            },
            _onEnable() {
                this._setActive(true);
                if (this.__onEnable) {
                    this.__onEnable();
                }
            },
            _onDisable() {
                this._setActive(false);
                if (this.__onDisable) {
                    this.__onDisable();
                }
            },
            onEnable() {},
            onDisable() {}
        });
        module.exports = View;
        cc._RF.pop();
    }, {
        "./gdk_BaseModule": 224
    } ],
    227: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "f4552MtrI1HmpKKnCXcD3eY", "gdk_AddPopupButton");
        var GUIManager = require("../../managers/gdk_GUIManager");
        var AddPopupButton = cc.Class({
            extends: require("./gdk_SoundButton"),
            editor: {
                menu: "gdk(Button)/AddPopupButton",
                disallowMultiple: false
            },
            properties: {
                prefab: {
                    default: null,
                    type: cc.Prefab
                },
                isMask: true
            },
            onClick() {
                let _super = cc.js.getSuper(this.__proto__.constructor);
                if (_super && _super.prototype && _super.prototype.onClick) {
                    _super.prototype.onClick.call(this);
                }
                GUIManager.addPopup(this.prefab, this.isMask);
            }
        });
        module.exports = AddPopupButton;
        cc._RF.pop();
    }, {
        "../../managers/gdk_GUIManager": 215,
        "./gdk_SoundButton": 231
    } ],
    228: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "b5e59z9W35Io4ONPXifpNkh", "gdk_CloseButton");
        var NodeTool = require("../../Tools/gdk_NodeTool");
        var CloseButton = cc.Class({
            extends: require("./gdk_SoundButton"),
            editor: {
                menu: "gdk(Button)/CloseButton",
                disallowMultiple: false
            },
            properties: {
                target: {
                    default: null,
                    type: cc.Node,
                    tooltip: CC_DEV && "可以为空，如果没配置则默认关闭父级。"
                }
            },
            onClick() {
                let _super = cc.js.getSuper(this.__proto__.constructor);
                if (_super && _super.prototype && _super.prototype.onClick) {
                    _super.prototype.onClick.call(this);
                }
                NodeTool.hide(this.target || this.node.parent);
            }
        });
        module.exports = CloseButton;
        cc._RF.pop();
    }, {
        "../../Tools/gdk_NodeTool": 140,
        "./gdk_SoundButton": 231
    } ],
    229: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "d9255CBRFdEYa1NE9CFW6hz", "gdk_ClosePanelButton");
        var PanelId = require("../../enums/gdk_PanelId");
        var PanelManager = require("../../managers/gdk_PanelManager");
        var ClosePanelButton = cc.Class({
            extends: require("./gdk_SoundButton"),
            editor: {
                menu: "gdk(Button)/ClosePanelButton",
                disallowMultiple: false
            },
            properties: {
                _panelName: "",
                _panel: {
                    get() {
                        return PanelId[this._panelName] || 0;
                    },
                    set(value) {
                        this._panelName = PanelId[value];
                    },
                    type: PanelId,
                    visible: true,
                    tooltip: CC_DEV && "如果没可选值，请先配置PanelId"
                }
            },
            onClick() {
                let _super = cc.js.getSuper(this.__proto__.constructor);
                if (_super && _super.prototype && _super.prototype.onClick) {
                    _super.prototype.onClick.call(this);
                }
                PanelManager.hide(this._panelName);
            }
        });
        module.exports = ClosePanelButton;
        cc._RF.pop();
    }, {
        "../../enums/gdk_PanelId": 201,
        "../../managers/gdk_PanelManager": 218,
        "./gdk_SoundButton": 231
    } ],
    230: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "352a6kUvlBBjL2ozul416/Y", "gdk_OpenPanelButton");
        var NodeTool = require("../../Tools/gdk_NodeTool");
        var PanelId = require("../../enums/gdk_PanelId");
        var PanelManager = require("../../managers/gdk_PanelManager");
        var OpenPanelButton = cc.Class({
            extends: require("./gdk_SoundButton"),
            editor: {
                menu: "gdk(Button)/OpenPanelButton",
                disallowMultiple: false
            },
            properties: {
                _panelName: "",
                _panel: {
                    get() {
                        return PanelId[this._panelName] || 0;
                    },
                    set(value) {
                        this._panelName = PanelId[value];
                    },
                    type: PanelId,
                    visible: true,
                    tooltip: CC_DEV && "如果没可选值，请先配置PanelId"
                },
                _onLoad: {
                    default: "",
                    visible: true,
                    tooltip: CC_DEV && "onLoad后触发，格式为:组件名:方法或属性名:参数,如:MyComponent:setTabIndex:1"
                }
            },
            onClick() {
                let _super = cc.js.getSuper(this.__proto__.constructor);
                if (_super && _super.prototype && _super.prototype.onClick) {
                    _super.prototype.onClick.call(this);
                }
                if (this._onLoad) {
                    PanelManager.open(this._panelName, panel => {
                        if (panel) {
                            let arr = this._onLoad.split(":");
                            let comName = arr[0];
                            let fun = arr[1];
                            let param = arr[2];
                            let params = param.split(",");
                            var coms = panel.getComponents(comName);
                            for (let i = 0; i < coms.length; i++) {
                                let com = coms[i];
                                if (fun in com) {
                                    if (com[fun] instanceof Function) {
                                        com[fun].apply(com, params);
                                    } else {
                                        com[fun] = param;
                                    }
                                }
                            }
                        }
                    }, this);
                } else {
                    PanelManager.open(this._panelName);
                }
            }
        });
        module.exports = OpenPanelButton;
        cc._RF.pop();
    }, {
        "../../Tools/gdk_NodeTool": 140,
        "../../enums/gdk_PanelId": 201,
        "../../managers/gdk_PanelManager": 218,
        "./gdk_SoundButton": 231
    } ],
    231: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "282e8BELC1PwKJcPU9/nTzu", "gdk_SoundButton");
        var ButtonSoundId = require("../../enums/gdk_ButtonSoundId");
        var SoundManager = require("../../managers/gdk_SoundManager");
        var Tools = require("../../core/gdk_Tool");
        var SoundButton = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(Button)/SoundButton",
                disallowMultiple: false
            },
            properties: {
                _soundName: "",
                _sound: {
                    get() {
                        return ButtonSoundId[this._soundName] || 0;
                    },
                    set(value) {
                        this._soundName = ButtonSoundId[value];
                    },
                    type: ButtonSoundId,
                    visible: true,
                    serializable: true,
                    tooltip: CC_DEV && "如果没可选值，请先配置ButtonSoundId"
                },
                _audioClip: {
                    default: null,
                    type: cc.AudioClip,
                    visible: true,
                    serializable: true,
                    tooltip: CC_DEV && "设置此值会覆盖sound的值,推荐使用sound设置，因为设置这里会影响场景加载速度，场景会把cc.AudioClip预加载进来"
                }
            },
            onLoad() {
                let btn = this.node.getComponent(cc.Button);
                if (btn) {
                    this.node.on("click", this.onClick, this);
                } else {
                    this.node.on("touchstart", this.onClick, this);
                }
            },
            onClick() {
                if (this._audioClip) {
                    SoundManager.playAudio(this._audioClip);
                } else {
                    let resId = Tools.getResIdByNode(this.node);
                    SoundManager.play(resId, ButtonSoundId.getValue(this._soundName));
                }
            }
        });
        module.exports = SoundButton;
        cc._RF.pop();
    }, {
        "../../core/gdk_Tool": 178,
        "../../enums/gdk_ButtonSoundId": 196,
        "../../managers/gdk_SoundManager": 223
    } ],
    232: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "d88ce/UzFhGfZBIFaJ4JQW5", "gdk_Alert");
        var BasePanel = require("./gdk_BasePanel");
        var DelayCall = require("../core/gdk_DelayCall");
        var NodeTool = require("../Tools/gdk_NodeTool");
        var EventTrigger = require("../core/gdk_EventTrigger");
        var i18n = require("../Tools/gdk_i18n");
        var _tagDic = {};
        var Alert = cc.Class({
            extends: BasePanel,
            editor: {
                menu: "gdk(UI)/Alert",
                disallowMultiple: false
            },
            properties: {
                _textField: {
                    default: null,
                    type: cc.Label,
                    serializable: true,
                    visible: true
                },
                _icon: {
                    default: null,
                    type: cc.Sprite,
                    serializable: true,
                    visible: true
                },
                _defalutButton: {
                    default: null,
                    type: cc.Button,
                    serializable: true,
                    visible: true
                },
                _normalButton: {
                    default: null,
                    type: cc.Button,
                    serializable: true,
                    visible: true
                },
                _text: "",
                text: {
                    get: function() {
                        return this._text;
                    },
                    set: function(value) {
                        if (this._text == value) return;
                        this._text = value;
                        this._updateText();
                        this.onTextChanged.emit();
                    },
                    visible: false
                },
                _iconPath: "",
                icon: {
                    get: function() {
                        return this._iconPath;
                    },
                    set: function(value) {
                        if (this._iconPath == value) return;
                        this._iconPath = value;
                        if (this._icon) {
                            if (this._iconPath instanceof cc.SpriteFrame) this._icon.SpriteFrame = this._iconPath; else {
                                this.loadRes(this._iconPath, cc.SpriteFrame, this._onIconLoaded);
                            }
                        }
                    },
                    visible: false
                },
                _buttonStrs: null,
                buttons: {
                    get: function() {
                        return this._buttonStrs;
                    },
                    set: function(value) {
                        this._buttonStrs = value;
                        this._updateButtons();
                    },
                    visible: false
                },
                _tag: null,
                tag: {
                    get() {
                        return this._tag;
                    },
                    set(value) {
                        if (this._tag) delete _tagDic[this._tag];
                        this._tag = value;
                        _tagDic[this._tag] = this;
                    },
                    visible: false
                },
                _defaultButtonIndex: 0,
                defaultButtonIndex: {
                    get() {
                        return this._defaultButtonIndex;
                    },
                    set(value) {
                        if (this._defaultButtonIndex = value) return;
                        this._defaultButtonIndex = value;
                        this._updateButtons();
                    },
                    visible: false
                },
                _buttonLetToRight: {
                    default: false,
                    serializable: true,
                    visible: true
                },
                buttonLetToRight: {
                    get() {
                        return this._buttonLetToRight;
                    },
                    set(value) {
                        if (this._buttonLetToRight = value) return;
                        this._buttonLetToRight = value;
                        this._updateButtons();
                    },
                    visible: false
                },
                onTextChanged: {
                    default: null,
                    serializable: false,
                    visible: false
                },
                _buttonArr: [],
                _buttonParent: null,
                _defaultIcon: null,
                _isLoaded: false,
                _timeoutButtonIndex: 0,
                _timeout: 0
            },
            statics: {
                getByTag(tag) {
                    return _tagDic[tag];
                }
            },
            ctor() {
                this.onTextChanged = EventTrigger.get();
            },
            onLoad() {
                this._buttonArr.push(this._defalutButton, this._normalButton);
                this._buttonParent = this._defalutButton.node.parent;
                this._isLoaded = true;
                this._defalutButton.node.active = false;
                this._normalButton.node.active = false;
                if (this._icon) this._defaultIcon = this._icon.spriteFrame;
                this._updateButtons();
            },
            onDestroy() {
                if (this._tag) {
                    delete _tagDic[this._tag];
                    this._tag = null;
                }
                this.onTextChanged.release();
                this.onTextChanged = null;
            },
            setTimeout(timeout, timeoutButton = -1) {
                this._timeout = timeout;
                this._timeoutButtonIndex = timeoutButton;
            },
            unuse() {
                let _super = cc.js.getSuper(this.__proto__.constructor);
                if (_super && _super.prototype && _super.prototype.unuse) {
                    _super.prototype.unuse.call(this);
                }
                this._iconPath = null;
                if (this._icon) this._icon.spriteFrame = this._defaultIcon;
                this._buttonStrs = null;
                this._text = "";
                this._textField.string = "";
                this._defaultButtonIndex = 0;
                this._buttonLetToRight = false;
                this._timeout = 0;
                if (this._tag) {
                    delete _tagDic[this._tag];
                    this._tag = null;
                }
                this.onTextChanged.offAll();
            },
            _onIconLoaded: (err, spriteFrame) => {
                if (err) {
                    cc.error(err.message || err);
                    return;
                }
                if (this._icon) this._icon.spriteFrame = spriteFrame;
            },
            _updateText() {
                NodeTool.callAfterUpdate(this._updateTextLate, this);
            },
            _updateTextLate() {
                this._textField.string = i18n.t(this._text);
            },
            _updateButtons() {
                NodeTool.callAfterUpdate(this._updateButtonsLate, this);
            },
            update(dt) {
                if (this._timeout > 0) {
                    let index = this._timeoutButtonIndex;
                    this._timeout -= dt;
                    if (index >= 0) {
                        for (let i = 0; i < this._buttonArr.length; i++) {
                            let button = this._buttonArr[i];
                            if (button.__time__) {
                                if (i == index) {
                                    button.__time__.string = Math.round(this._timeout);
                                    button.__time__.node.active = this._timeout > 0;
                                } else {
                                    button.__time__.node.active = false;
                                }
                            }
                        }
                    }
                    if (this._timeout < 0) {
                        this._timeout = 0;
                        this.close(this.index);
                    }
                }
            },
            _updateButtonsLate() {
                if (this._isLoaded == false || cc.isValid(this.node) == false) return;
                var index = this._buttonArr.indexOf(this._defalutButton);
                if (this._defaultButtonIndex < 0) {
                    if (this._defalutButton.node.parent) this._defalutButton.node.removeFromParent(false);
                    if (index != -1) this._buttonArr.splice(index, 1);
                } else {
                    if (this._defalutButton.node.parent == null) this._defalutButton.node.parent = this._buttonParent;
                    if (index == -1) this._buttonArr.add(this._defalutButton);
                }
                var buttonStrCount = this._buttonStrs ? this._buttonStrs.length : 0;
                while (this._buttonArr.length < buttonStrCount) {
                    var node = cc.instantiate(this._normalButton.node);
                    node.parent = this._buttonParent;
                    var button = node.getComponent(cc.Button);
                    this._buttonArr.push(button);
                }
                if (this._defaultButtonIndex >= 0) {
                    index = this._buttonArr.indexOf(this._defalutButton);
                    if (index != this._defaultButtonIndex) {
                        this._buttonArr.splice(index, 1);
                        if (this._defaultButtonIndex < this._buttonArr.length) this._buttonArr.splice(this._defaultButtonIndex, 0, this._defalutButton); else this._buttonArr.push(this._defalutButton);
                    }
                }
                for (let i = 0, n = this._buttonArr.length; i < n; i++) {
                    let button = this._buttonArr[i];
                    let s = this._buttonStrs ? this._buttonStrs[i] : null;
                    button.node.targetOff(this);
                    if (s) {
                        s = i18n.t(s);
                        button.node.active = true;
                        if (this._buttonLetToRight) button.node.setSiblingIndex(i); else button.node.setSiblingIndex(n - i - 1);
                        if (button.__label__ == null) {
                            button.__label__ = cc.find("Label", button.node);
                            if (button.__label__) button.__label__ = button.__label__.getComponent(cc.Label);
                        }
                        if (button.__label__ == null) button.__label__ = button.node.getComponentInChildren(cc.Label);
                        if (button.__label__) {
                            button.__label__.string = s || "";
                        }
                        if (button.__time__ == null) {
                            button.__time__ = cc.find("Time", button.node);
                            if (button.__time__) button.__time__ = button.__time__.getComponent(cc.Label);
                        }
                        if (button.__time__) {
                            button.__time__.node.active = false;
                        }
                        button.node.on("click", function() {
                            this.close(i);
                        }, this);
                    } else {
                        button.node.active = false;
                    }
                }
            }
        });
        module.exports = Alert;
        cc._RF.pop();
    }, {
        "../Tools/gdk_NodeTool": 140,
        "../Tools/gdk_i18n": 142,
        "../core/gdk_DelayCall": 171,
        "../core/gdk_EventTrigger": 173,
        "./gdk_BasePanel": 233
    } ],
    233: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "15a65RddahCF5KQfWgjbvyo", "gdk_BasePanel");
        var EventTrigger = require("../core/gdk_EventTrigger");
        var Tool = require("../core/gdk_Tool");
        var NodeTool = require("../Tools/gdk_NodeTool");
        var i18n = require("../Tools/gdk_i18n");
        var PanelId = require("../enums/gdk_PanelId");
        var HideMode = require("../const/gdk_HideMode");
        var ResourceManager = require("../managers/gdk_ResourceManager");
        var PoolManager = require("../managers/gdk_PoolManager");
        var Timer = require("../core/gdk_Timer");
        var EventManager = require("../managers/gdk_EventManager");
        var BasePanel = cc.Class({
            extends: cc.Component,
            editor: {
                disallowMultiple: false
            },
            properties: {
                _resId: 0,
                resId: {
                    get() {
                        return this._resId;
                    },
                    set(value) {
                        this._resId = value;
                    },
                    visible: false
                },
                config: {
                    get() {
                        if (CC_EDITOR) return;
                        return PanelId.getValue(this._resId);
                    },
                    visible: false
                },
                args: {
                    get() {
                        if (CC_EDITOR) return;
                        var PanelManager = require("../managers/gdk_PanelManager");
                        return PanelManager.getArgs(this._resId) || [];
                    },
                    visible: false
                },
                preloads: {
                    get() {
                        let config = this.config;
                        return config ? config.preloads : null;
                    },
                    visible: false
                },
                _preloadNames: [],
                _preloads: {
                    get() {
                        let ret = [];
                        for (let i = 0; i < this._preloadNames.length; i++) {
                            ret[i] = PanelId[this._preloadNames[i]] || 0;
                        }
                        return ret;
                    },
                    set(value) {
                        this._preloadNames = [];
                        for (let i = 0; i < value.length; i++) {
                            this._preloadNames[i] = PanelId[value[i]];
                        }
                    },
                    type: [ PanelId ],
                    visible: true,
                    tooltip: CC_DEV && "预加载列表，如果没可选值，请先配置PanelId"
                },
                _closeBtn: {
                    default: null,
                    type: cc.Button,
                    serializable: true,
                    visible: true
                },
                _titleLabel: {
                    default: null,
                    type: cc.Label,
                    serializable: true,
                    visible: true
                },
                _isShowCloseBtn: {
                    default: false,
                    serializable: true
                },
                isShowCloseBtn: {
                    type: cc.Boolean,
                    set(value) {
                        this._isShowCloseBtn = value;
                        if (this._closeBtn) {
                            this._closeBtn.node.active = value;
                        }
                    },
                    get() {
                        return this._isShowCloseBtn;
                    }
                },
                _title: "",
                title: {
                    type: cc.String,
                    visible: false,
                    set(value) {
                        this._title = value;
                        if (this._titleLabel) {
                            this._titleLabel.string = i18n.t(value);
                        }
                    },
                    get() {
                        return this._title;
                    }
                },
                onClose: {
                    default: null,
                    serializable: false,
                    visible: false
                }
            },
            ctor() {
                this.onClose = EventTrigger.get();
                [ "onLoad", "onEnable", "onDisable", "onDestroy" ].forEach(name => {
                    if (this[name]) {
                        let func = this[name];
                        this[name] = function() {
                            func.call(this);
                            this["_" + name].call(this);
                        };
                    } else {
                        this[name] = this["_" + name];
                        delete this["_" + name];
                    }
                });
            },
            _onLoad() {
                if (this._closeBtn) {
                    this._closeBtn.node.on("click", () => {
                        this.close(-1);
                    }, this);
                    this._closeBtn.node.active = this._isShowCloseBtn;
                }
            },
            _onEnable() {
                this._$N_preloads = [];
                let preloads = this.preloads;
                if (preloads instanceof Array) {
                    let a0 = preloads;
                    let n0 = a0 ? a0.length : 0;
                    if (n0 > 0) {
                        for (let i = 0; i < n0; i++) {
                            let val = cc.js.isString(a0[i]) ? PanelId.getValue(a0[i]) : a0[i];
                            if (val && this._$N_preloads.indexOf(val) === -1) {
                                this._$N_preloads.push(val);
                            }
                        }
                    }
                }
                preloads = this._preloadNames;
                if (preloads instanceof Array) {
                    let a0 = preloads;
                    let n0 = a0 ? a0.length : 0;
                    if (n0 > 0) {
                        for (let i = 0; i < n0; i++) {
                            let val = PanelId.getValue(a0[i]);
                            if (val && this._$N_preloads.indexOf(val) === -1) {
                                this._$N_preloads.push(val);
                            }
                        }
                    }
                }
                let a = this._$N_preloads;
                let n = a ? a.length : 0;
                if (n > 0) {
                    const PanelManager = require("../managers/gdk_PanelManager");
                    for (let i = 0; i < n; i++) {
                        PanelManager.preload(a[i]);
                    }
                }
            },
            _onDisable() {
                let a = this._$N_preloads;
                let n = a ? a.length : 0;
                if (n > 0) {
                    const PanelManager = require("../managers/gdk_PanelManager");
                    for (let i = 0; i < n; i++) {
                        let val = a[i];
                        let resId = val.__id__;
                        if (!PanelManager.isOpenOrOpening(resId)) {
                            let key = null;
                            let prefab = ResourceManager.getResByUrl(val.prefab, cc.Prefab);
                            if (prefab) {
                                key = prefab.name + "#" + prefab.data._prefab.fileId;
                            }
                            if (key == null || PoolManager.getCount(key) <= 0) {
                                ResourceManager.releaseResByPanel(resId);
                            }
                        }
                    }
                }
                let config = this.config;
                if (config) {
                    config.parent = null;
                    config.tempHidemode = null;
                    delete config.parent;
                    delete config.tempHidemode;
                }
            },
            _onDestroy() {
                this.onClose.release();
                this.onClose = null;
                Timer.clearAll(this);
                EventManager.targetOff(this);
                ResourceManager.releaseResByPanel(this._resId);
            },
            close(buttonIndex) {
                buttonIndex === void 0 && (buttonIndex = -1);
                if (this.onClose.emit(buttonIndex) == false) {
                    return;
                }
                let config = this.config;
                let hideVal = null;
                if (config) {
                    hideVal = config.onHide;
                    delete config.onHide;
                }
                if (buttonIndex == -1 && hideVal) {
                    if (hideVal.id) {
                        const PanelManager = require("../managers/gdk_PanelManager");
                        if (hideVal.args !== void 0) {
                            PanelManager.setArgs(hideVal.id, hideVal.args);
                        }
                        PanelManager.open(hideVal.id, this._closeAfter, this);
                    } else {
                        if (typeof hideVal.func === "function") {
                            hideVal.func();
                        }
                        this._closeAfter();
                    }
                } else {
                    this._closeAfter();
                }
            },
            _closeAfter() {
                if (!cc.isValid(this)) return;
                if (!cc.isValid(this.node)) return;
                this.onClose.offAll();
                let hideMode = HideMode.DESTROY;
                let config = this.config;
                if (config) {
                    hideMode = Tool.validate(config.tempHidemode, config.hideMode, hideMode);
                }
                NodeTool.hide(this.node, true, hideMode);
            },
            unuse() {
                this.onClose.offAll();
                this._isShowCloseBtn = false;
                this._title = "";
            },
            loadRes(url, type, cb) {
                ResourceManager.loadRes(this._resId, url, type, cb);
            },
            loadResByModule(modules, param, pcb, cb) {
                ResourceManager.loadResByModule(this._resId, modules, param, pcb, cb);
            },
            releaseRes(asset, type) {
                ResourceManager.releaseRes(this._resId, asset, type);
            }
        });
        module.exports = BasePanel;
        cc._RF.pop();
    }, {
        "../Tools/gdk_NodeTool": 140,
        "../Tools/gdk_i18n": 142,
        "../const/gdk_HideMode": 165,
        "../core/gdk_EventTrigger": 173,
        "../core/gdk_Timer": 177,
        "../core/gdk_Tool": 178,
        "../enums/gdk_PanelId": 201,
        "../managers/gdk_EventManager": 214,
        "../managers/gdk_PanelManager": 218,
        "../managers/gdk_PoolManager": 219,
        "../managers/gdk_ResourceManager": 221
    } ],
    234: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "715f6Mi6mBALZNf1UB/JgTG", "gdk_LoadingUI");
        var i18n = require("../Tools/gdk_i18n");
        var NodeTool = require("../Tools/gdk_NodeTool");
        var LoadingUI = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(UI)/LoadingUI",
                disallowMultiple: false
            },
            properties: {
                _label: {
                    default: null,
                    type: cc.Label,
                    serializable: true,
                    visible: true
                },
                _progressBar: {
                    default: null,
                    type: cc.ProgressBar,
                    serializable: true,
                    visible: true
                },
                _info: "",
                info: {
                    get: function() {
                        return this._info;
                    },
                    set: function(value) {
                        this._info = value;
                        this._updateInfo();
                    },
                    visible: false
                },
                _loaded: 0,
                loaded: {
                    get: function() {
                        return this._loaded;
                    },
                    set: function(value) {
                        this._loaded = value;
                        this._updateInfo();
                    },
                    visible: false
                },
                _total: 100,
                total: {
                    get: function() {
                        return this._total;
                    },
                    set: function(value) {
                        this._total = value;
                        this._updateInfo();
                    },
                    visible: false
                }
            },
            onEnable() {
                this._updateInfo();
            },
            unuse() {
                this._label = "";
                this._loaded = -1;
                this._total = -1;
                if (this._progressBar) this._progressBar.progress = 0;
                NodeTool.cancelCallBeforeDraw(this._updateInfoLate, this);
            },
            _updateInfo() {
                NodeTool.callBeforeDraw(this._updateInfoLate, this);
            },
            _updateInfoLate() {
                var p = 0;
                if (this._total > 0) {
                    p = this._loaded / this._total * 100;
                    if (this._label) {
                        var s = i18n.t(this._info);
                        s = s.replace("{0}", this._loaded).replace("{1}", this._total).replace("{2}", p.toFixed(2)).replace("{3}", p >> 0);
                        this._label.string = s;
                    }
                }
                if (this._progressBar) {
                    this._progressBar.progress = p * .01;
                }
            }
        });
        module.exports = LoadingUI;
        cc._RF.pop();
    }, {
        "../Tools/gdk_NodeTool": 140,
        "../Tools/gdk_i18n": 142
    } ],
    235: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "0166euw1bRP0rgXidOjhXmj", "gdk_MessageUI");
        var TextUI = require("./gdk_TextUI");
        var MessageUI = cc.Class({
            extends: TextUI,
            editor: {
                menu: "gdk(UI)/MessageUI",
                disallowMultiple: false
            },
            properties: {
                _type: "",
                type: {
                    get: function() {
                        return this._type;
                    },
                    set: function(value) {
                        if (this._type == value) return;
                        this._type = value;
                        this._updateType();
                    },
                    visible: false
                }
            },
            _updateType() {},
            reuse() {
                this.node.stopAllActions();
                this.node.setPosition(0, 0);
            }
        });
        module.exports = MessageUI;
        cc._RF.pop();
    }, {
        "./gdk_TextUI": 239
    } ],
    236: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ef65dc/RbJHQKcqhB30GmjH", "gdk_PageViewTabBar");
        var PageViewTabBar = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(UI)/PageViewTabBar",
                disallowMultiple: false
            },
            properties: {
                pageView: cc.PageView,
                _selectIndex: {
                    default: 0,
                    serializable: true,
                    visible: true
                },
                selectIndex: {
                    visible: false,
                    get() {
                        return this._selectIndex;
                    },
                    set(value) {
                        if (this._selectIndex == value) return;
                        this._selectIndex = value;
                        this.pageView.setCurrentPageIndex(value);
                        this._pageIndexChanaged();
                    }
                }
            },
            onLoad() {
                this.toggles = this.node.getComponentsInChildren(cc.Toggle);
                for (let i = 0; i < this.toggles.length; i++) {
                    let toggle = this.toggles[i];
                    toggle.node.on("toggle", function() {
                        toggle.isChecked = true;
                        this.selectIndex = i;
                    }, this);
                }
                this.pageView.node.on("page-turning", function() {
                    this._selectIndex = this.pageView.getCurrentPageIndex();
                    this._pageIndexChanaged();
                }, this);
            },
            start() {
                if (this._selectIndex != this.pageView.getCurrentPageIndex()) this.pageView.setCurrentPageIndex(this._selectIndex); else this._pageIndexChanaged();
            },
            _pageIndexChanaged() {
                for (let i = 0; i < this.toggles.length; i++) {
                    let toggle = this.toggles[i];
                    toggle.isChecked = i == this._selectIndex;
                }
            }
        });
        module.exports = PageViewTabBar;
        cc._RF.pop();
    }, {} ],
    237: [ function(require, module, exports) {}, {} ],
    238: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "1c3f0SyveVGnqqU9PcW2p3k", "gdk_Switcher");
        var EventTrigger = require("../core/gdk_EventTrigger");
        var Switcher = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(UI)/Switcher",
                disallowMultiple: false,
                requireComponent: cc.Button
            },
            properties: {
                isOn: {
                    default: true,
                    tooltip: CC_DEV && "i18n:COMPONENT.toggle.isOn",
                    notify: function() {
                        this._updateCheckMark();
                        this.onToggle.emit(this.isOn);
                    }
                },
                onNode: {
                    default: null,
                    type: cc.Node,
                    tooltip: CC_DEV && "i18n:COMPONENT.toggle.onNode"
                },
                offNode: {
                    default: null,
                    type: cc.Node,
                    tooltip: CC_DEV && "处于未选中状态时显示的图片"
                },
                onToggle: {
                    default: null,
                    visible: false,
                    serializable: false
                }
            },
            ctor() {
                this.onToggle = EventTrigger.get();
            },
            start() {
                this._updateCheckMark();
            },
            onDestroy() {
                this.onToggle.release();
                this.onToggle = null;
            },
            onEnable: function() {
                if (!CC_EDITOR) {
                    this._registerToggleEvent();
                }
            },
            onDisable: function() {
                if (!CC_EDITOR) {
                    this._unregisterToggleEvent();
                }
            },
            _updateCheckMark: function() {
                if (this.onNode) {
                    this.onNode.active = !!this.isOn;
                }
                if (this.offNode) this.offNode.active = !this.isOn;
            },
            _registerToggleEvent: function() {
                this.node.on("click", this.toggle, this);
            },
            _unregisterToggleEvent: function() {
                this.node.off("click", this.toggle, this);
            },
            check: function() {
                this.isOn = true;
            },
            uncheck: function() {
                this.isOn = false;
            },
            toggle() {
                this.isOn = !this.isOn;
            }
        });
        module.exports = Switcher;
        cc._RF.pop();
    }, {
        "../core/gdk_EventTrigger": 173
    } ],
    239: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "88578Qz321PRZzYhGLe/c57", "gdk_TextUI");
        var i18n = require("../Tools/gdk_i18n");
        var TextUI = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(UI)/TextUI",
                disallowMultiple: false
            },
            properties: {
                _label: {
                    default: null,
                    type: cc.Label,
                    serializable: true,
                    visible: true
                },
                _richText: {
                    default: null,
                    type: cc.RichText,
                    serializable: true,
                    visible: true
                },
                _text: "",
                text: {
                    visible: false,
                    get: function() {
                        return this._text;
                    },
                    set: function(value) {
                        if (this._text == value) return;
                        this._text = value || "";
                        let label = this._label || this._richText;
                        if (label) {
                            if (this._text) {
                                label.string = i18n.t(this._text);
                                label.node.active = true;
                            } else {
                                label.node.active = false;
                            }
                        }
                    }
                }
            },
            onLoad() {
                let label = this._label || this._richText;
                if (label) {
                    this._text = label.string;
                }
            }
        });
        module.exports = TextUI;
        cc._RF.pop();
    }, {
        "../Tools/gdk_i18n": 142
    } ],
    240: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "635c6nSJz1Oc7F/2a9vjuhC", "gdk_ToolTip");
        var TextUI = require("./gdk_TextUI");
        var ToolTip = cc.Class({
            extends: TextUI,
            editor: {
                menu: "gdk(UI)/ToolTip",
                disallowMultiple: false
            },
            properties: {}
        });
        module.exports = ToolTip;
        cc._RF.pop();
    }, {
        "./gdk_TextUI": 239
    } ],
    241: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ebaf9ccy7FM2qO6Cq1c20d6", "gdk_WaitingUI");
        var TextUI = require("./gdk_TextUI");
        var WaitingUI = cc.Class({
            extends: TextUI,
            editor: {
                menu: "gdk(UI)/WaitingUI",
                disallowMultiple: false
            },
            properties: {
                _icon: {
                    default: null,
                    type: cc.Node,
                    serializable: true,
                    visible: true
                }
            }
        });
        module.exports = WaitingUI;
        cc._RF.pop();
    }, {
        "./gdk_TextUI": 239
    } ],
    242: [ function(require, module, exports) {
        require("./gdk_Alert");
        require("./gdk_BasePanel");
        require("./gdk_LoadingUI");
        require("./gdk_MessageUI");
        require("./gdk_PageViewTabBar");
        require("./gdk_ScrollList");
        require("./gdk_Switcher");
        require("./gdk_TextUI");
        require("./gdk_ToolTip");
        require("./gdk_WaitingUI");
        require("./buttons/gdk_AddPopupButton");
        require("./buttons/gdk_CloseButton");
        require("./buttons/gdk_OpenPanelButton");
        require("./buttons/gdk_ClosePanelButton");
        require("./buttons/gdk_SoundButton");
        require("./list/gdk_BaseList");
        require("./list/gdk_ItemRenderer");
        require("./list/gdk_List");
        require("./list/gdk_TextItemRenderer");
    }, {
        "./buttons/gdk_AddPopupButton": 227,
        "./buttons/gdk_CloseButton": 228,
        "./buttons/gdk_ClosePanelButton": 229,
        "./buttons/gdk_OpenPanelButton": 230,
        "./buttons/gdk_SoundButton": 231,
        "./gdk_Alert": 232,
        "./gdk_BasePanel": 233,
        "./gdk_LoadingUI": 234,
        "./gdk_MessageUI": 235,
        "./gdk_PageViewTabBar": 236,
        "./gdk_ScrollList": 237,
        "./gdk_Switcher": 238,
        "./gdk_TextUI": 239,
        "./gdk_ToolTip": 240,
        "./gdk_WaitingUI": 241,
        "./list/gdk_BaseList": 243,
        "./list/gdk_ItemRenderer": 244,
        "./list/gdk_List": 245,
        "./list/gdk_TextItemRenderer": 246
    } ],
    243: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "c6bf4k08J5D8IxVphseBwB2", "gdk_BaseList");
        var DelayCall = require("../../core/gdk_DelayCall");
        var EventTrigger = require("../../core/gdk_EventTrigger");
        var NodeTool = require("../../Tools/gdk_NodeTool");
        var PoolManager = require("../../managers/gdk_PoolManager");
        var ItemRenderer = require("./gdk_ItemRenderer");
        var BaseList = cc.Class({
            extends: cc.Component,
            editor: {
                disallowMultiple: false
            },
            properties: {
                _itemRenderer: {
                    default: null,
                    type: cc.Prefab,
                    serializable: true,
                    visible: true,
                    toolTip: CC_DEV && "列表项"
                },
                _selectable: {
                    default: false,
                    serializable: true,
                    visible: true,
                    toolTip: CC_DEV && "列表项是否可以选中"
                },
                selectable: {
                    visible: false,
                    get() {
                        return this._selectable;
                    },
                    set(value) {
                        if (this._selectable == value) return;
                        this._selectable = value;
                        if (this._selectable == false && this._selectIndexs.length > 0) {
                            this._selectIndexs.length = 0;
                            for (var i = 0, n = _itemRenderers.length; i < n; i++) {
                                _itemRenderers[i]._setSelected(false);
                            }
                            this.onSelectChanged.emit();
                        }
                    }
                },
                _selectToggle: {
                    default: false,
                    serializable: true,
                    visible: true,
                    toolTip: CC_DEV && "选中的项是否可以再次点击时取消"
                },
                selectToggle: {
                    visible: false,
                    get() {
                        return this._selectToggle;
                    },
                    set(value) {
                        if (this._selectToggle == value) {
                            return;
                        }
                        this._selectToggle = value;
                    }
                },
                _isMultipleSelection: {
                    default: false,
                    serializable: true,
                    visible: true,
                    toolTip: CC_DEV && "是否可以多选"
                },
                isMultipleSelection: {
                    visible: false,
                    get() {
                        return this._isMultipleSelection;
                    },
                    set(value) {
                        if (this._isMultipleSelection == value) return;
                        this._isMultipleSelection = value;
                        if (this._isMultipleSelection == false && this._selectIndexs.length > 1) {
                            this._selectIndexs.length = 1;
                            for (var i = 1, n = _itemRenderers.length; i < n; i++) {
                                _itemRenderers[i]._setSelected(false);
                            }
                            this.onSelectChanged.emit();
                        }
                    }
                },
                async: {
                    default: false,
                    toolTip: CC_DEV && "开启异步模式，对于一次生成大量列表数据时，会每帧生成一个，不会造成瞬时阻塞，让程序平滑"
                },
                _datas: [],
                datas: {
                    visible: false,
                    get() {
                        return this._datas;
                    },
                    set(value) {
                        if (value != this._datas) {
                            this._selectIndexs.length = 0;
                        }
                        if (value && value.length > 0) {
                            this._datas = value;
                        } else {
                            this._datas.length = 0;
                        }
                        this._appendIndex = 0;
                        this.InvalidView();
                        this.onDataChanged.emit();
                    }
                },
                _selectIndexs: [],
                selectIndexs: {
                    visible: false,
                    get() {
                        return this._selectIndexs;
                    },
                    set(value) {
                        if (this._selectable) {
                            var isChanged = false;
                            if (value && value.length > 0) {
                                if (value.length > 1 && this._isMultipleSelection) {
                                    this._selectIndexs = value;
                                    isChanged = true;
                                } else if (value[0] != this._selectIndexs[0]) {
                                    this._selectIndexs[0] = value[0];
                                    isChanged = true;
                                }
                            } else {
                                isChanged = true;
                                this._selectIndexs.length = 0;
                            }
                            if (isChanged) {
                                this.updateItemSelect();
                                this.onSelectChanged.emit();
                            }
                        }
                    }
                },
                selectIndex: {
                    visible: false,
                    get() {
                        return this._selectIndexs && this._selectIndexs.length > 0 ? this._selectIndexs[0] : -1;
                    },
                    set(value) {
                        if (value < 0) {
                            this.selectIndexs = null;
                        } else if (value < this._datas.length) {
                            this.selectIndexs = [ value ];
                        }
                    }
                },
                onSelectChanged: {
                    default: null,
                    type: EventTrigger,
                    visible: false,
                    serializable: false
                },
                onDataChanged: {
                    default: null,
                    type: EventTrigger,
                    visible: false,
                    serializable: false
                },
                onItemClick: {
                    default: null,
                    type: EventTrigger,
                    visible: false,
                    serializable: false
                },
                onItemEvent: {
                    default: null,
                    type: EventTrigger,
                    visible: false,
                    serializable: false
                },
                _appendIndex: 0,
                _itemRenderers: []
            },
            ctor() {
                this.onSelectChanged = EventTrigger.get();
                this.onDataChanged = EventTrigger.get();
                this.onItemClick = EventTrigger.get();
                this.onItemEvent = EventTrigger.get();
            },
            onDestroy() {
                this.onSelectChanged.release();
                this.onDataChanged.release();
                this.onItemClick.release();
                this.onItemEvent.release();
                this.onSelectChanged = null;
                this.onDataChanged = null;
                this.onItemClick = null;
                this.onItemEvent = null;
                this._removeAllRenerer();
                this.unschedule(this._updateRenderer);
                DelayCall.cancel(this.updateView, this);
            },
            onEnable() {
                this.InvalidView();
            },
            onDisable() {
                this.unschedule(this._updateRenderer);
                this._appendingRenderer = false;
                DelayCall.cancel(this.updateView, this);
            },
            unuse() {
                this.onSelectChanged.offAll();
                this.onDataChanged.offAll();
                this.onItemClick.offAll();
                this.onItemEvent.offAll();
                this._selectIndexs.length = 0;
                this._datas.length = 0;
                this._selectable = false;
                this._isMultipleSelection = false;
                this._selectToggle = false;
                this._appendIndex = 0;
                this._removeAllRenerer();
                this.unschedule(this._updateRenderer);
                DelayCall.cancel(this.updateView, this);
            },
            addDatas(arr) {
                if (arr && arr.length > 0) {
                    if (this._datas == null || this._datas.length == 0) {
                        this._datas = arr;
                    } else {
                        this._datas = [ ...this._datas, ...arr ];
                    }
                    this.InvalidView();
                    this.onDataChanged.emit();
                }
            },
            addData(value) {
                this._datas.push(value);
                this.InvalidView();
                this.onDataChanged.emit();
            },
            addDataAt(value, index) {
                this._datas.splice(index, 0, value);
                var isSelectChanged = false;
                this._appendIndex = Math.min(this._appendIndex, index);
                for (var i = this._selectIndexs.length - 1; i >= 0; i--) {
                    if (this._selectIndexs[i] >= index) {
                        this._selectIndexs[i] = this._selectIndexs[i] + 1;
                        isSelectChanged = true;
                    }
                }
                this.InvalidView();
                if (isSelectChanged) {
                    this.onSelectChanged.emit();
                }
                this.onDataChanged.emit();
            },
            removeDataAt(index) {
                if (index < this.datas.length) {
                    this._datas.splice(index, 1);
                    var isSelectChanged = false;
                    this._appendIndex = Math.min(this._appendIndex, index);
                    for (var i = this._selectIndexs.length - 1; i >= 0; i--) {
                        if (this._selectIndexs[i] > index) {
                            this._selectIndexs[i] = this._selectIndexs[i] - 1;
                            isSelectChanged = true;
                        } else if (this._selectIndexs[i] == index) {
                            this._selectIndexs.splice(i, 1);
                            isSelectChanged = true;
                        }
                    }
                    this.InvalidView();
                    if (isSelectChanged) this.onSelectChanged.emit();
                    this.onDataChanged.emit();
                }
            },
            updateItem(index) {
                if (index < this._datas.length) {
                    for (var i = 0; i < this._itemRenderers.length; i++) {
                        var renderer = this._itemRenderers[i];
                        if (renderer.index == index) {
                            renderer._setData(this, index, this._datas[index], renderer.isSelected);
                            break;
                        }
                    }
                }
            },
            refresh() {
                this._appendIndex = 0;
                this.InvalidView();
            },
            updateItemSelect() {
                for (var i = this._selectIndexs.length - 1; i >= 0; i--) {
                    if (this._selectIndexs[i] > this._datas.length && this._selectIndexs[i] < 0) {
                        this._selectIndexs.splice(i, 1);
                    }
                }
                for (var i = 0; i < this._itemRenderers.length; i++) {
                    var renderer = this._itemRenderers[i];
                    renderer._setSelected(this._selectIndexs.indexOf(renderer.index) != -1);
                }
            },
            InvalidView() {
                DelayCall.addCall(this.updateView, this);
            },
            updateView() {
                this.removeRenererAfter(this._datas.length);
                this._appendRenderer();
            },
            _appendRenderer() {
                if (this._appendingRenderer) return;
                var len = this._datas.length;
                if (this.async) {
                    if (this._appendIndex < len) {
                        this._appendingRenderer = true;
                        this.schedule(this._updateRenderer, 0);
                    } else {
                        this._updateRenderer();
                    }
                } else {
                    for (var i = this._appendIndex, n = len; i < n; i++) {
                        this.updateRenderer(i);
                    }
                    this.unschedule(this._updateRenderer);
                    this._appendIndex = len;
                    this._appendingRenderer = false;
                }
            },
            _updateRenderer() {
                var len = this._datas.length;
                if (this._appendIndex < len) {
                    for (var i = 0; i < 3; i++) {
                        this.updateRenderer(this._appendIndex);
                        this._appendIndex++;
                        if (this._appendIndex >= len) break;
                    }
                } else {
                    this.unschedule(this._updateRenderer);
                    this._appendIndex = len;
                    this._appendingRenderer = false;
                }
            },
            removeRenererAfter(index) {},
            _removeAllRenerer() {
                for (var i = 0; i < this._itemRenderers.length; i++) {
                    var renderer = this._itemRenderers[i];
                    if (renderer.node) {
                        NodeTool.hide(renderer.node, false);
                    }
                }
                this._itemRenderers.length = 0;
            },
            getRenderer() {
                let prefab = this._itemRenderer;
                let key = prefab.name + "#" + prefab.data._prefab.fileId;
                let node = PoolManager.get(key);
                if (!node) {
                    node = cc.instantiate(prefab);
                }
                node.setPosition(0, 0);
                return node.getComponent(ItemRenderer);
            },
            updateRenderer(index) {},
            _itemClick(renderer) {
                var index = renderer.index;
                var data = renderer.data;
                this.onItemClick.emit(index, data);
                if (this._selectable) {
                    var arr = this._selectIndexs;
                    if (arr.length == 0) {
                        renderer._setSelected(true);
                        arr.push(index);
                        this.onSelectChanged.emit();
                    } else if (this.isMultipleSelection == false) {
                        if (arr[0] != index) {
                            arr[0] = index;
                            this.updateItemSelect();
                            this.onSelectChanged.emit();
                        } else if (this._selectToggle) {
                            arr.length = 0;
                            renderer._setSelected(false);
                            this.onSelectChanged.emit();
                        }
                    } else {
                        var i = arr.indexOf(index);
                        if (i == -1) {
                            arr.push(index);
                            renderer._setSelected(true);
                            this.onSelectChanged.emit();
                        } else if (this._selectToggle) {
                            arr.splice(i, 1);
                            renderer._setSelected(false);
                            this.onSelectChanged.emit();
                        }
                    }
                }
            }
        });
        module.exports = BaseList;
        cc._RF.pop();
    }, {
        "../../Tools/gdk_NodeTool": 140,
        "../../core/gdk_DelayCall": 171,
        "../../core/gdk_EventTrigger": 173,
        "../../managers/gdk_PoolManager": 219,
        "./gdk_ItemRenderer": 244
    } ],
    244: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "52f07pmUrROwqL4BUt4V55f", "gdk_ItemRenderer");
        var EventTrigger = require("../../core/gdk_EventTrigger");
        var ItemRenderer = cc.Class({
            extends: cc.Component,
            editor: {
                menu: "gdk(UI)/ItemRenderer",
                disallowMultiple: false
            },
            properties: {
                selectClip: {
                    default: null,
                    type: cc.Node
                },
                _data: null,
                data: {
                    visible: false,
                    get() {
                        return this._data;
                    }
                },
                _index: -1,
                index: {
                    visible: false,
                    get() {
                        return this._index;
                    }
                },
                _list: null,
                list: {
                    visible: false,
                    get() {
                        return this._list;
                    }
                },
                _isSelected: null,
                isSelected: {
                    visible: false,
                    get() {
                        return this._isSelected;
                    }
                },
                onSelectChanged: {
                    default: null,
                    type: EventTrigger,
                    visible: false,
                    serializable: false
                },
                onDataChanged: {
                    default: null,
                    type: EventTrigger,
                    visible: false,
                    serializable: false
                }
            },
            ctor() {
                this.onSelectChanged = EventTrigger.get();
                this.onDataChanged = EventTrigger.get();
            },
            onLoad() {
                this.node.on("touchend", this._triggerClick, this);
            },
            onDestroy() {
                this.onSelectChanged.release();
                this.onDataChanged.release();
                this.onSelectChanged = null;
                this.onDataChanged = null;
            },
            unuse() {
                this.onSelectChanged.offAll();
                this.onDataChanged.offAll();
                this._index = -1;
                this._data = null;
                this._list = null;
                this._isSelected = false;
            },
            _setData(list, index, data, isSelected) {
                this._list = list;
                this._data = data;
                this._index = index;
                this._isSelected = isSelected;
                this.updateView();
                if (this.selectClip) {
                    this.selectClip.active = this._isSelected;
                }
                this.onDataChanged.emit();
            },
            _setSelected(value) {
                if (this._isSelected == value) {
                    return;
                }
                this._isSelected = value;
                if (this.selectClip) {
                    this.selectClip.active = this._isSelected;
                }
                this.onSelectChanged.emit();
            },
            _triggerClick() {
                if (this._list) {
                    this._list._itemClick(this);
                }
            },
            triggerItemEvent(type) {
                if (this.list) {
                    this.list.onItemEvent.emit(type, this.index, this.data);
                }
            },
            updateView() {}
        });
        module.exports = ItemRenderer;
        cc._RF.pop();
    }, {
        "../../core/gdk_EventTrigger": 173
    } ],
    245: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "8ab61QkBw9BgbHk2SC1sJJv", "gdk_List");
        var NodeTool = require("../../Tools/gdk_NodeTool");
        var BaseList = require("./gdk_BaseList");
        var List = cc.Class({
            extends: BaseList,
            editor: {
                menu: "gdk(UI)/List",
                disallowMultiple: false
            },
            removeRenererAfter(index) {
                var len = this._itemRenderers.length;
                if (index >= len) return;
                for (var i = index; i < len; i++) {
                    var renderer = this._itemRenderers[i];
                    NodeTool.hide(renderer.node, false);
                }
                this._itemRenderers.length = index;
            },
            updateRenderer(index) {
                var renderer = this._itemRenderers[index];
                if (renderer == null) {
                    renderer = this.getRenderer();
                    renderer.node.parent = this.node;
                    this._itemRenderers[index] = renderer;
                }
                renderer._setData(this, index, this._datas[index], this._selectIndexs.indexOf(index) != -1);
                NodeTool.show(renderer.node);
            }
        });
        module.exports = List;
        cc._RF.pop();
    }, {
        "../../Tools/gdk_NodeTool": 140,
        "./gdk_BaseList": 243
    } ],
    246: [ function(require, module, exports) {
        "use strict";
        cc._RF.push(module, "ade70fsTn1Oe6Z7P4AvrB/I", "gdk_TextItemRenderer");
        var ItemRenderer = require("./gdk_ItemRenderer");
        var i18n = require("../../Tools/gdk_i18n");
        var TextItemRenderer = cc.Class({
            extends: ItemRenderer,
            editor: {
                menu: "gdk(UI)/TextItemRenderer",
                disallowMultiple: false
            },
            properties: {
                _label: {
                    default: null,
                    type: cc.Label,
                    serializable: true,
                    visible: true
                }
            },
            updateView() {
                this._label.string = i18n.t(this.data);
            }
        });
        module.exports = TextItemRenderer;
        cc._RF.pop();
    }, {
        "../../Tools/gdk_i18n": 142,
        "./gdk_ItemRenderer": 244
    } ]
}, {}, [ 205, 42 ]);